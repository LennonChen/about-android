<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0057)http://blog.csdn.net/luoshengyang/article/details/6882903 -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/javascript" async="" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ga.js"></script><script id="allmobilize" charset="utf-8" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/allmobilize.min.js"></script><style type="text/css"></style>
 <meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" media="handheld" href="http://blog.csdn.net/luoshengyang/article/details/6882903#">

    <title>Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅
        - 博客频道 - CSDN.NET</title>
    
    <meta name="description" content="在Android系统中，键盘按键事件是由WindowManagerService服务来管理的，然后再以消息的形式来分发给应用程序处理，不过和普通消息不一样，它是由硬件中断触发的；在上一篇文章《Android应用程序消息处理机制（Looper、Handler）分析》中，我们分析了Android应用程序的消息处理机制，本文将结合这种消息处理机制来详细分析Android应用程序是如何获得键盘按键消息的。">
    <script src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/jquery.js" type="text/javascript"></script>
    <script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ad.js"></script>
        <!--new top-->
       
        <link rel="stylesheet" href="http://static.csdn.net/public/common/toolbar/css/index.css">
        <!--new top-->

    <link rel="Stylesheet" type="text/css" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/style.css">
    <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://blog.csdn.net/Luoshengyang/rss/list">
    <link rel="shortcut icon" href="http://csdnimg.cn/public/favicon.ico">
    <link type="text/css" rel="stylesheet" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/default.css">
 


<script src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/share.js"></script><link href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/bdsstyle.css" rel="stylesheet" type="text/css"><script type="text/javascript" charset="utf-8" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/tracking.js"></script><script type="text/javascript" charset="utf-8" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/main.js"></script><link type="text/css" rel="stylesheet" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/style(1).css"><script src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/logger.js"></script><link rel="stylesheet" type="text/css" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/style(2).css"><link rel="stylesheet" href="http://bdimg.share.baidu.com/static/api/css/share_style0_16.css?v=f4b44e79.css"></head>
<body><iframe frameborder="0" style="display: none;"></iframe>
    
   
      <!--new top-->
    <script id="toolbar-tpl-scriptId" fixed="true" prod="blog" skin="black" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/html.js" type="text/javascript"></script><div class="csdn-toolbar csdn-toolbar-skin-black ">        <div class="container row center-block ">          <div class="col-md-3 pull-left logo clearfix"><a href="http://www.csdn.net/?ref=toolbar" title="CSDN首页" target="_blank" class="icon"></a><a title="频道首页" href="http://blog.csdn.net/?ref=toolbar_logo" target="_blank" class="img blog-icon"></a></div>          <div class="pull-right login-wrap unlogin">            <ul class="btns">              <li class="loginlink"><a href="https://passport.csdn.net/account/login?ref=toolbar" target="_top">登录&nbsp;</a>|<a target="_top" href="https://passport.csdn.net/account/register?ref=toolbar">&nbsp;注册</a></li>              <li class="search">                <div class="icon on-search-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <form action="http://so.csdn.net/search" method="get" target="_blank">                      <input type="hidden" value="toolbar" name="ref" accesskey="2">                      <div class="border">                        <input placeholder="搜索" type="text" value="" name="q" accesskey="2"><span class="icon-enter-sm"></span>                      </div>                    </form>                  </div>                </div>              </li>              <li class="favor">                <div class="icon on-favor-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div style="display:none;" class="favor-success"><span class="msg">收藏成功</span>                      <div class="btns"><span class="btn btn-primary ok">确定</span></div>                    </div>                    <div style="display:none;" class="favor-failed"><span class="icon-danger-lg"></span><span class="msg">收藏失败，请重新收藏</span>                      <div class="btns"><span class="btn btn-primary ok">确定</span></div>                    </div>                    <form role="form" class="form-horizontal favor-form">                      <div class="form-group">                        <div class="clearfix">                          <label for="input-title" class="col-sm-2 control-label">标题</label>                          <div class="col-sm-10">                            <input id="inputTitle" type="text" placeholder="" class="title form-control">                          </div>                        </div>                        <div class="alert alert-danger"><strong></strong>标题不能为空</div>                      </div>                      <div class="form-group">                        <label for="input-url" class="col-sm-2 control-label">网址</label>                        <div class="col-sm-10">                          <input id="input-url" type="text" placeholder="" class="url form-control">                        </div>                      </div>                      <div class="form-group">                        <label for="input-tag" class="col-sm-2 tag control-label">标签</label>                        <div class="col-sm-10">                          <input id="input-tag" type="text" class="form-control tag">                        </div>                      </div>                      <div class="form-group">                        <label for="input-description" class="description col-sm-2 control-label">摘要</label>                        <div class="col-sm-10">                          <textarea id="input-description" class="form-control description"></textarea>                        </div>                      </div>                      <div class="form-group">                        <div class="col-sm-offset-2 col-sm-10 ft">                          <div class="col-sm-4 pull-left">                            <div class="checkbox">                              <label>                                <input type="checkbox" name="share" checked="checked" class="share">公开                              </label>                            </div>                          </div>                          <div class="col-sm-8 pull-right favor-btns">                            <button type="button" class="cancel btn btn-default">取消</button>                            <button type="submit" class="submit btn btn-primary">收藏</button>                          </div>                        </div>                      </div>                    </form>                  </div>                </div>              </li>              <li class="notify">                <div style="display:none" class="number"></div>                <div style="display:none" class="icon-hasnotes-sm"></div>                <div id="header_notice_num"></div>                <div class="icon on-notify-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div id="note1" class="csdn_note">                      <div class="box"></div>                    <iframe src="about:block" frameborder="0" allowtransparency="true" style="z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:transparent"></iframe></div>                  </div>                </div>              </li>              <li class="ugc">                <div class="icon on-ugc-icon">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <dl>                      <dt><a href="http://geek.csdn.net/news/expert?ref=toolbar" target="_blank" class="p-news clearfix"><em class="icon"></em><span>分享资讯</span></a></dt>                      <dt><a href="http://share.csdn.net/slides/new?ref=toolbar" target="_blank" class="p-doc clearfix"><em class="icon"></em><span>传PPT/文档</span></a></dt>                      <dt><a href="http://bbs.csdn.net/topics/new?ref=toolbar" target="_blank" class="p-ask clearfix"><em class="icon"></em><span>提问题</span></a></dt>                      <dt><a href="http://write.blog.csdn.net/postedit?ref=toolbar" target="_blank" class="p-blog clearfix"><em class="icon"></em><span>写博客</span></a></dt>                      <dt><a href="http://u.download.csdn.net/upload?ref=toolbar" target="_blank" class="p-src clearfix"><em class="icon"></em><span>传资源</span></a></dt>                      <dt><a href="https://code.csdn.net/projects/new?ref=toolbar" target="_blank" class="c-obj clearfix"><em class="icon"></em><span>创建项目</span></a></dt>                      <dt><a href="https://code.csdn.net/snippets/new?ref=toolbar" target="_blank" class="c-code clearfix"><em class="icon"></em><span>创建代码片</span></a></dt>                    </dl>                  </div>                </div>              </li>              <li class="profile">                <div class="icon on-profile-icon"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/100x100.jpg" class="curr-icon-img">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div class="bd">                      <dl class="clearfix">                        <dt class="pull-left img"><a target="_blank" href="http://my.csdn.net/?ref=toolbar" class="avatar"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/100x100.jpg"></a></dt>                        <dd class="info"><a target="_blank" href="http://my.csdn.net/?ref=toolbar" class="nickname"></a><a class="set-nick" href="https://passport.csdn.net/account/profile">设置昵称<span class="write-icon"></span></a><span class="dec"><a class="fill-dec" href="http://my.csdn.net/" target="_blank">编辑自我介绍，让更多人了解你<span class="write-icon"></span></a></span></dd>                      </dl>                    </div>                    <div class="ft clearfix"><a target="_blank" href="http://my.csdn.net/my/account/changepwd?ref=toolbar" class="pull-left"><span class="icon-cog"></span>帐号设置</a><a href="https://passport.csdn.net/account/logout?ref=toolbar" target="_top" class="pull-right "><span class="icon-signout"></span><span class="out">退出</span></a></div>                  </div>                </div>              </li>              <li class="apps">                <div class="icon on-apps-icon">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                  <div class="detail">                    <dl>                      <dt>                        <h5>社区</h5>                      </dt>                      <dd> <a href="http://blog.csdn.net/?ref=toolbar" target="_blank">博客</a></dd>                      <dd> <a href="http://bbs.csdn.net/?ref=toolbar" target="_blank">论坛</a></dd>                      <dd> <a href="http://download.csdn.net/?ref=toolbar" target="_blank">下载</a></dd>                      <dd><a href="http://share.csdn.net/?ref=toolbar" target="_blank">Share</a></dd>                      <dd><a href="http://geek.csdn.net/?ref=toolbar" target="_blank">极客头条</a></dd>                    </dl>                  </div>                  <div class="detail">                    <dl>                      <dt>                        <h5>服务</h5>                      </dt>                      <dd> <a href="https://code.csdn.net/?ref=toolbar" target="_blank">CODE</a></dd>                      <dd> <a href="http://hero.csdn.net/?ref=toolbar" target="_blank">英雄会</a></dd>                      <dd> <a href="http://huiyi.csdn.net/?ref=toolbar" target="_blank">活动</a></dd>                      <dd> <a href="http://www.csto.com/?ref=toolbar" target="_blank">CSTO</a></dd>                    </dl>                  </div>                  <div class="detail last">                    <dl>                      <dt>                        <h5>俱乐部</h5>                      </dt>                      <dd> <a href="http://cto.csdn.net/?ref=toolbar" target="_blank">CTO俱乐部</a></dd>                      <dd> <a href="http://student.csdn.net/?ref=toolbar" target="_blank">高校俱乐部</a></dd>                    </dl>                  </div>                </div>              </div>            </li>            </ul>          </div>        </div>    </div>
     <!--new top-->
    <div id="container">
        <div id="header">
    <div class="header">
        <div id="blog_title">
            <h2>
                <a href="http://blog.csdn.net/luoshengyang">老罗的Android之旅</a></h2>
            <h3>爱生活，爱Android</h3>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>
                <li id="btnContents"><a href="http://blog.csdn.net/luoshengyang?viewmode=contents"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_mulu&#39;])">
                    <img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_list.gif">目录视图</span></a></li>
                <li id="btnView"><a href="http://blog.csdn.net/luoshengyang?viewmode=list"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_zhaiyao&#39;])">
                    <img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_summary.gif">摘要视图</span></a></li>
                <li id="btnRss"><a href="http://blog.csdn.net/luoshengyang/rss/list"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_RSS&#39;])">
                    <img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_rss.gif">订阅</span></a></li>                

            </ul>
    </div>
</div>
<script type="text/javascript">
    var username = "Luoshengyang";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/luoshengyang";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";  
</script>

        <div id="body">
            <div id="main">
                <div class="main">
                        <div class="ad_class">
<div class="notice tracking-ad" data-mod="popu_3"> 

<a href="http://bbs.csdn.net/topics/390812950?page=2#post-398116601" target="_blank">
<font color="blue">博客专家福利
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://bbs.csdn.net/topics/390863850" target="_blank">
<font color="red">【限时活动】建专辑得大奖</font></a>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://www.csdn.net/article/2014-09-10/2821606" target="_blank">
<font color="blue">专访荣浩：流程的永恒之道
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://blog.csdn.net/blogdevteam/article/details/38657235" target="_blank"><font color="red">当青春遇上互联网，能否点燃你的创业梦
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://blog.csdn.net/blogdevteam/article/details/38418263" target="_blank">
<font color="blue">推荐有礼--找出您心中的技术大牛
</font></a>


</div>                        </div>
                        

  
<link href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/comment1.css" type="text/css" rel="stylesheet">
<link href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/style1.css" type="text/css" rel="stylesheet">
<script language="JavaScript" type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/jquery.cookie.js"></script>
<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/main(1).js"></script>
<div id="article_details" class="details">
    <div class="article_title">   
         <span class="ico ico_type_Original"></span>


    <h1>
        <span class="link_title"><a href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET.html">
        Android应用程序键盘（Keyboard）消息处理机制分析
        </a></span>
    </h1>
</div>

    <div class="article_manage">
        <span class="link_categories">
        分类：
            <a href="http://blog.csdn.net/Luoshengyang/article/category/838604" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_fenlei&#39;]);">Android</a> 
        </span>
    <span class="link_postdate">2011-10-24 00:59</span>
    <span class="link_view" title="阅读次数">66790人阅读</span>
    <span class="link_comments" title="评论次数"><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#comments" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_pinglun&#39;])">评论</a>(188)</span>
    <span class="link_collect"><a href="javascript:void(0);" onclick="javascript:_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_shoucang&#39;]);collectArticle(&#39;Android应用程序键盘（Keyboard）消息处理机制分析&#39;,&#39;6882903&#39;);return false;" title="收藏">收藏</a></span>
    <span class="link_report"><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" onclick="javascript:_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_jubao&#39;]);report(6882903,2);return false;" title="举报">举报</a></span>
    
</div>
<div class="tag2box"><a href="http://www.csdn.net/tag/android" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">android</a><a href="http://www.csdn.net/tag/class" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">class</a><a href="http://www.csdn.net/tag/input" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">input</a><a href="http://www.csdn.net/tag/keyboard" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">keyboard</a><a href="http://www.csdn.net/tag/server" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">server</a></div>

  
    
<div id="article_content" class="article_content">
<p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在Android系统中，键盘按键事件是由WindowManagerService服务来管理的，然后再以消息的形式来分发给应用程序处理，不过和普通消息不一样，它是由硬件中断触发的；在上一篇文章《Android应用程序消息处理机制（Looper、Handler）分析》中，我们分析了Android应用程序的消息处理机制，本文将结合这种消息处理机制来详细分析Android应用程序是如何获得键盘按键消息的。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在系统启动的时候，SystemServer会启动窗口管理服务WindowManagerService，WindowManagerService在启动的时候就会通过系统输入管理器InputManager来总负责监控键盘消息。这些键盘消息一般都是分发给当前激活的Activity窗口来处理的，因此，当前激活的Activity窗口在创建的时候，会到WindowManagerService中去注册一个接收键盘消息的通道，表明它要处理键盘消息，而当InputManager监控到有键盘消息时，就会分给给它处理。当当前激活的Activity窗口不再处于激活状态时，它也会到WindowManagerService中去反注册之前的键盘消息接收通道，这样，InputManager就不会再把键盘消息分发给它来处理。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;由于本文的内容比较多，在接下面的章节中，我们将分为五个部分来详细描述Android应用程序获得键盘按键消息的过程，每一个部分都是具体描述键盘消息处理过程中的一个过程。结合上面的键盘消息处理框架，这四个过程分别是InputManager的启动过程、应用程序注册键盘消息接收通道的过程、InputManager分发键盘消息给应用程序的过程以及应用程序注销键盘消息接收通道的过程。为了更好地理解Android应用程序获得键盘按键消息的整个过程，建议读者首先阅读<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序消息处理机制（Looper、Handler）分析</a>一文，理解了Android应用程序的消息处理机制后，就能很好的把握本文的内容。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. InputManager的启动过程分析&nbsp;</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面说过，Android系统的键盘事件是由InputManager来监控的，而InputManager是由窗口管理服务WindowManagerService来启动的。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面一篇文章<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6768304">Android系统进程Zygote启动过程的源代码分析</a>中，我们知道在Android系统中，Zygote进程负责启动系统服务进程SystemServer，而系统服务进程SystemServer负责启动系统中的各种关键服务，例如我们在前面两篇文章<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6766010">Android应用程序安装过程源代码分析</a>和<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6767736">Android系统默认Home应用程序（Launcher）的启动过程源代码分析</a>中提到的Package管理服务PackageManagerService和Activity管理服务ActivityManagerService。这里我们所讨论的窗口管理服务WindowManagerService也是由SystemServer来启动的，具体的启动过程这里就不再详述了，具体可以参考PackageManagerService和ActivityManagerService的启动过程。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; 了解了WindowManagerService的启动过程之后，我们就可以继续分析InputManager的启动过程了。我们先来看一下InputManager启动过程的序列图，然后根据这个序列图来一步步分析它的启动过程：</p><p align="left"><img width="710" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/0_1319371717FBD2.gif" alt=""><br></p><p align="left" style="text-align: center;"><a target="_blank" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/0_1319371717FBD2.gif">点击查看大图</a></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. WindowManagerService.main</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java文件中：</p><p align="left"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 2098px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_1" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_1" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=1&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;WindowManagerService&nbsp;main(Context&nbsp;context,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PowerManagerService&nbsp;pm,&nbsp;<span class="keyword">boolean</span><span>&nbsp;haveInputMethods)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMThread&nbsp;thr&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;WMThread(context,&nbsp;pm,&nbsp;haveInputMethods);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thr.start();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(thr)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(thr.mService&nbsp;==&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thr.wait();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(InterruptedException&nbsp;e)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;thr.mService;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_1_2917148" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	public static WindowManagerService main(Context context,
			PowerManagerService pm, boolean haveInputMethods) {
		WMThread thr = new WMThread(context, pm, haveInputMethods);
		thr.start();

		synchronized (thr) {
			while (thr.mService == null) {
				try {
					thr.wait();
				} catch (InterruptedException e) {
				}
			}
			return thr.mService;
		}
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;它通过一个线程WMThread实例来执行全局唯一的WindowManagerService实例的启动操作。这里调用WMThread实例thr的start成员函数时，会进入到WMThread实例thr的run函数中去。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2. WMThread.run</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java文件中：<br></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 2699px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_2" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_2" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=2&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">static</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WMThread&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Thread&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;run()&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowManagerService&nbsp;s&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;WindowManagerService(mContext,&nbsp;mPM,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mHaveInputMethods);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_2_1281728" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	static class WMThread extends Thread {
		......

		public void run() {
			......

			WindowManagerService s = new WindowManagerService(mContext, mPM,
				mHaveInputMethods);
			......
		}
	}


	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这里执行的主要操作就是创建一个WindowManagerService实例，这样会调用到WindowManagerService构造函数中去。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; Step 3. WindowManagerService&lt;init&gt;</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的构造函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java文件中：</p><p align="left"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 3272px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_3" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_3" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=3&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;InputManager&nbsp;mInputManager;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;WindowManagerService(Context&nbsp;context,&nbsp;PowerManagerService&nbsp;pm,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;haveInputMethods)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputManager&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputManager(context,&nbsp;</span><span class="keyword">this</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputManager.start();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_3_6439941" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	final InputManager mInputManager;

	......

	private WindowManagerService(Context context, PowerManagerService pm,
			boolean haveInputMethods) {
		......

		mInputManager = new InputManager(context, this);

		......

		mInputManager.start();

		......
	}


	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这里我们只关心InputManager的创建过程，而忽略其它无关部分。首先是创建一个InputManager实例，然后再调用它的start成员函数来监控键盘事件。在创建InputManager实例的过程中，会执行一些初始化工作，因此，我们先进入到InputManager类的构造函数去看看，然后再回过头来分析它的start成员函数。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 4. InputManager&lt;init&gt;@java</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Java层的InputManager类的构造函数定义在frameworks/base/services/java/com/android/server/InputManager.java文件中：</p><p align="left"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 3961px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_4" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_4" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=4&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputManager&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;InputManager(Context&nbsp;context,&nbsp;WindowManagerService&nbsp;windowManagerService)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span><span>.mContext&nbsp;=&nbsp;context;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span><span>.mWindowManagerService&nbsp;=&nbsp;windowManagerService;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span><span>.mCallbacks&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Callbacks();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_4_4629798" name="code" class="java" style="display: none;">public class InputManager {
	......

	public InputManager(Context context, WindowManagerService windowManagerService) {
		this.mContext = context;
		this.mWindowManagerService = windowManagerService;

		this.mCallbacks = new Callbacks();

		init();
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里只是简单地初始化InputManager类的一些成员变量，然后调用init函数进一步执行初始化操作。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 5. InputManager.init</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/InputManager.java文件中：</p><p align="left"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 4392px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_5" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_5" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=5&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputManager&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;init()&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Slog.i(TAG,&nbsp;<span class="string">"Initializing&nbsp;input&nbsp;manager"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nativeInit(mCallbacks);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_5_6723349" name="code" class="java" style="display: none;">public class InputManager {
	......

	private void init() {
		Slog.i(TAG, "Initializing input manager");
		nativeInit(mCallbacks);
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 函数init通过调用本地方法nativeInit来执行C++层的相关初始化操作。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; Step 6. InputManager.nativeInit</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/services/jni$ vi com_android_server_InputManager.cpp文件中：<br></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 4751px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_6" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_6" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=6&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;android_server_InputManager_nativeInit(JNIEnv*&nbsp;env,&nbsp;jclass&nbsp;clazz,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;callbacks)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(gNativeInputManager&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gNativeInputManager&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;NativeInputManager(callbacks);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"Input&nbsp;manager&nbsp;already&nbsp;initialized."</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jniThrowRuntimeException(env,&nbsp;<span class="string">"Input&nbsp;manager&nbsp;already&nbsp;initialized."</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_6_6549408" name="code" class="cpp" style="display: none;">static void android_server_InputManager_nativeInit(JNIEnv* env, jclass clazz,
        jobject callbacks) {
    if (gNativeInputManager == NULL) {
        gNativeInputManager = new NativeInputManager(callbacks);
    } else {
        LOGE("Input manager already initialized.");
        jniThrowRuntimeException(env, "Input manager already initialized.");
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数的作用是创建一个NativeInputManager实例，并保存在gNativeInputManager变量中。由于是第一次调用到这里，因此，gNativeInputManager为NULL，于是就会new一个NativeInputManager对象出来，这样就会执行NativeInputManager类的构造函数来执其它的初始化操作。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; Step 7. NativeInputManager&lt;init&gt;</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;NativeInputManager类的构造函数定义在frameworks/base/services/jni$ vi com_android_server_InputManager.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 5170px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_7" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_7" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=7&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>NativeInputManager::NativeInputManager(jobject&nbsp;callbacksObj)&nbsp;:&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mFilterTouchEvents(-1),&nbsp;mFilterJumpyTouchEvents(-1),&nbsp;mVirtualKeyQuietTime(-1),&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mMaxEventsPerSecond(-1),&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mDisplayWidth(-1),&nbsp;mDisplayHeight(-1),&nbsp;mDisplayOrientation(ROTATION_0)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;JNIEnv*&nbsp;env&nbsp;=&nbsp;jniEnv();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mCallbacksObj&nbsp;=&nbsp;env-&gt;NewGlobalRef(callbacksObj);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;EventHub&gt;&nbsp;eventHub&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;EventHub();&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mInputManager&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputManager(eventHub,&nbsp;</span><span class="keyword">this</span><span>,&nbsp;</span><span class="keyword">this</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_7_1674603" name="code" class="cpp" style="display: none;">NativeInputManager::NativeInputManager(jobject callbacksObj) :
	mFilterTouchEvents(-1), mFilterJumpyTouchEvents(-1), mVirtualKeyQuietTime(-1),
	mMaxEventsPerSecond(-1),
	mDisplayWidth(-1), mDisplayHeight(-1), mDisplayOrientation(ROTATION_0) {
	JNIEnv* env = jniEnv();

	mCallbacksObj = env-&gt;NewGlobalRef(callbacksObj);

	sp&lt;EventHub&gt; eventHub = new EventHub();
	mInputManager = new InputManager(eventHub, this, this);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里只要是创建了一个EventHub实例，并且把这个EventHub作为参数来创建InputManager对象。注意，这里的InputManager类是定义在C++层的，和前面在Java层的InputManager不一样，不过它们是对应关系。EventHub类是真正执行监控键盘事件操作的地方，后面我们会进一步分析到，现在我们主要关心InputManager实例的创建过程，它会InputManager类的构造函数里面执行一些初始化操作。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 8. InputManager&lt;init&gt;@C++</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;C++层的InputManager类的构造函数定义在frameworks/base/libs/ui/InputManager.cpp&nbsp;文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 5625px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_8" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_8" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=8&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>InputManager::InputManager(&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;sp&lt;EventHubInterface&gt;&amp;&nbsp;eventHub,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;sp&lt;InputReaderPolicyInterface&gt;&amp;&nbsp;readerPolicy,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;sp&lt;InputDispatcherPolicyInterface&gt;&amp;&nbsp;dispatcherPolicy)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mDispatcher&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputDispatcher(dispatcherPolicy);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mReader&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputReader(eventHub,&nbsp;readerPolicy,&nbsp;mDispatcher);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;initialize();&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_8_944255" name="code" class="cpp" style="display: none;">InputManager::InputManager(
        const sp&lt;EventHubInterface&gt;&amp; eventHub,
        const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,
        const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) {
    mDispatcher = new InputDispatcher(dispatcherPolicy);
    mReader = new InputReader(eventHub, readerPolicy, mDispatcher);
    initialize();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里主要是创建了一个InputDispatcher对象和一个InputReader对象，并且分别保存在成员变量mDispatcher和mReader中。InputDispatcher类是负责把键盘消息分发给当前激活的Activity窗口的，而InputReader类则是通过EventHub类来实现读取键盘事件的，后面我们会进一步分析。创建了这两个对象后，还要调用initialize函数来执行其它的初始化操作。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 9. InputManager.initialize</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputManager.cpp&nbsp;文件中：<br></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 6026px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_9" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_9" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=9&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputManager::initialize()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mReaderThread&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputReaderThread(mReader);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mDispatcherThread&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputDispatcherThread(mDispatcher);&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_9_737294" name="code" class="cpp" style="display: none;">void InputManager::initialize() {
	mReaderThread = new InputReaderThread(mReader);
	mDispatcherThread = new InputDispatcherThread(mDispatcher);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数创建了一个InputReaderThread线程实例和一个InputDispatcherThread线程实例，并且分别保存在成员变量mReaderThread和mDispatcherThread中。这里的InputReader实列mReader就是通过这里的InputReaderThread线程实列mReaderThread来读取键盘事件的，而InputDispatcher实例mDispatcher则是通过这里的InputDispatcherThread线程实例mDisptacherThread来分发键盘消息的。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;至此，InputManager的初始化工作就完成了，在回到Step 3中继续分析InputManager的进一步启动过程之前，我们先来作一个小结，看看这个初始化过程都做什么事情：</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;A. 在Java层中的WindowManagerService中创建了一个InputManager对象，由它来负责管理Android应用程序框架层的键盘消息处理；</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;B. 在C++层也相应地创建一个InputManager本地对象来负责监控键盘事件；</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;C. 在C++层中的InputManager对象中，分别创建了一个InputReader对象和一个InputDispatcher对象，前者负责读取系统中的键盘消息，后者负责把键盘消息分发出去；</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;D.&nbsp;InputReader对象和一个InputDispatcher对象分别是通过InputReaderThread线程实例和InputDispatcherThread线程实例来实键盘消息的读取和分发的。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;有了这些对象之后，万事就俱备了，回到Step 3中，调用InputManager类的start函数来执行真正的启动操作。<br></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 10. InputManager.start</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/InputManager.java文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 6699px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_10" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_10" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=10&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputManager&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;start()&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Slog.i(TAG,&nbsp;<span class="string">"Starting&nbsp;input&nbsp;manager"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nativeStart();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_10_9450538" name="code" class="cpp" style="display: none;">public class InputManager {
	......

	public void start() {
		Slog.i(TAG, "Starting input manager");
		nativeStart();
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数通过调用本地方法nativeStart来执行进一步的启动操作。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 11. InputManager.nativeStart</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/jni$ vi com_android_server_InputManager.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 7058px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_11" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_11" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=11&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;android_server_InputManager_nativeStart(JNIEnv*&nbsp;env,&nbsp;jclass&nbsp;clazz)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(checkInputManagerUnitialized(env))&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;result&nbsp;=&nbsp;gNativeInputManager-&gt;getInputManager()-&gt;start();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jniThrowRuntimeException(env,&nbsp;<span class="string">"Input&nbsp;manager&nbsp;could&nbsp;not&nbsp;be&nbsp;started."</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_11_8163782" name="code" class="cpp" style="display: none;">static void android_server_InputManager_nativeStart(JNIEnv* env, jclass clazz) {
    if (checkInputManagerUnitialized(env)) {
        return;
    }

    status_t result = gNativeInputManager-&gt;getInputManager()-&gt;start();
    if (result) {
        jniThrowRuntimeException(env, "Input manager could not be started.");
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的gNativeInputManager对象是在前面的Step 6中创建的，通过它的getInputManager函数可以返回C++层的InputManager对象，接着调用这个InputManager对象的start函数。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 12. InputManager.start</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputManager.cpp&nbsp;文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 7443px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_12" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_12" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=12&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputManager::start()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;result&nbsp;=&nbsp;mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span><span>,&nbsp;PRIORITY_URGENT_DISPLAY);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"Could&nbsp;not&nbsp;start&nbsp;InputDispatcher&nbsp;thread&nbsp;due&nbsp;to&nbsp;error&nbsp;%d."</span><span>,&nbsp;result);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;result;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;mReaderThread-&gt;run(<span class="string">"InputReader"</span><span>,&nbsp;PRIORITY_URGENT_DISPLAY);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"Could&nbsp;not&nbsp;start&nbsp;InputReader&nbsp;thread&nbsp;due&nbsp;to&nbsp;error&nbsp;%d."</span><span>,&nbsp;result);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mDispatcherThread-&gt;requestExit();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;result;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_12_7433434" name="code" class="cpp" style="display: none;">status_t InputManager::start() {
	status_t result = mDispatcherThread-&gt;run("InputDispatcher", PRIORITY_URGENT_DISPLAY);
	if (result) {
		LOGE("Could not start InputDispatcher thread due to error %d.", result);
		return result;
	}

	result = mReaderThread-&gt;run("InputReader", PRIORITY_URGENT_DISPLAY);
	if (result) {
		LOGE("Could not start InputReader thread due to error %d.", result);

		mDispatcherThread-&gt;requestExit();
		return result;
	}

	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数主要就是分别启动一个InputDispatcherThread线程和一个InputReaderThread线程来读取和分发键盘消息的了。这里的InputDispatcherThread线程对象mDispatcherThread和InputReaderThread线程对象是在前面的Step 9中创建的，调用了它们的run函数后，就会进入到它们的threadLoop函数中去，只要threadLoop函数返回true，函数threadLoop就会一直被循环调用，于是这两个线程就起到了不断地读取和分发键盘消息的作用。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们先来分析InputDispatcherThread线程分发消息的过程，然后再回过头来分析InputReaderThread线程读取消息的过程。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 13.&nbsp;InputDispatcherThread.threadLoop</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 8090px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_13" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_13" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=13&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;InputDispatcherThread::threadLoop()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mDispatcher-&gt;dispatchOnce();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_13_9526985" name="code" class="cpp" style="display: none;">bool InputDispatcherThread::threadLoop() {
    mDispatcher-&gt;dispatchOnce();
    return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的成员变量mDispatcher即为在前面Step 8中创建的InputDispatcher对象，调用它的dispatchOnce成员函数执行一次键盘消息分发的操作。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 14. InputDispatcher.dispatchOnce</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 8367px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_14" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_14" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=14&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::dispatchOnce()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;keyRepeatTimeout&nbsp;=&nbsp;mPolicy-&gt;getKeyRepeatTimeout();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;keyRepeatDelay&nbsp;=&nbsp;mPolicy-&gt;getKeyRepeatDelay();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;nextWakeupTime&nbsp;=&nbsp;LONG_LONG_MAX;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatchOnceInnerLocked(keyRepeatTimeout,&nbsp;keyRepeatDelay,&nbsp;&amp;&nbsp;nextWakeupTime);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(runCommandsLockedInterruptible())&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextWakeupTime&nbsp;=&nbsp;LONG_LONG_MIN;&nbsp;&nbsp;<span class="comment">//&nbsp;force&nbsp;next&nbsp;poll&nbsp;to&nbsp;wake&nbsp;up&nbsp;immediately</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Wait&nbsp;for&nbsp;callback&nbsp;or&nbsp;timeout&nbsp;or&nbsp;wake.&nbsp;&nbsp;(make&nbsp;sure&nbsp;we&nbsp;round&nbsp;up,&nbsp;not&nbsp;down)</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;currentTime&nbsp;=&nbsp;now();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;timeoutMillis;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(nextWakeupTime&nbsp;&gt;&nbsp;currentTime)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_t&nbsp;timeout&nbsp;=&nbsp;uint64_t(nextWakeupTime&nbsp;-&nbsp;currentTime);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout&nbsp;=&nbsp;(timeout&nbsp;+&nbsp;999999LL)&nbsp;/&nbsp;1000000LL;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeoutMillis&nbsp;=&nbsp;timeout&nbsp;&gt;&nbsp;INT_MAX&nbsp;?&nbsp;-1&nbsp;:&nbsp;int32_t(timeout);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeoutMillis&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mLooper-&gt;pollOnce(timeoutMillis);&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_14_9876432" name="code" class="cpp" style="display: none;">void InputDispatcher::dispatchOnce() {
	nsecs_t keyRepeatTimeout = mPolicy-&gt;getKeyRepeatTimeout();
	nsecs_t keyRepeatDelay = mPolicy-&gt;getKeyRepeatDelay();

	nsecs_t nextWakeupTime = LONG_LONG_MAX;
	{ // acquire lock
		AutoMutex _l(mLock);
		dispatchOnceInnerLocked(keyRepeatTimeout, keyRepeatDelay, &amp; nextWakeupTime);

		if (runCommandsLockedInterruptible()) {
			nextWakeupTime = LONG_LONG_MIN;  // force next poll to wake up immediately
		}
	} // release lock

	// Wait for callback or timeout or wake.  (make sure we round up, not down)
	nsecs_t currentTime = now();
	int32_t timeoutMillis;
	if (nextWakeupTime &gt; currentTime) {
		uint64_t timeout = uint64_t(nextWakeupTime - currentTime);
		timeout = (timeout + 999999LL) / 1000000LL;
		timeoutMillis = timeout &gt; INT_MAX ? -1 : int32_t(timeout);
	} else {
		timeoutMillis = 0;
	}

	mLooper-&gt;pollOnce(timeoutMillis);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数很简单，把键盘消息交给dispatchOnceInnerLocked函数来处理，这个过程我们在后面再详细分析，然后调用mLooper-&gt;pollOnce函数等待下一次键盘事件的发生。这里的成员变量mLooper的类型为Looper，它定义在C++层中，具体可以参考前面<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序消息处理机制（Looper、Handler）分析</a>一文。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 15. Looper.pollOnce</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/utils/Looper.cpp文件中，具体可以参考前面<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序消息处理机制（Looper、Handler）分析</a>一文，这里就不再详述了。总的来说，就是在Looper类中，会创建一个管道，当调用Looper类的pollOnce函数时，如果管道中没有内容可读，那么当前线程就会进入到空闲等待状态；当有键盘事件发生时，InputReader就会往这个管道中写入新的内容，这样就会唤醒前面正在等待键盘事件发生的线程。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;InputDispatcher类分发消息的过程就暂时分析到这里，后面会有更进一步的分析，现在，我们回到Step 12中，接着分析InputReader类读取键盘事件的过程。在调用了InputReaderThread线程类的run就函数后，同样会进入到InputReaderThread线程类的threadLoop函数中去。<br></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 16. InputReaderThread.threadLoop</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputReader.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 9334px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_15" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_15" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=15&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;InputReaderThread::threadLoop()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mReader-&gt;loopOnce();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_15_7509881" name="code" class="cpp" style="display: none;">bool InputReaderThread::threadLoop() {
    mReader-&gt;loopOnce();
    return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这里的成员变量mReader即为在前面Step 8中创建的InputReader对象，调用它的loopOnce成员函数执行一次键盘事件的读取操作。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; Step 17. InputReader.loopOnce</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/libs/ui/InputReader.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 9611px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_16" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_16" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=16&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputReader::loopOnce()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;RawEvent&nbsp;rawEvent;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mEventHub-&gt;getEvent(&amp;&nbsp;rawEvent);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="preprocessor">#if&nbsp;DEBUG_RAW_EVENTS</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGD(<span class="string">"Input&nbsp;event:&nbsp;device=0x%x&nbsp;type=0x%x&nbsp;scancode=%d&nbsp;keycode=%d&nbsp;value=%d"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rawEvent.deviceId,&nbsp;rawEvent.type,&nbsp;rawEvent.scanCode,&nbsp;rawEvent.keyCode,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rawEvent.value);&nbsp;&nbsp;</span></li><li class="alt"><span><span class="preprocessor">#endif</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;process(&amp;&nbsp;rawEvent);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_16_1763023" name="code" class="cpp" style="display: none;">void InputReader::loopOnce() {
	RawEvent rawEvent;
	mEventHub-&gt;getEvent(&amp; rawEvent);

#if DEBUG_RAW_EVENTS
	LOGD("Input event: device=0x%x type=0x%x scancode=%d keycode=%d value=%d",
		rawEvent.deviceId, rawEvent.type, rawEvent.scanCode, rawEvent.keyCode,
		rawEvent.value);
#endif

	process(&amp; rawEvent);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里通过成员函数mEventHub来负责键盘消息的读取工作，如果当前有键盘事件发生或者有键盘事件等待处理，通过mEventHub的getEvent函数就可以得到这个事件，然后交给process函数进行处理，这个函数主要就是唤醒前面的InputDispatcherThread线程，通知它有新的键盘事件发生了，它需要进行一次键盘消息的分发操作了，这个函数我们后面再进一步详细分析；如果没有键盘事件发生或者没有键盘事件等待处理，那么调用mEventHub的getEvent函数时就会进入等待状态。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 18. EventHub.getEvent</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/EventHub.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 10110px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_17" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_17" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=17&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;EventHub::getEvent(RawEvent*&nbsp;outEvent)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;scanCode&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;keyCode&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;flags&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;value&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Note&nbsp;that&nbsp;we&nbsp;only&nbsp;allow&nbsp;one&nbsp;caller&nbsp;to&nbsp;getEvent(),&nbsp;so&nbsp;don't&nbsp;need</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;to&nbsp;do&nbsp;locking&nbsp;here...&nbsp;&nbsp;only&nbsp;when&nbsp;adding/removing&nbsp;devices.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!mOpened)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mError&nbsp;=&nbsp;openPlatformInput()&nbsp;?&nbsp;NO_ERROR&nbsp;:&nbsp;UNKNOWN_ERROR;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mOpened&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mNeedToSendFinishedDeviceScan&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(;;)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Report&nbsp;any&nbsp;devices&nbsp;that&nbsp;had&nbsp;last&nbsp;been&nbsp;added/removed.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mClosingDevices&nbsp;!=&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device_t*&nbsp;device&nbsp;=&nbsp;mClosingDevices;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"Reporting&nbsp;device&nbsp;closed:&nbsp;id=0x%x,&nbsp;name=%s\n"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;id,&nbsp;device-&gt;path.string());&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mClosingDevices&nbsp;=&nbsp;device-&gt;next;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;id&nbsp;==&nbsp;mFirstKeyboardId)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;DEVICE_REMOVED;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;systemTime(SYSTEM_TIME_MONOTONIC);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">delete</span><span>&nbsp;device;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mNeedToSendFinishedDeviceScan&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mOpeningDevices&nbsp;!=&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device_t*&nbsp;device&nbsp;=&nbsp;mOpeningDevices;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"Reporting&nbsp;device&nbsp;opened:&nbsp;id=0x%x,&nbsp;name=%s\n"</span><span>,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;id,&nbsp;device-&gt;path.string());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mOpeningDevices&nbsp;=&nbsp;device-&gt;next;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;id&nbsp;==&nbsp;mFirstKeyboardId)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;DEVICE_ADDED;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;systemTime(SYSTEM_TIME_MONOTONIC);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mNeedToSendFinishedDeviceScan&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mNeedToSendFinishedDeviceScan)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mNeedToSendFinishedDeviceScan&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;FINISHED_DEVICE_SCAN;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;systemTime(SYSTEM_TIME_MONOTONIC);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Grab&nbsp;the&nbsp;next&nbsp;input&nbsp;event.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(;;)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Consume&nbsp;buffered&nbsp;input&nbsp;events,&nbsp;if&nbsp;any.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInputBufferIndex&nbsp;&lt;&nbsp;mInputBufferCount)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;</span><span class="keyword">struct</span><span>&nbsp;input_event&amp;&nbsp;iev&nbsp;=&nbsp;mInputBufferData[mInputBufferIndex++];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;device_t*&nbsp;device&nbsp;=&nbsp;mDevices[mInputDeviceIndex];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"%s&nbsp;got:&nbsp;t0=%d,&nbsp;t1=%d,&nbsp;type=%d,&nbsp;code=%d,&nbsp;v=%d"</span><span>,&nbsp;device-&gt;path.string(),&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="datatypes">int</span><span>)&nbsp;iev.time.tv_sec,&nbsp;(</span><span class="datatypes">int</span><span>)&nbsp;iev.time.tv_usec,&nbsp;iev.type,&nbsp;iev.code,&nbsp;iev.value);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;id&nbsp;==&nbsp;mFirstKeyboardId)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;iev.type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;scanCode&nbsp;=&nbsp;iev.code;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(iev.type&nbsp;==&nbsp;EV_KEY)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;err&nbsp;=&nbsp;device-&gt;layoutMap-&gt;map(iev.code,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;outEvent-&gt;keyCode,&nbsp;&amp;&nbsp;outEvent-&gt;flags);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"iev.code=%d&nbsp;keyCode=%d&nbsp;flags=0x%08x&nbsp;err=%d\n"</span><span>,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iev.code,&nbsp;outEvent-&gt;keyCode,&nbsp;outEvent-&gt;flags,&nbsp;err);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(err&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;keyCode&nbsp;=&nbsp;AKEYCODE_UNKNOWN;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;flags&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;keyCode&nbsp;=&nbsp;iev.code;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;value&nbsp;=&nbsp;iev.value;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Use&nbsp;an&nbsp;event&nbsp;timestamp&nbsp;in&nbsp;the&nbsp;same&nbsp;timebase&nbsp;as</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;java.lang.System.nanoTime()&nbsp;and&nbsp;android.os.SystemClock.uptimeMillis()</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;as&nbsp;expected&nbsp;by&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;system.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;systemTime(SYSTEM_TIME_MONOTONIC);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Finish&nbsp;reading&nbsp;all&nbsp;events&nbsp;from&nbsp;devices&nbsp;identified&nbsp;in&nbsp;previous&nbsp;poll().</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;This&nbsp;code&nbsp;assumes&nbsp;that&nbsp;mInputDeviceIndex&nbsp;is&nbsp;initially&nbsp;0&nbsp;and&nbsp;that&nbsp;the</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;revents&nbsp;member&nbsp;of&nbsp;pollfd&nbsp;is&nbsp;initialized&nbsp;to&nbsp;0&nbsp;when&nbsp;the&nbsp;device&nbsp;is&nbsp;first&nbsp;added.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Since&nbsp;mFDs[0]&nbsp;is&nbsp;used&nbsp;for&nbsp;inotify,&nbsp;we&nbsp;process&nbsp;regular&nbsp;events&nbsp;starting&nbsp;at&nbsp;index&nbsp;1.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputDeviceIndex&nbsp;+=&nbsp;1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInputDeviceIndex&nbsp;&gt;=&nbsp;mFDCount)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;</span><span class="keyword">struct</span><span>&nbsp;pollfd&amp;&nbsp;pfd&nbsp;=&nbsp;mFDs[mInputDeviceIndex];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(pfd.revents&nbsp;&amp;&nbsp;POLLIN)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;readSize&nbsp;=&nbsp;read(pfd.fd,&nbsp;mInputBufferData,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sizeof</span><span>(</span><span class="keyword">struct</span><span>&nbsp;input_event)&nbsp;*&nbsp;INPUT_BUFFER_SIZE);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(readSize&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(errno&nbsp;!=&nbsp;EAGAIN&nbsp;&amp;&amp;&nbsp;errno&nbsp;!=&nbsp;EINTR)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGW(<span class="string">"could&nbsp;not&nbsp;get&nbsp;event&nbsp;(errno=%d)"</span><span>,&nbsp;errno);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;((readSize&nbsp;%&nbsp;</span><span class="keyword">sizeof</span><span>(</span><span class="keyword">struct</span><span>&nbsp;input_event))&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"could&nbsp;not&nbsp;get&nbsp;event&nbsp;(wrong&nbsp;size:&nbsp;%d)"</span><span>,&nbsp;readSize);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputBufferCount&nbsp;=&nbsp;readSize&nbsp;/&nbsp;<span class="keyword">sizeof</span><span>(</span><span class="keyword">struct</span><span>&nbsp;input_event);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputBufferIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputDeviceIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Poll&nbsp;for&nbsp;events.&nbsp;&nbsp;Mind&nbsp;the&nbsp;wake&nbsp;lock&nbsp;dance!</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;We&nbsp;hold&nbsp;a&nbsp;wake&nbsp;lock&nbsp;at&nbsp;all&nbsp;times&nbsp;except&nbsp;during&nbsp;poll().&nbsp;&nbsp;This&nbsp;works&nbsp;due&nbsp;to&nbsp;some</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;subtle&nbsp;choreography.&nbsp;&nbsp;When&nbsp;a&nbsp;device&nbsp;driver&nbsp;has&nbsp;pending&nbsp;(unread)&nbsp;events,&nbsp;it&nbsp;acquires</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;a&nbsp;kernel&nbsp;wake&nbsp;lock.&nbsp;&nbsp;However,&nbsp;once&nbsp;the&nbsp;last&nbsp;pending&nbsp;event&nbsp;has&nbsp;been&nbsp;read,&nbsp;the&nbsp;device</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;driver&nbsp;will&nbsp;release&nbsp;the&nbsp;kernel&nbsp;wake&nbsp;lock.&nbsp;&nbsp;To&nbsp;prevent&nbsp;the&nbsp;system&nbsp;from&nbsp;going&nbsp;to&nbsp;sleep</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;when&nbsp;this&nbsp;happens,&nbsp;the&nbsp;EventHub&nbsp;holds&nbsp;onto&nbsp;its&nbsp;own&nbsp;user&nbsp;wake&nbsp;lock&nbsp;while&nbsp;the&nbsp;client</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;is&nbsp;processing&nbsp;events.&nbsp;&nbsp;Thus&nbsp;the&nbsp;system&nbsp;can&nbsp;only&nbsp;sleep&nbsp;if&nbsp;there&nbsp;are&nbsp;no&nbsp;events</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;pending&nbsp;or&nbsp;currently&nbsp;being&nbsp;processed.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;release_wake_lock(WAKE_LOCK_ID);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;pollResult&nbsp;=&nbsp;poll(mFDs,&nbsp;mFDCount,&nbsp;-1);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acquire_wake_lock(PARTIAL_WAKE_LOCK,&nbsp;WAKE_LOCK_ID);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(pollResult&nbsp;&lt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(errno&nbsp;!=&nbsp;EINTR)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGW(<span class="string">"poll&nbsp;failed&nbsp;(errno=%d)\n"</span><span>,&nbsp;errno);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usleep(100000);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_17_9952879" name="code" class="cpp" style="display: none;">bool EventHub::getEvent(RawEvent* outEvent)
{
	outEvent-&gt;deviceId = 0;
	outEvent-&gt;type = 0;
	outEvent-&gt;scanCode = 0;
	outEvent-&gt;keyCode = 0;
	outEvent-&gt;flags = 0;
	outEvent-&gt;value = 0;
	outEvent-&gt;when = 0;

	// Note that we only allow one caller to getEvent(), so don't need
	// to do locking here...  only when adding/removing devices.

	if (!mOpened) {
		mError = openPlatformInput() ? NO_ERROR : UNKNOWN_ERROR;
		mOpened = true;
		mNeedToSendFinishedDeviceScan = true;
	}

	for (;;) {
		// Report any devices that had last been added/removed.
		if (mClosingDevices != NULL) {
			device_t* device = mClosingDevices;
			LOGV("Reporting device closed: id=0x%x, name=%s\n",
				device-&gt;id, device-&gt;path.string());
			mClosingDevices = device-&gt;next;
			if (device-&gt;id == mFirstKeyboardId) {
				outEvent-&gt;deviceId = 0;
			} else {
				outEvent-&gt;deviceId = device-&gt;id;
			}
			outEvent-&gt;type = DEVICE_REMOVED;
			outEvent-&gt;when = systemTime(SYSTEM_TIME_MONOTONIC);
			delete device;
			mNeedToSendFinishedDeviceScan = true;
			return true;
		}

		if (mOpeningDevices != NULL) {
			device_t* device = mOpeningDevices;
			LOGV("Reporting device opened: id=0x%x, name=%s\n",
				device-&gt;id, device-&gt;path.string());
			mOpeningDevices = device-&gt;next;
			if (device-&gt;id == mFirstKeyboardId) {
				outEvent-&gt;deviceId = 0;
			} else {
				outEvent-&gt;deviceId = device-&gt;id;
			}
			outEvent-&gt;type = DEVICE_ADDED;
			outEvent-&gt;when = systemTime(SYSTEM_TIME_MONOTONIC);
			mNeedToSendFinishedDeviceScan = true;
			return true;
		}

		if (mNeedToSendFinishedDeviceScan) {
			mNeedToSendFinishedDeviceScan = false;
			outEvent-&gt;type = FINISHED_DEVICE_SCAN;
			outEvent-&gt;when = systemTime(SYSTEM_TIME_MONOTONIC);
			return true;
		}

		// Grab the next input event.
		for (;;) {
			// Consume buffered input events, if any.
			if (mInputBufferIndex &lt; mInputBufferCount) {
				const struct input_event&amp; iev = mInputBufferData[mInputBufferIndex++];
				const device_t* device = mDevices[mInputDeviceIndex];

				LOGV("%s got: t0=%d, t1=%d, type=%d, code=%d, v=%d", device-&gt;path.string(),
					(int) iev.time.tv_sec, (int) iev.time.tv_usec, iev.type, iev.code, iev.value);
				if (device-&gt;id == mFirstKeyboardId) {
					outEvent-&gt;deviceId = 0;
				} else {
					outEvent-&gt;deviceId = device-&gt;id;
				}
				outEvent-&gt;type = iev.type;
				outEvent-&gt;scanCode = iev.code;
				if (iev.type == EV_KEY) {
					status_t err = device-&gt;layoutMap-&gt;map(iev.code,
						&amp; outEvent-&gt;keyCode, &amp; outEvent-&gt;flags);
					LOGV("iev.code=%d keyCode=%d flags=0x%08x err=%d\n",
						iev.code, outEvent-&gt;keyCode, outEvent-&gt;flags, err);
					if (err != 0) {
						outEvent-&gt;keyCode = AKEYCODE_UNKNOWN;
						outEvent-&gt;flags = 0;
					}
				} else {
					outEvent-&gt;keyCode = iev.code;
				}
				outEvent-&gt;value = iev.value;

				// Use an event timestamp in the same timebase as
				// java.lang.System.nanoTime() and android.os.SystemClock.uptimeMillis()
				// as expected by the rest of the system.
				outEvent-&gt;when = systemTime(SYSTEM_TIME_MONOTONIC);
				return true;
			}

			// Finish reading all events from devices identified in previous poll().
			// This code assumes that mInputDeviceIndex is initially 0 and that the
			// revents member of pollfd is initialized to 0 when the device is first added.
			// Since mFDs[0] is used for inotify, we process regular events starting at index 1.
			mInputDeviceIndex += 1;
			if (mInputDeviceIndex &gt;= mFDCount) {
				break;
			}

			const struct pollfd&amp; pfd = mFDs[mInputDeviceIndex];
			if (pfd.revents &amp; POLLIN) {
				int32_t readSize = read(pfd.fd, mInputBufferData,
					sizeof(struct input_event) * INPUT_BUFFER_SIZE);
				if (readSize &lt; 0) {
					if (errno != EAGAIN &amp;&amp; errno != EINTR) {
						LOGW("could not get event (errno=%d)", errno);
					}
				} else if ((readSize % sizeof(struct input_event)) != 0) {
					LOGE("could not get event (wrong size: %d)", readSize);
				} else {
					mInputBufferCount = readSize / sizeof(struct input_event);
					mInputBufferIndex = 0;
				}
			}
		}

		......

		mInputDeviceIndex = 0;

		// Poll for events.  Mind the wake lock dance!
		// We hold a wake lock at all times except during poll().  This works due to some
		// subtle choreography.  When a device driver has pending (unread) events, it acquires
		// a kernel wake lock.  However, once the last pending event has been read, the device
		// driver will release the kernel wake lock.  To prevent the system from going to sleep
		// when this happens, the EventHub holds onto its own user wake lock while the client
		// is processing events.  Thus the system can only sleep if there are no events
		// pending or currently being processed.
		release_wake_lock(WAKE_LOCK_ID);

		int pollResult = poll(mFDs, mFDCount, -1);

		acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);

		if (pollResult &lt;= 0) {
			if (errno != EINTR) {
				LOGW("poll failed (errno=%d)\n", errno);
				usleep(100000);
			}
		}

	}
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数比较长，我们一步一步来分析。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;首先，如果是第一次进入到这个函数中时，成员变量mOpened的值为false，于是就会调用openPlatformInput函数来打开系统输入设备，在本文中，我们主要讨论的输入设备就是键盘了。打开了这些输入设备文件后，就可以对这些输入设备进行是监控了。如果不是第一次进入到这个函数，那么就会分析当前有没有输入事件发生，如果有，就返回这个事件，否则就会进入等待状态，等待下一次输入事件的发生。在我们这个场景中，就是等待下一次键盘事件的发生了。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; 我们先分析openPlatformInput函数的实现，然后回过头来分析这个getEvent函数的具体的实现。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; Step 19. EventHub.openPlatformInput</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/libs/ui/EventHub.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 13224px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_18" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_18" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=18&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;EventHub::openPlatformInput(</span><span class="keyword">void</span><span>)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;scanDir(device_path);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(res&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"scan&nbsp;dir&nbsp;failed&nbsp;for&nbsp;%s\n"</span><span>,&nbsp;device_path);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_18_7270684" name="code" class="cpp" style="display: none;">bool EventHub::openPlatformInput(void)
{
	......

	res = scanDir(device_path);
	if(res &lt; 0) {
		LOGE("scan dir failed for %s\n", device_path);
	}

	return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数主要是扫描device_path目录下的设备文件，然后打开它们，这里的变量device_path定义在frameworks/base/libs/ui/EventHub.cpp文件开始的地方：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 13547px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_19" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_19" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=19&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*device_path&nbsp;=&nbsp;</span><span class="string">"/dev/input"</span><span>;&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_19_1316083" name="code" class="cpp" style="display: none;">static const char *device_path = "/dev/input";</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在设备目录/dev/input中，一般有三个设备文件存在，分别是event0、mice和mouse0设备文件，其中，键盘事件就包含在event0设备文件中了。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 20.&nbsp;EventHub.scanDir</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/EventHub.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 13770px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_20" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_20" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=20&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;EventHub::scanDir(</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*dirname)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;devname[PATH_MAX];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;*filename;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;DIR&nbsp;*dir;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">struct</span><span>&nbsp;dirent&nbsp;*de;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;dir&nbsp;=&nbsp;opendir(dirname);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(dir&nbsp;==&nbsp;NULL)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;strcpy(devname,&nbsp;dirname);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;filename&nbsp;=&nbsp;devname&nbsp;+&nbsp;strlen(devname);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;*filename++&nbsp;=&nbsp;<span class="string">'/'</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>((de&nbsp;=&nbsp;readdir(dir)))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(de-&gt;d_name[0]&nbsp;==&nbsp;</span><span class="string">'.'</span><span>&nbsp;&amp;&amp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(de-&gt;d_name[1]&nbsp;==&nbsp;<span class="string">'\0'</span><span>&nbsp;||&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(de-&gt;d_name[1]&nbsp;==&nbsp;<span class="string">'.'</span><span>&nbsp;&amp;&amp;&nbsp;de-&gt;d_name[2]&nbsp;==&nbsp;</span><span class="string">'\0'</span><span>)))&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">continue</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(filename,&nbsp;de-&gt;d_name);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openDevice(devname);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;closedir(dir);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_20_7205427" name="code" class="cpp" style="display: none;">int EventHub::scanDir(const char *dirname)
{
	char devname[PATH_MAX];
	char *filename;
	DIR *dir;
	struct dirent *de;
	dir = opendir(dirname);
	if(dir == NULL)
		return -1;
	strcpy(devname, dirname);
	filename = devname + strlen(devname);
	*filename++ = '/';
	while((de = readdir(dir))) {
		if(de-&gt;d_name[0] == '.' &amp;&amp;
			(de-&gt;d_name[1] == '\0' ||
			(de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2] == '\0')))
			continue;
		strcpy(filename, de-&gt;d_name);
		openDevice(devname);
	}
	closedir(dir);
	return 0;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 根据上面一步的分析，这个函数主要就是调用openDevice函数来分别打开/dev/input/event0、/dev/input/mice和/dev/input/mouse0三个设备文件了。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; Step 21.&nbsp;EventHub.openDevice<br>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/libs/ui/EventHub.cpp文件中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 14375px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_21" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_21" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=21&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;EventHub::openDevice(</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*deviceName)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;version;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;fd;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">struct</span><span>&nbsp;pollfd&nbsp;*new_mFDs;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;device_t&nbsp;**new_devices;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;**new_device_names;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;name[80];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;location[80];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;idstr[80];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">struct</span><span>&nbsp;input_id&nbsp;id;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"Opening&nbsp;device:&nbsp;%s"</span><span>,&nbsp;deviceName);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;fd&nbsp;=&nbsp;open(deviceName,&nbsp;O_RDWR);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(fd&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"could&nbsp;not&nbsp;open&nbsp;%s,&nbsp;%s\n"</span><span>,&nbsp;deviceName,&nbsp;strerror(errno));&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;devid&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(devid&nbsp;&lt;&nbsp;mNumDevicesById)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mDevicesById[devid].device&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devid++;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mDevicesById[devid].seq&nbsp;=&nbsp;(mDevicesById[devid].seq+(1&lt;&lt;SEQ_SHIFT))&amp;SEQ_MASK;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mDevicesById[devid].seq&nbsp;==&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mDevicesById[devid].seq&nbsp;=&nbsp;1&lt;&lt;SEQ_SHIFT;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;new_mFDs&nbsp;=&nbsp;(pollfd*)realloc(mFDs,&nbsp;<span class="keyword">sizeof</span><span>(mFDs[0])&nbsp;*&nbsp;(mFDCount&nbsp;+&nbsp;1));&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;new_devices&nbsp;=&nbsp;(device_t**)realloc(mDevices,&nbsp;<span class="keyword">sizeof</span><span>(mDevices[0])&nbsp;*&nbsp;(mFDCount&nbsp;+&nbsp;1));&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(new_mFDs&nbsp;==&nbsp;NULL&nbsp;||&nbsp;new_devices&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"out&nbsp;of&nbsp;memory"</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mFDs&nbsp;=&nbsp;new_mFDs;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mDevices&nbsp;=&nbsp;new_devices;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;device_t*&nbsp;device&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;device_t(devid|mDevicesById[devid].seq,&nbsp;deviceName,&nbsp;name);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"out&nbsp;of&nbsp;memory"</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;fd&nbsp;=&nbsp;fd;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mFDs[mFDCount].fd&nbsp;=&nbsp;fd;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mFDs[mFDCount].events&nbsp;=&nbsp;POLLIN;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mFDs[mFDCount].revents&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Figure&nbsp;out&nbsp;the&nbsp;kinds&nbsp;of&nbsp;events&nbsp;the&nbsp;device&nbsp;reports.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;uint8_t&nbsp;key_bitmask[sizeof_bit_array(KEY_MAX&nbsp;+&nbsp;1)];&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;memset(key_bitmask,&nbsp;0,&nbsp;<span class="keyword">sizeof</span><span>(key_bitmask));&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"Getting&nbsp;keys..."</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(ioctl(fd,&nbsp;EVIOCGBIT(EV_KEY,&nbsp;</span><span class="keyword">sizeof</span><span>(key_bitmask)),&nbsp;key_bitmask)&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;See&nbsp;if&nbsp;this&nbsp;is&nbsp;a&nbsp;keyboard.&nbsp;&nbsp;Ignore&nbsp;everything&nbsp;in&nbsp;the&nbsp;button&nbsp;range&nbsp;except&nbsp;for</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;gamepads&nbsp;which&nbsp;are&nbsp;also&nbsp;considered&nbsp;keyboards.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(containsNonZeroByte(key_bitmask,&nbsp;0,&nbsp;sizeof_bit_array(BTN_MISC))&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;containsNonZeroByte(key_bitmask,&nbsp;sizeof_bit_array(BTN_GAMEPAD),&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof_bit_array(BTN_DIGI))&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;containsNonZeroByte(key_bitmask,&nbsp;sizeof_bit_array(KEY_OK),&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof_bit_array(KEY_MAX&nbsp;+&nbsp;1)))&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;classes&nbsp;|=&nbsp;INPUT_DEVICE_CLASS_KEYBOARD;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;keyBitmask&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;uint8_t[</span><span class="keyword">sizeof</span><span>(key_bitmask)];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;keyBitmask&nbsp;!=&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(device-&gt;keyBitmask,&nbsp;key_bitmask,&nbsp;<span class="keyword">sizeof</span><span>(key_bitmask));&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">delete</span><span>&nbsp;device;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"out&nbsp;of&nbsp;memory&nbsp;allocating&nbsp;key&nbsp;bitmask"</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;((device-&gt;classes&nbsp;&amp;&nbsp;INPUT_DEVICE_CLASS_KEYBOARD)&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;tmpfn[</span><span class="keyword">sizeof</span><span>(name)];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;keylayoutFilename[300];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;a&nbsp;more&nbsp;descriptive&nbsp;name</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;name&nbsp;=&nbsp;name;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;replace&nbsp;all&nbsp;the&nbsp;spaces&nbsp;with&nbsp;underscores</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(tmpfn,&nbsp;name);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">char</span><span>&nbsp;*p&nbsp;=&nbsp;strchr(tmpfn,&nbsp;</span><span class="string">'&nbsp;'</span><span>);&nbsp;p&nbsp;&amp;&amp;&nbsp;*p;&nbsp;p&nbsp;=&nbsp;strchr(tmpfn,&nbsp;</span><span class="string">'&nbsp;'</span><span>))&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*p&nbsp;=&nbsp;<span class="string">'_'</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;find&nbsp;the&nbsp;.kl&nbsp;file&nbsp;we&nbsp;need&nbsp;for&nbsp;this&nbsp;device</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>*&nbsp;root&nbsp;=&nbsp;getenv(</span><span class="string">"ANDROID_ROOT"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(keylayoutFilename,&nbsp;<span class="keyword">sizeof</span><span>(keylayoutFilename),&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"%s/usr/keylayout/%s.kl"</span><span>,&nbsp;root,&nbsp;tmpfn);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">bool</span><span>&nbsp;defaultKeymap&nbsp;=&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(access(keylayoutFilename,&nbsp;R_OK))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(keylayoutFilename,&nbsp;<span class="keyword">sizeof</span><span>(keylayoutFilename),&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"%s/usr/keylayout/%s"</span><span>,&nbsp;root,&nbsp;</span><span class="string">"qwerty.kl"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultKeymap&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;device-&gt;layoutMap-&gt;load(keylayoutFilename);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(status)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"Error&nbsp;%d&nbsp;loading&nbsp;key&nbsp;layout."</span><span>,&nbsp;status);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;tell&nbsp;the&nbsp;world&nbsp;about&nbsp;the&nbsp;devname&nbsp;(the&nbsp;descriptive&nbsp;name)</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!mHaveFirstKeyboard&nbsp;&amp;&amp;&nbsp;!defaultKeymap&nbsp;&amp;&amp;&nbsp;strstr(name,&nbsp;</span><span class="string">"-keypad"</span><span>))&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;the&nbsp;built-in&nbsp;keyboard&nbsp;has&nbsp;a&nbsp;well-known&nbsp;device&nbsp;ID&nbsp;of&nbsp;0,</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;this&nbsp;device&nbsp;better&nbsp;not&nbsp;go&nbsp;away.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mHaveFirstKeyboard&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFirstKeyboardId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property_set(<span class="string">"hw.keyboards.0.devname"</span><span>,&nbsp;name);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;ensure&nbsp;mFirstKeyboardId&nbsp;is&nbsp;set&nbsp;to&nbsp;-something-.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mFirstKeyboardId&nbsp;==&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFirstKeyboardId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;propName[100];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(propName,&nbsp;<span class="string">"hw.keyboards.%u.devname"</span><span>,&nbsp;device-&gt;id);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property_set(propName,&nbsp;name);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;'Q'&nbsp;key&nbsp;support&nbsp;=&nbsp;cheap&nbsp;test&nbsp;of&nbsp;whether&nbsp;this&nbsp;is&nbsp;an&nbsp;alpha-capable&nbsp;kbd</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(hasKeycodeLocked(device,&nbsp;AKEYCODE_Q))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;classes&nbsp;|=&nbsp;INPUT_DEVICE_CLASS_ALPHAKEY;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;See&nbsp;if&nbsp;this&nbsp;device&nbsp;has&nbsp;a&nbsp;DPAD.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_UP)&nbsp;&amp;&amp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_DOWN)&nbsp;&amp;&amp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_LEFT)&nbsp;&amp;&amp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_RIGHT)&nbsp;&amp;&amp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_CENTER))&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;classes&nbsp;|=&nbsp;INPUT_DEVICE_CLASS_DPAD;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;See&nbsp;if&nbsp;this&nbsp;device&nbsp;has&nbsp;a&nbsp;gamepad.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">size_t</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;</span><span class="keyword">sizeof</span><span>(GAMEPAD_KEYCODES)/</span><span class="keyword">sizeof</span><span>(GAMEPAD_KEYCODES[0]);&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(hasKeycodeLocked(device,&nbsp;GAMEPAD_KEYCODES[i]))&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;classes&nbsp;|=&nbsp;INPUT_DEVICE_CLASS_GAMEPAD;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGI(<span class="string">"New&nbsp;keyboard:&nbsp;device-&gt;id=0x%x&nbsp;devname='%s'&nbsp;propName='%s'&nbsp;keylayout='%s'\n"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;id,&nbsp;name,&nbsp;propName,&nbsp;keylayoutFilename);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mDevicesById[devid].device&nbsp;=&nbsp;device;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;next&nbsp;=&nbsp;mOpeningDevices;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mOpeningDevices&nbsp;=&nbsp;device;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mDevices[mFDCount]&nbsp;=&nbsp;device;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mFDCount++;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_21_3966824" name="code" class="cpp" style="display: none;">int EventHub::openDevice(const char *deviceName) {
	int version;
	int fd;
	struct pollfd *new_mFDs;
	device_t **new_devices;
	char **new_device_names;
	char name[80];
	char location[80];
	char idstr[80];
	struct input_id id;

	LOGV("Opening device: %s", deviceName);

	AutoMutex _l(mLock);

	fd = open(deviceName, O_RDWR);
	if(fd &lt; 0) {
		LOGE("could not open %s, %s\n", deviceName, strerror(errno));
		return -1;
	}

	......

	int devid = 0;
	while (devid &lt; mNumDevicesById) {
		if (mDevicesById[devid].device == NULL) {
			break;
		}
		devid++;
	}
	
	......

	mDevicesById[devid].seq = (mDevicesById[devid].seq+(1&lt;&lt;SEQ_SHIFT))&amp;SEQ_MASK;
	if (mDevicesById[devid].seq == 0) {
		mDevicesById[devid].seq = 1&lt;&lt;SEQ_SHIFT;
	}

	new_mFDs = (pollfd*)realloc(mFDs, sizeof(mFDs[0]) * (mFDCount + 1));
	new_devices = (device_t**)realloc(mDevices, sizeof(mDevices[0]) * (mFDCount + 1));
	if (new_mFDs == NULL || new_devices == NULL) {
		LOGE("out of memory");
		return -1;
	}
	mFDs = new_mFDs;
	mDevices = new_devices;

	......

	device_t* device = new device_t(devid|mDevicesById[devid].seq, deviceName, name);
	if (device == NULL) {
		LOGE("out of memory");
		return -1;
	}

	device-&gt;fd = fd;
	mFDs[mFDCount].fd = fd;
	mFDs[mFDCount].events = POLLIN;
	mFDs[mFDCount].revents = 0;

	// Figure out the kinds of events the device reports.

	uint8_t key_bitmask[sizeof_bit_array(KEY_MAX + 1)];
	memset(key_bitmask, 0, sizeof(key_bitmask));

	LOGV("Getting keys...");
	if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(key_bitmask)), key_bitmask) &gt;= 0) {
		// See if this is a keyboard.  Ignore everything in the button range except for
		// gamepads which are also considered keyboards.
		if (containsNonZeroByte(key_bitmask, 0, sizeof_bit_array(BTN_MISC))
			|| containsNonZeroByte(key_bitmask, sizeof_bit_array(BTN_GAMEPAD),
			sizeof_bit_array(BTN_DIGI))
			|| containsNonZeroByte(key_bitmask, sizeof_bit_array(KEY_OK),
			sizeof_bit_array(KEY_MAX + 1))) {
				device-&gt;classes |= INPUT_DEVICE_CLASS_KEYBOARD;

				device-&gt;keyBitmask = new uint8_t[sizeof(key_bitmask)];
				if (device-&gt;keyBitmask != NULL) {
					memcpy(device-&gt;keyBitmask, key_bitmask, sizeof(key_bitmask));
				} else {
					delete device;
					LOGE("out of memory allocating key bitmask");
					return -1;
				}
		}
	}

	......

	if ((device-&gt;classes &amp; INPUT_DEVICE_CLASS_KEYBOARD) != 0) {
		char tmpfn[sizeof(name)];
		char keylayoutFilename[300];

		// a more descriptive name
		device-&gt;name = name;

		// replace all the spaces with underscores
		strcpy(tmpfn, name);
		for (char *p = strchr(tmpfn, ' '); p &amp;&amp; *p; p = strchr(tmpfn, ' '))
			*p = '_';

		// find the .kl file we need for this device
		const char* root = getenv("ANDROID_ROOT");
		snprintf(keylayoutFilename, sizeof(keylayoutFilename),
			"%s/usr/keylayout/%s.kl", root, tmpfn);
		bool defaultKeymap = false;
		if (access(keylayoutFilename, R_OK)) {
			snprintf(keylayoutFilename, sizeof(keylayoutFilename),
				"%s/usr/keylayout/%s", root, "qwerty.kl");
			defaultKeymap = true;
		}
		status_t status = device-&gt;layoutMap-&gt;load(keylayoutFilename);
		if (status) {
			LOGE("Error %d loading key layout.", status);
		}

		// tell the world about the devname (the descriptive name)
		if (!mHaveFirstKeyboard &amp;&amp; !defaultKeymap &amp;&amp; strstr(name, "-keypad")) {
			// the built-in keyboard has a well-known device ID of 0,
			// this device better not go away.
			mHaveFirstKeyboard = true;
			mFirstKeyboardId = device-&gt;id;
			property_set("hw.keyboards.0.devname", name);
		} else {
			// ensure mFirstKeyboardId is set to -something-.
			if (mFirstKeyboardId == 0) {
				mFirstKeyboardId = device-&gt;id;
			}
		}
		char propName[100];
		sprintf(propName, "hw.keyboards.%u.devname", device-&gt;id);
		property_set(propName, name);

		// 'Q' key support = cheap test of whether this is an alpha-capable kbd
		if (hasKeycodeLocked(device, AKEYCODE_Q)) {
			device-&gt;classes |= INPUT_DEVICE_CLASS_ALPHAKEY;
		}

		// See if this device has a DPAD.
		if (hasKeycodeLocked(device, AKEYCODE_DPAD_UP) &amp;&amp;
			hasKeycodeLocked(device, AKEYCODE_DPAD_DOWN) &amp;&amp;
			hasKeycodeLocked(device, AKEYCODE_DPAD_LEFT) &amp;&amp;
			hasKeycodeLocked(device, AKEYCODE_DPAD_RIGHT) &amp;&amp;
			hasKeycodeLocked(device, AKEYCODE_DPAD_CENTER)) {
				device-&gt;classes |= INPUT_DEVICE_CLASS_DPAD;
		}

		// See if this device has a gamepad.
		for (size_t i = 0; i &lt; sizeof(GAMEPAD_KEYCODES)/sizeof(GAMEPAD_KEYCODES[0]); i++) {
			if (hasKeycodeLocked(device, GAMEPAD_KEYCODES[i])) {
				device-&gt;classes |= INPUT_DEVICE_CLASS_GAMEPAD;
				break;
			}
		}

		LOGI("New keyboard: device-&gt;id=0x%x devname='%s' propName='%s' keylayout='%s'\n",
			device-&gt;id, name, propName, keylayoutFilename);
	}

	......

	mDevicesById[devid].device = device;
	device-&gt;next = mOpeningDevices;
	mOpeningDevices = device;
	mDevices[mFDCount] = device;

	mFDCount++;
	return 0;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 函数首先根据文件名来打开这个设备文件：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 17549px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_22" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_22" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=22&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>fd&nbsp;=&nbsp;open(deviceName,&nbsp;O_RDWR);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_22_4108528" name="code" class="cpp" style="display: none;">fd = open(deviceName, O_RDWR);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;系统中所有输入设备文件信息都保存在成员变量mDevicesById中，因此，先在mDevicesById找到一个空位置来保存当前打开的设备文件信息：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 17692px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_23" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_23" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=23&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>mDevicesById[devid].seq&nbsp;=&nbsp;(mDevicesById[devid].seq+(1&lt;&lt;SEQ_SHIFT))&amp;SEQ_MASK;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">if</span><span>&nbsp;(mDevicesById[devid].seq&nbsp;==&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mDevicesById[devid].seq&nbsp;=&nbsp;1&lt;&lt;SEQ_SHIFT;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_23_9233721" name="code" class="cpp" style="display: none;">mDevicesById[devid].seq = (mDevicesById[devid].seq+(1&lt;&lt;SEQ_SHIFT))&amp;SEQ_MASK;
if (mDevicesById[devid].seq == 0) {
	mDevicesById[devid].seq = 1&lt;&lt;SEQ_SHIFT;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;找到了空闲位置后，就为这个输入设备文件创建相应的device_t信息：<span style="font-family:monospace; white-space:pre"></span><br><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 17863px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_24" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_24" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=24&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>mDevicesById[devid].seq&nbsp;=&nbsp;(mDevicesById[devid].seq+(1&lt;&lt;SEQ_SHIFT))&amp;SEQ_MASK;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">if</span><span>&nbsp;(mDevicesById[devid].seq&nbsp;==&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mDevicesById[devid].seq&nbsp;=&nbsp;1&lt;&lt;SEQ_SHIFT;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>new_mFDs&nbsp;=&nbsp;(pollfd*)realloc(mFDs,&nbsp;<span class="keyword">sizeof</span><span>(mFDs[0])&nbsp;*&nbsp;(mFDCount&nbsp;+&nbsp;1));&nbsp;&nbsp;</span></span></li><li class="alt"><span>new_devices&nbsp;=&nbsp;(device_t**)realloc(mDevices,&nbsp;<span class="keyword">sizeof</span><span>(mDevices[0])&nbsp;*&nbsp;(mFDCount&nbsp;+&nbsp;1));&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">if</span><span>&nbsp;(new_mFDs&nbsp;==&nbsp;NULL&nbsp;||&nbsp;new_devices&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"out&nbsp;of&nbsp;memory"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>mFDs&nbsp;=&nbsp;new_mFDs;&nbsp;&nbsp;</span></li><li class="alt"><span>mDevices&nbsp;=&nbsp;new_devices;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>device_t*&nbsp;device&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;device_t(devid|mDevicesById[devid].seq,&nbsp;deviceName,&nbsp;name);&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">if</span><span>&nbsp;(device&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"out&nbsp;of&nbsp;memory"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>device-&gt;fd&nbsp;=&nbsp;fd;&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_24_6551526" name="code" class="cpp" style="display: none;">mDevicesById[devid].seq = (mDevicesById[devid].seq+(1&lt;&lt;SEQ_SHIFT))&amp;SEQ_MASK;
if (mDevicesById[devid].seq == 0) {
	mDevicesById[devid].seq = 1&lt;&lt;SEQ_SHIFT;
}

new_mFDs = (pollfd*)realloc(mFDs, sizeof(mFDs[0]) * (mFDCount + 1));
new_devices = (device_t**)realloc(mDevices, sizeof(mDevices[0]) * (mFDCount + 1));
if (new_mFDs == NULL || new_devices == NULL) {
	LOGE("out of memory");
	return -1;
}
mFDs = new_mFDs;
mDevices = new_devices;

......

device_t* device = new device_t(devid|mDevicesById[devid].seq, deviceName, name);
if (device == NULL) {
	LOGE("out of memory");
	return -1;
}

device-&gt;fd = fd;</pre><p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;同时，这个设备文件还会保存在数组mFDs中：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 18376px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_25" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_25" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=25&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>mFDs[mFDCount].fd&nbsp;=&nbsp;fd;&nbsp;&nbsp;</span></span></li><li class=""><span>mFDs[mFDCount].events&nbsp;=&nbsp;POLLIN;&nbsp;&nbsp;</span></li><li class="alt"><span>mFDs[mFDCount].revents&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_25_4741383" name="code" class="cpp" style="display: none;">mFDs[mFDCount].fd = fd;
mFDs[mFDCount].events = POLLIN;
mFDs[mFDCount].revents = 0;</pre>&nbsp;&nbsp; &nbsp; &nbsp; 接下来查看这个设备是不是键盘：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 18529px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_26" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_26" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=26&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;Figure&nbsp;out&nbsp;the&nbsp;kinds&nbsp;of&nbsp;events&nbsp;the&nbsp;device&nbsp;reports.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>uint8_t&nbsp;key_bitmask[sizeof_bit_array(KEY_MAX&nbsp;+&nbsp;1)];&nbsp;&nbsp;</span></li><li class=""><span>memset(key_bitmask,&nbsp;0,&nbsp;<span class="keyword">sizeof</span><span>(key_bitmask));&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>LOGV(<span class="string">"Getting&nbsp;keys..."</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(ioctl(fd,&nbsp;EVIOCGBIT(EV_KEY,&nbsp;</span><span class="keyword">sizeof</span><span>(key_bitmask)),&nbsp;key_bitmask)&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;See&nbsp;if&nbsp;this&nbsp;is&nbsp;a&nbsp;keyboard.&nbsp;&nbsp;Ignore&nbsp;everything&nbsp;in&nbsp;the&nbsp;button&nbsp;range&nbsp;except&nbsp;for</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;gamepads&nbsp;which&nbsp;are&nbsp;also&nbsp;considered&nbsp;keyboards.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(containsNonZeroByte(key_bitmask,&nbsp;0,&nbsp;sizeof_bit_array(BTN_MISC))&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;containsNonZeroByte(key_bitmask,&nbsp;sizeof_bit_array(BTN_GAMEPAD),&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof_bit_array(BTN_DIGI))&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;containsNonZeroByte(key_bitmask,&nbsp;sizeof_bit_array(KEY_OK),&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof_bit_array(KEY_MAX&nbsp;+&nbsp;1)))&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;classes&nbsp;|=&nbsp;INPUT_DEVICE_CLASS_KEYBOARD;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;keyBitmask&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;uint8_t[</span><span class="keyword">sizeof</span><span>(key_bitmask)];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;keyBitmask&nbsp;!=&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(device-&gt;keyBitmask,&nbsp;key_bitmask,&nbsp;<span class="keyword">sizeof</span><span>(key_bitmask));&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">delete</span><span>&nbsp;device;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"out&nbsp;of&nbsp;memory&nbsp;allocating&nbsp;key&nbsp;bitmask"</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-1;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_26_422984" name="code" class="cpp" style="display: none;">// Figure out the kinds of events the device reports.

uint8_t key_bitmask[sizeof_bit_array(KEY_MAX + 1)];
memset(key_bitmask, 0, sizeof(key_bitmask));

LOGV("Getting keys...");
if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(key_bitmask)), key_bitmask) &gt;= 0) {
	// See if this is a keyboard.  Ignore everything in the button range except for
	// gamepads which are also considered keyboards.
	if (containsNonZeroByte(key_bitmask, 0, sizeof_bit_array(BTN_MISC))
		|| containsNonZeroByte(key_bitmask, sizeof_bit_array(BTN_GAMEPAD),
		sizeof_bit_array(BTN_DIGI))
		|| containsNonZeroByte(key_bitmask, sizeof_bit_array(KEY_OK),
		sizeof_bit_array(KEY_MAX + 1))) {
			device-&gt;classes |= INPUT_DEVICE_CLASS_KEYBOARD;

			device-&gt;keyBitmask = new uint8_t[sizeof(key_bitmask)];
			if (device-&gt;keyBitmask != NULL) {
				memcpy(device-&gt;keyBitmask, key_bitmask, sizeof(key_bitmask));
			} else {
				delete device;
				LOGE("out of memory allocating key bitmask");
				return -1;
			}
	}
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果是的话，还要继续进一步初始化前面为这个设备文件所创建的device_t结构体，主要就是把结构体device的classes成员变量的INPUT_DEVICE_CLASS_KEYBOARD位置为1了，以表明这是一个键盘。<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果是键盘设备，初始化工作还未完成，还要继续设置键盘的布局等信息：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 19148px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_27" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_27" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=27&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">if</span><span>&nbsp;((device-&gt;classes&nbsp;&amp;&nbsp;INPUT_DEVICE_CLASS_KEYBOARD)&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;tmpfn[</span><span class="keyword">sizeof</span><span>(name)];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;keylayoutFilename[300];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;a&nbsp;more&nbsp;descriptive&nbsp;name</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;name&nbsp;=&nbsp;name;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;replace&nbsp;all&nbsp;the&nbsp;spaces&nbsp;with&nbsp;underscores</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;strcpy(tmpfn,&nbsp;name);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">char</span><span>&nbsp;*p&nbsp;=&nbsp;strchr(tmpfn,&nbsp;</span><span class="string">'&nbsp;'</span><span>);&nbsp;p&nbsp;&amp;&amp;&nbsp;*p;&nbsp;p&nbsp;=&nbsp;strchr(tmpfn,&nbsp;</span><span class="string">'&nbsp;'</span><span>))&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*p&nbsp;=&nbsp;<span class="string">'_'</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;find&nbsp;the&nbsp;.kl&nbsp;file&nbsp;we&nbsp;need&nbsp;for&nbsp;this&nbsp;device</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>*&nbsp;root&nbsp;=&nbsp;getenv(</span><span class="string">"ANDROID_ROOT"</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;snprintf(keylayoutFilename,&nbsp;<span class="keyword">sizeof</span><span>(keylayoutFilename),&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"%s/usr/keylayout/%s.kl"</span><span>,&nbsp;root,&nbsp;tmpfn);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">bool</span><span>&nbsp;defaultKeymap&nbsp;=&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(access(keylayoutFilename,&nbsp;R_OK))&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(keylayoutFilename,&nbsp;<span class="keyword">sizeof</span><span>(keylayoutFilename),&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"%s/usr/keylayout/%s"</span><span>,&nbsp;root,&nbsp;</span><span class="string">"qwerty.kl"</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultKeymap&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;device-&gt;layoutMap-&gt;load(keylayoutFilename);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(status)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"Error&nbsp;%d&nbsp;loading&nbsp;key&nbsp;layout."</span><span>,&nbsp;status);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;tell&nbsp;the&nbsp;world&nbsp;about&nbsp;the&nbsp;devname&nbsp;(the&nbsp;descriptive&nbsp;name)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!mHaveFirstKeyboard&nbsp;&amp;&amp;&nbsp;!defaultKeymap&nbsp;&amp;&amp;&nbsp;strstr(name,&nbsp;</span><span class="string">"-keypad"</span><span>))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;the&nbsp;built-in&nbsp;keyboard&nbsp;has&nbsp;a&nbsp;well-known&nbsp;device&nbsp;ID&nbsp;of&nbsp;0,</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;this&nbsp;device&nbsp;better&nbsp;not&nbsp;go&nbsp;away.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mHaveFirstKeyboard&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFirstKeyboardId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property_set(<span class="string">"hw.keyboards.0.devname"</span><span>,&nbsp;name);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;ensure&nbsp;mFirstKeyboardId&nbsp;is&nbsp;set&nbsp;to&nbsp;-something-.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mFirstKeyboardId&nbsp;==&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFirstKeyboardId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;propName[100];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;sprintf(propName,&nbsp;<span class="string">"hw.keyboards.%u.devname"</span><span>,&nbsp;device-&gt;id);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;property_set(propName,&nbsp;name);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;'Q'&nbsp;key&nbsp;support&nbsp;=&nbsp;cheap&nbsp;test&nbsp;of&nbsp;whether&nbsp;this&nbsp;is&nbsp;an&nbsp;alpha-capable&nbsp;kbd</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(hasKeycodeLocked(device,&nbsp;AKEYCODE_Q))&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;classes&nbsp;|=&nbsp;INPUT_DEVICE_CLASS_ALPHAKEY;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;See&nbsp;if&nbsp;this&nbsp;device&nbsp;has&nbsp;a&nbsp;DPAD.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_UP)&nbsp;&amp;&amp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_DOWN)&nbsp;&amp;&amp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_LEFT)&nbsp;&amp;&amp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_RIGHT)&nbsp;&amp;&amp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasKeycodeLocked(device,&nbsp;AKEYCODE_DPAD_CENTER))&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;classes&nbsp;|=&nbsp;INPUT_DEVICE_CLASS_DPAD;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;See&nbsp;if&nbsp;this&nbsp;device&nbsp;has&nbsp;a&nbsp;gamepad.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">size_t</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;</span><span class="keyword">sizeof</span><span>(GAMEPAD_KEYCODES)/</span><span class="keyword">sizeof</span><span>(GAMEPAD_KEYCODES[0]);&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(hasKeycodeLocked(device,&nbsp;GAMEPAD_KEYCODES[i]))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;classes&nbsp;|=&nbsp;INPUT_DEVICE_CLASS_GAMEPAD;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGI(<span class="string">"New&nbsp;keyboard:&nbsp;device-&gt;id=0x%x&nbsp;devname='%s'&nbsp;propName='%s'&nbsp;keylayout='%s'\n"</span><span>,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;id,&nbsp;name,&nbsp;propName,&nbsp;keylayoutFilename);&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_27_2516535" name="code" class="cpp" style="display: none;">if ((device-&gt;classes &amp; INPUT_DEVICE_CLASS_KEYBOARD) != 0) {
	char tmpfn[sizeof(name)];
	char keylayoutFilename[300];

	// a more descriptive name
	device-&gt;name = name;

	// replace all the spaces with underscores
	strcpy(tmpfn, name);
	for (char *p = strchr(tmpfn, ' '); p &amp;&amp; *p; p = strchr(tmpfn, ' '))
		*p = '_';

	// find the .kl file we need for this device
	const char* root = getenv("ANDROID_ROOT");
	snprintf(keylayoutFilename, sizeof(keylayoutFilename),
		"%s/usr/keylayout/%s.kl", root, tmpfn);
	bool defaultKeymap = false;
	if (access(keylayoutFilename, R_OK)) {
		snprintf(keylayoutFilename, sizeof(keylayoutFilename),
			"%s/usr/keylayout/%s", root, "qwerty.kl");
		defaultKeymap = true;
	}
	status_t status = device-&gt;layoutMap-&gt;load(keylayoutFilename);
	if (status) {
		LOGE("Error %d loading key layout.", status);
	}

	// tell the world about the devname (the descriptive name)
	if (!mHaveFirstKeyboard &amp;&amp; !defaultKeymap &amp;&amp; strstr(name, "-keypad")) {
		// the built-in keyboard has a well-known device ID of 0,
		// this device better not go away.
		mHaveFirstKeyboard = true;
		mFirstKeyboardId = device-&gt;id;
		property_set("hw.keyboards.0.devname", name);
	} else {
		// ensure mFirstKeyboardId is set to -something-.
		if (mFirstKeyboardId == 0) {
			mFirstKeyboardId = device-&gt;id;
		}
	}
	char propName[100];
	sprintf(propName, "hw.keyboards.%u.devname", device-&gt;id);
	property_set(propName, name);

	// 'Q' key support = cheap test of whether this is an alpha-capable kbd
	if (hasKeycodeLocked(device, AKEYCODE_Q)) {
		device-&gt;classes |= INPUT_DEVICE_CLASS_ALPHAKEY;
	}

	// See if this device has a DPAD.
	if (hasKeycodeLocked(device, AKEYCODE_DPAD_UP) &amp;&amp;
		hasKeycodeLocked(device, AKEYCODE_DPAD_DOWN) &amp;&amp;
		hasKeycodeLocked(device, AKEYCODE_DPAD_LEFT) &amp;&amp;
		hasKeycodeLocked(device, AKEYCODE_DPAD_RIGHT) &amp;&amp;
		hasKeycodeLocked(device, AKEYCODE_DPAD_CENTER)) {
			device-&gt;classes |= INPUT_DEVICE_CLASS_DPAD;
	}

	// See if this device has a gamepad.
	for (size_t i = 0; i &lt; sizeof(GAMEPAD_KEYCODES)/sizeof(GAMEPAD_KEYCODES[0]); i++) {
		if (hasKeycodeLocked(device, GAMEPAD_KEYCODES[i])) {
			device-&gt;classes |= INPUT_DEVICE_CLASS_GAMEPAD;
			break;
		}
	}

	LOGI("New keyboard: device-&gt;id=0x%x devname='%s' propName='%s' keylayout='%s'\n",
		device-&gt;id, name, propName, keylayoutFilename);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;到这里，系统中的输入设备文件就打开了。<p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到Step 18中，我们继续分析EventHub.getEvent函数的实现。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在中间的for循环里面，首先会检查当前是否有输入设备被关闭，如果有，就返回一个设备移除的事件给调用方：</p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 20595px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_28" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_28" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=28&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;Report&nbsp;any&nbsp;devices&nbsp;that&nbsp;had&nbsp;last&nbsp;been&nbsp;added/removed.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">if</span><span>&nbsp;(mClosingDevices&nbsp;!=&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;device_t*&nbsp;device&nbsp;=&nbsp;mClosingDevices;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"Reporting&nbsp;device&nbsp;closed:&nbsp;id=0x%x,&nbsp;name=%s\n"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;id,&nbsp;device-&gt;path.string());&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mClosingDevices&nbsp;=&nbsp;device-&gt;next;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;id&nbsp;==&nbsp;mFirstKeyboardId)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;DEVICE_REMOVED;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;systemTime(SYSTEM_TIME_MONOTONIC);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">delete</span><span>&nbsp;device;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mNeedToSendFinishedDeviceScan&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_28_914135" name="code" class="cpp" style="display: none;">// Report any devices that had last been added/removed.
if (mClosingDevices != NULL) {
	device_t* device = mClosingDevices;
	LOGV("Reporting device closed: id=0x%x, name=%s\n",
		device-&gt;id, device-&gt;path.string());
	mClosingDevices = device-&gt;next;
	if (device-&gt;id == mFirstKeyboardId) {
		outEvent-&gt;deviceId = 0;
	} else {
		outEvent-&gt;deviceId = device-&gt;id;
	}
	outEvent-&gt;type = DEVICE_REMOVED;
	outEvent-&gt;when = systemTime(SYSTEM_TIME_MONOTONIC);
	delete device;
	mNeedToSendFinishedDeviceScan = true;
	return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接着，检查当前是否有新的输入设备加入进来：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 21000px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_29" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_29" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=29&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(mOpeningDevices&nbsp;!=&nbsp;NULL)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;device_t*&nbsp;device&nbsp;=&nbsp;mOpeningDevices;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"Reporting&nbsp;device&nbsp;opened:&nbsp;id=0x%x,&nbsp;name=%s\n"</span><span>,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;id,&nbsp;device-&gt;path.string());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mOpeningDevices&nbsp;=&nbsp;device-&gt;next;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;id&nbsp;==&nbsp;mFirstKeyboardId)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;DEVICE_ADDED;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;systemTime(SYSTEM_TIME_MONOTONIC);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mNeedToSendFinishedDeviceScan&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_29_6039329" name="code" class="cpp" style="display: none;">if (mOpeningDevices != NULL) {
	device_t* device = mOpeningDevices;
	LOGV("Reporting device opened: id=0x%x, name=%s\n",
		device-&gt;id, device-&gt;path.string());
	mOpeningDevices = device-&gt;next;
	if (device-&gt;id == mFirstKeyboardId) {
		outEvent-&gt;deviceId = 0;
	} else {
		outEvent-&gt;deviceId = device-&gt;id;
	}
	outEvent-&gt;type = DEVICE_ADDED;
	outEvent-&gt;when = systemTime(SYSTEM_TIME_MONOTONIC);
	mNeedToSendFinishedDeviceScan = true;
	return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接着，再检查是否需要结束监控输入事件：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 21369px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_30" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_30" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=30&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(mNeedToSendFinishedDeviceScan)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mNeedToSendFinishedDeviceScan&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;FINISHED_DEVICE_SCAN;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;systemTime(SYSTEM_TIME_MONOTONIC);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_30_9212675" name="code" class="cpp" style="display: none;">if (mNeedToSendFinishedDeviceScan) {
	mNeedToSendFinishedDeviceScan = false;
	outEvent-&gt;type = FINISHED_DEVICE_SCAN;
	outEvent-&gt;when = systemTime(SYSTEM_TIME_MONOTONIC);
	return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后，就是要检查当前是否有还未处理的输入设备事件发生了：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 21576px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_31" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_31" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=31&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;Grab&nbsp;the&nbsp;next&nbsp;input&nbsp;event.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">for</span><span>&nbsp;(;;)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Consume&nbsp;buffered&nbsp;input&nbsp;events,&nbsp;if&nbsp;any.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInputBufferIndex&nbsp;&lt;&nbsp;mInputBufferCount)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;</span><span class="keyword">struct</span><span>&nbsp;input_event&amp;&nbsp;iev&nbsp;=&nbsp;mInputBufferData[mInputBufferIndex++];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;device_t*&nbsp;device&nbsp;=&nbsp;mDevices[mInputDeviceIndex];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"%s&nbsp;got:&nbsp;t0=%d,&nbsp;t1=%d,&nbsp;type=%d,&nbsp;code=%d,&nbsp;v=%d"</span><span>,&nbsp;device-&gt;path.string(),&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="datatypes">int</span><span>)&nbsp;iev.time.tv_sec,&nbsp;(</span><span class="datatypes">int</span><span>)&nbsp;iev.time.tv_usec,&nbsp;iev.type,&nbsp;iev.code,&nbsp;iev.value);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;id&nbsp;==&nbsp;mFirstKeyboardId)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;deviceId&nbsp;=&nbsp;device-&gt;id;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;type&nbsp;=&nbsp;iev.type;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;scanCode&nbsp;=&nbsp;iev.code;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(iev.type&nbsp;==&nbsp;EV_KEY)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;err&nbsp;=&nbsp;device-&gt;layoutMap-&gt;map(iev.code,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;outEvent-&gt;keyCode,&nbsp;&amp;&nbsp;outEvent-&gt;flags);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGV(<span class="string">"iev.code=%d&nbsp;keyCode=%d&nbsp;flags=0x%08x&nbsp;err=%d\n"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iev.code,&nbsp;outEvent-&gt;keyCode,&nbsp;outEvent-&gt;flags,&nbsp;err);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(err&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;keyCode&nbsp;=&nbsp;AKEYCODE_UNKNOWN;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;flags&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;keyCode&nbsp;=&nbsp;iev.code;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;value&nbsp;=&nbsp;iev.value;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Use&nbsp;an&nbsp;event&nbsp;timestamp&nbsp;in&nbsp;the&nbsp;same&nbsp;timebase&nbsp;as</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;java.lang.System.nanoTime()&nbsp;and&nbsp;android.os.SystemClock.uptimeMillis()</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;as&nbsp;expected&nbsp;by&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;system.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outEvent-&gt;when&nbsp;=&nbsp;systemTime(SYSTEM_TIME_MONOTONIC);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Finish&nbsp;reading&nbsp;all&nbsp;events&nbsp;from&nbsp;devices&nbsp;identified&nbsp;in&nbsp;previous&nbsp;poll().</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;This&nbsp;code&nbsp;assumes&nbsp;that&nbsp;mInputDeviceIndex&nbsp;is&nbsp;initially&nbsp;0&nbsp;and&nbsp;that&nbsp;the</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;revents&nbsp;member&nbsp;of&nbsp;pollfd&nbsp;is&nbsp;initialized&nbsp;to&nbsp;0&nbsp;when&nbsp;the&nbsp;device&nbsp;is&nbsp;first&nbsp;added.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Since&nbsp;mFDs[0]&nbsp;is&nbsp;used&nbsp;for&nbsp;inotify,&nbsp;we&nbsp;process&nbsp;regular&nbsp;events&nbsp;starting&nbsp;at&nbsp;index&nbsp;1.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mInputDeviceIndex&nbsp;+=&nbsp;1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInputDeviceIndex&nbsp;&gt;=&nbsp;mFDCount)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;</span><span class="keyword">struct</span><span>&nbsp;pollfd&amp;&nbsp;pfd&nbsp;=&nbsp;mFDs[mInputDeviceIndex];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(pfd.revents&nbsp;&amp;&nbsp;POLLIN)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;readSize&nbsp;=&nbsp;read(pfd.fd,&nbsp;mInputBufferData,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sizeof</span><span>(</span><span class="keyword">struct</span><span>&nbsp;input_event)&nbsp;*&nbsp;INPUT_BUFFER_SIZE);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(readSize&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(errno&nbsp;!=&nbsp;EAGAIN&nbsp;&amp;&amp;&nbsp;errno&nbsp;!=&nbsp;EINTR)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGW(<span class="string">"could&nbsp;not&nbsp;get&nbsp;event&nbsp;(errno=%d)"</span><span>,&nbsp;errno);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;((readSize&nbsp;%&nbsp;</span><span class="keyword">sizeof</span><span>(</span><span class="keyword">struct</span><span>&nbsp;input_event))&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"could&nbsp;not&nbsp;get&nbsp;event&nbsp;(wrong&nbsp;size:&nbsp;%d)"</span><span>,&nbsp;readSize);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputBufferCount&nbsp;=&nbsp;readSize&nbsp;/&nbsp;<span class="keyword">sizeof</span><span>(</span><span class="keyword">struct</span><span>&nbsp;input_event);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputBufferIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_31_2070378" name="code" class="cpp" style="display: none;">// Grab the next input event.
for (;;) {
	// Consume buffered input events, if any.
	if (mInputBufferIndex &lt; mInputBufferCount) {
		const struct input_event&amp; iev = mInputBufferData[mInputBufferIndex++];
		const device_t* device = mDevices[mInputDeviceIndex];

		LOGV("%s got: t0=%d, t1=%d, type=%d, code=%d, v=%d", device-&gt;path.string(),
			(int) iev.time.tv_sec, (int) iev.time.tv_usec, iev.type, iev.code, iev.value);
		if (device-&gt;id == mFirstKeyboardId) {
			outEvent-&gt;deviceId = 0;
		} else {
			outEvent-&gt;deviceId = device-&gt;id;
		}
		outEvent-&gt;type = iev.type;
		outEvent-&gt;scanCode = iev.code;
		if (iev.type == EV_KEY) {
			status_t err = device-&gt;layoutMap-&gt;map(iev.code,
				&amp; outEvent-&gt;keyCode, &amp; outEvent-&gt;flags);
			LOGV("iev.code=%d keyCode=%d flags=0x%08x err=%d\n",
				iev.code, outEvent-&gt;keyCode, outEvent-&gt;flags, err);
			if (err != 0) {
				outEvent-&gt;keyCode = AKEYCODE_UNKNOWN;
				outEvent-&gt;flags = 0;
			}
		} else {
			outEvent-&gt;keyCode = iev.code;
		}
		outEvent-&gt;value = iev.value;

		// Use an event timestamp in the same timebase as
		// java.lang.System.nanoTime() and android.os.SystemClock.uptimeMillis()
		// as expected by the rest of the system.
		outEvent-&gt;when = systemTime(SYSTEM_TIME_MONOTONIC);
		return true;
	}

	// Finish reading all events from devices identified in previous poll().
	// This code assumes that mInputDeviceIndex is initially 0 and that the
	// revents member of pollfd is initialized to 0 when the device is first added.
	// Since mFDs[0] is used for inotify, we process regular events starting at index 1.
	mInputDeviceIndex += 1;
	if (mInputDeviceIndex &gt;= mFDCount) {
		break;
	}

	const struct pollfd&amp; pfd = mFDs[mInputDeviceIndex];
	if (pfd.revents &amp; POLLIN) {
		int32_t readSize = read(pfd.fd, mInputBufferData,
			sizeof(struct input_event) * INPUT_BUFFER_SIZE);
		if (readSize &lt; 0) {
			if (errno != EAGAIN &amp;&amp; errno != EINTR) {
				LOGW("could not get event (errno=%d)", errno);
			}
		} else if ((readSize % sizeof(struct input_event)) != 0) {
			LOGE("could not get event (wrong size: %d)", readSize);
		} else {
			mInputBufferCount = readSize / sizeof(struct input_event);
			mInputBufferIndex = 0;
		}
	}
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;未处理的输入事件保存在成员变量mInputBufferData中，如果有的话，就可以直接返回了，否则的话，就要通过系统调用poll来等待输入设备上发生新的事件了，在我们这个场景中，就是等待键盘有键被按下或者松开了。：<p></p><p align="left"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 22832px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_32" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_32" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=32&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;pollResult&nbsp;=&nbsp;poll(mFDs,&nbsp;mFDCount,&nbsp;-1);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_32_4687317" name="code" class="cpp" style="display: none;">int pollResult = poll(mFDs, mFDCount, -1);</pre><p></p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的mFDs包含了我们所要监控的输入设备的打开文件描述符，这是在前面的openPlatformInput函数中初始化的。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 22. poll</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这是一个Linux系统的文件操作系统调用，它用来查询指定的文件列表是否有有可读写的，如果有，就马上返回，否则的话，就阻塞线程，并等待驱动程序唤醒，重新调用poll函数，或超时返回。在我们的这个场景中，就是要查询是否有键盘事件发生，如果有的话，就返回，否则的话，当前线程就睡眠等待键盘事件的发生了。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这样，InputManager的启动过程就分析完了，下面我们再分析应用程序注册键盘消息接收通道的过程。</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp;应用程序注册键盘消息接收通道的过程分析</p><p align="left">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;InputManager启动以后，就开始负责监控键盘输入事件了。当InputManager监控到键盘输入事件时，它应该把这个键盘事件分发给谁呢？当然是要把这个键盘消息分发给当前激活的Activity窗口了，不过，当前激活的Activity窗口还需要主动注册一个键盘消息接收通道到InputManager中去，InputManager才能把这个键盘消息分发给它处理。那么，当前被激活的Activity窗口又是什么时候去注册这个键盘消息接收通道的呢？在前面一篇文章Android应用程序启动过程源代码分析中，我们分析Android应用程序的启动过程时，在Step 33中分析到ActivityThread类的handleLaunchActivity函数中，我们曾经说过，当函数handleLaunchActivity调用performLaunchActivity函数来加载这个完毕应用程序的默认Activity后，再次回到handleLaunchActivity函数时，会调用handleResumeActivity函数来使这个Activity进入Resumed状态。在调用handleResumeActivity函数的过程中，ActivityThread会通过android.view.WindowManagerImpl类为该Activity创建一个ViewRoot实例，并且会通过调用ViewRoot类的setView成员函数把与该Activity关联的View设置到这个ViewRoot中去，而Activity正是通过ViewRoot类的setView成员函数来注册键盘消息接收通道的。</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;有了这些背影知识后，接下来，我们就可以从ViewRoot.setView函数开始分析应用程序注册键盘消息接收通道的过程了。首先看一下这个注册过程的序列图，然后再详细分析每一个步骤：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"><img width="710" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/0_1319372058cnwW.gif" alt=""><br></p><p align="left" style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "><a target="_blank" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/0_1319372058cnwW.gif">点击查看大图</a></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. ViewRoot.setView</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 24371px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_33" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_33" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=33&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;setView(View&nbsp;view,&nbsp;WindowManager.LayoutParams&nbsp;attrs,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View&nbsp;panelParentView)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(</span><span class="keyword">this</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mView&nbsp;==&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Schedule&nbsp;the&nbsp;first&nbsp;layout&nbsp;-before-&nbsp;adding&nbsp;to&nbsp;the&nbsp;window</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;manager,&nbsp;to&nbsp;make&nbsp;sure&nbsp;we&nbsp;do&nbsp;the&nbsp;relayout&nbsp;before&nbsp;receiving</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;any&nbsp;other&nbsp;events&nbsp;from&nbsp;the&nbsp;system.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestLayout();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputChannel&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputChannel();&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;sWindowSession.add(mWindow,&nbsp;mWindowAttributes,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getHostVisibility(),&nbsp;mAttachInfo.mContentInsets,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputChannel);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(RemoteException&nbsp;e)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">finally</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(view&nbsp;</span><span class="keyword">instanceof</span><span>&nbsp;RootViewSurfaceTaker)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputQueueCallback&nbsp;=&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInputQueueCallback&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputQueue&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputQueue(mInputChannel);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputQueueCallback.onInputQueueCreated(mInputQueue);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputQueue.registerInputChannel(mInputChannel,&nbsp;mInputHandler,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Looper.myQueue());&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_33_3433581" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	public void setView(View view, WindowManager.LayoutParams attrs,
			View panelParentView) {
		......

		synchronized (this) {
			if (mView == null) {
				......

				// Schedule the first layout -before- adding to the window
				// manager, to make sure we do the relayout before receiving
				// any other events from the system.
				requestLayout();
				mInputChannel = new InputChannel();
				try {
					res = sWindowSession.add(mWindow, mWindowAttributes,
						getHostVisibility(), mAttachInfo.mContentInsets,
						mInputChannel);
				} catch (RemoteException e) {
					......
				} finally {
					......
				}

				......

				if (view instanceof RootViewSurfaceTaker) {
					mInputQueueCallback =
						((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();
				}
				if (mInputQueueCallback != null) {
					mInputQueue = new InputQueue(mInputChannel);
					mInputQueueCallback.onInputQueueCreated(mInputQueue);
				} else {
					InputQueue.registerInputChannel(mInputChannel, mInputHandler,
						Looper.myQueue());
				}

				......
			}
		}
	}

}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数中与注册键盘消息接收通道（InputChannel）相关的逻辑主要有三处，一是调用requestLayout函数来通知InputManager，这个Activity窗口是当前被激活的窗口，二是调用sWindowSession（WindowManagerService内部类Session的远程接口）的add成员函数来把键盘消息接收通道的一端注册在InputManager中，三是调用InputQueue的registerInputChannel成员函数来把键盘消息接收通道的另一端注册在本应用程序的消息循环（Looper）中。这样，当InputManager监控到有键盘消息时，就会先找到当前被激活的窗口，然后找到其在InputManager中对应的键盘消息接收通道，通过这个通道在InputManager中的一端来通知在应用程序消息循环中的另一端，就把键盘消息分发给当前激活的Activity窗口了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在接下来的内容中，我们首先描述requestLayout函数是如何告诉InputManager当前的Activity窗口便是激活窗口的，接着再回过头来分析应用程序是如何把键盘消息接收通道的一端注册到InputManager中去的，最后分析应用程序是如何键盘消息接收通道的另一端注册到本应用程序的消息循环中去了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2.&nbsp;ViewRoot.requestLayout</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 25656px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_34" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_34" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=34&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;requestLayout()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mLayoutRequested&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scheduleTraversals();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_34_194978" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	public void requestLayout() {
		......
		mLayoutRequested = true;
		scheduleTraversals();
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数调用了scheduleTraversals函数来进一步执行操作，由于篇幅关系，我们就不详细描述scheduleTraversals函数了，简单来说，在scheduleTraversals函数中，会通过sendEmptyMessage(DO_TRAVERSAL)发送一个消息到应用程序的消息队列中，这个消息最终由ViewRoot的handleMessage函数处理，而ViewRoot的handleMessage函数把这个消息交给ViewRoot类的performTraversals来处理，在performTraversals函数中，又会调用ViewRoot类的relayoutWindow函数来进一步执行操作，最后在relayoutWindow函数中，就会通过WindowManagerService内部类Session的远程接口sWindowSession的relayout函数来进入到WindowManagerService中。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3.&nbsp;WindowManagerService.Session.relayout</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java&nbsp;文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 26213px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_35" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_35" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=35&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Session&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowSession.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;IBinder.DeathRecipient&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;relayout(IWindow&nbsp;window,&nbsp;WindowManager.LayoutParams&nbsp;attrs,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;requestedWidth,&nbsp;</span><span class="keyword">int</span><span>&nbsp;requestedHeight,&nbsp;</span><span class="keyword">int</span><span>&nbsp;viewFlags,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;insetsPending,&nbsp;Rect&nbsp;outFrame,&nbsp;Rect&nbsp;outContentInsets,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rect&nbsp;outVisibleInsets,&nbsp;Configuration&nbsp;outConfig,&nbsp;Surface&nbsp;outSurface)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Log.d(TAG,&nbsp;"&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;ENTERED&nbsp;relayout&nbsp;from&nbsp;"&nbsp;+&nbsp;Binder.getCallingPid());</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;res&nbsp;=&nbsp;relayoutWindow(</span><span class="keyword">this</span><span>,&nbsp;window,&nbsp;attrs,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestedWidth,&nbsp;requestedHeight,&nbsp;viewFlags,&nbsp;insetsPending,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outFrame,&nbsp;outContentInsets,&nbsp;outVisibleInsets,&nbsp;outConfig,&nbsp;outSurface);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Log.d(TAG,&nbsp;"&lt;&lt;&lt;&lt;&lt;&lt;&nbsp;EXITING&nbsp;relayout&nbsp;to&nbsp;"&nbsp;+&nbsp;Binder.getCallingPid());</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;res;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_35_5876579" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	private final class Session extends IWindowSession.Stub
			implements IBinder.DeathRecipient {
		......

		public int relayout(IWindow window, WindowManager.LayoutParams attrs,
				int requestedWidth, int requestedHeight, int viewFlags,
				boolean insetsPending, Rect outFrame, Rect outContentInsets,
				Rect outVisibleInsets, Configuration outConfig, Surface outSurface) {
			//Log.d(TAG, "&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from " + Binder.getCallingPid());
			int res = relayoutWindow(this, window, attrs,
					requestedWidth, requestedHeight, viewFlags, insetsPending,
					outFrame, outContentInsets, outVisibleInsets, outConfig, outSurface);
			//Log.d(TAG, "&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to " + Binder.getCallingPid());
			return res;
		}

		......
	}

	......
}</pre><p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数只是简单地调用WindowManagerService的成员函数relayoutWIndow来进一步处理。</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 4.&nbsp;WindowManagerService.relayoutWIndow</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java&nbsp;文件中：<br></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 26849px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_36" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_36" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=36&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;relayoutWindow(Session&nbsp;session,&nbsp;IWindow&nbsp;client,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowManager.LayoutParams&nbsp;attrs,&nbsp;<span class="keyword">int</span><span>&nbsp;requestedWidth,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;requestedHeight,&nbsp;</span><span class="keyword">int</span><span>&nbsp;viewVisibility,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;insetsPending,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rect&nbsp;outFrame,&nbsp;Rect&nbsp;outContentInsets,&nbsp;Rect&nbsp;outVisibleInsets,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configuration&nbsp;outConfig,&nbsp;Surface&nbsp;outSurface)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>(mWindowMap)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputMonitor.updateInputWindowsLw();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_36_2114588" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	public int relayoutWindow(Session session, IWindow client,
			WindowManager.LayoutParams attrs, int requestedWidth,
			int requestedHeight, int viewVisibility, boolean insetsPending,
			Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,
			Configuration outConfig, Surface outSurface) {
		......

		synchronized(mWindowMap) {
			......

			mInputMonitor.updateInputWindowsLw();
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数又会继续调用mInputMonitor的updateInputWindowsLw成员函数来更新当前的输入窗口，mInputMonitor是WindowManagerService的成员变量，它的类型为InputMonitor。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 5.&nbsp;InputMonitor.updateInputWindowsLw</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java&nbsp;文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 27456px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_37" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_37" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=37&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputMonitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/*&nbsp;Updates&nbsp;the&nbsp;cached&nbsp;window&nbsp;information&nbsp;provided&nbsp;to&nbsp;the&nbsp;input&nbsp;dispatcher.&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;updateInputWindowsLw()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Populate&nbsp;the&nbsp;input&nbsp;window&nbsp;list&nbsp;with&nbsp;information&nbsp;about&nbsp;all&nbsp;of&nbsp;the&nbsp;windows&nbsp;that</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;could&nbsp;potentially&nbsp;receive&nbsp;input.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;As&nbsp;an&nbsp;optimization,&nbsp;we&nbsp;could&nbsp;try&nbsp;to&nbsp;prune&nbsp;the&nbsp;list&nbsp;of&nbsp;windows&nbsp;but&nbsp;this&nbsp;turns</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;out&nbsp;to&nbsp;be&nbsp;difficult&nbsp;because&nbsp;only&nbsp;the&nbsp;native&nbsp;code&nbsp;knows&nbsp;for&nbsp;sure&nbsp;which&nbsp;window</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;currently&nbsp;has&nbsp;touch&nbsp;focus.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;ArrayList&lt;WindowState&gt;&nbsp;windows&nbsp;=&nbsp;mWindows;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;N&nbsp;=&nbsp;windows.size();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="keyword">int</span><span>&nbsp;i&nbsp;=&nbsp;N&nbsp;-&nbsp;</span><span class="number">1</span><span>;&nbsp;i&nbsp;&gt;=&nbsp;</span><span class="number">0</span><span>;&nbsp;i--)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;WindowState&nbsp;child&nbsp;=&nbsp;windows.get(i);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(child.mInputChannel&nbsp;==&nbsp;</span><span class="keyword">null</span><span>&nbsp;||&nbsp;child.mRemoved)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Skip&nbsp;this&nbsp;window&nbsp;because&nbsp;it&nbsp;cannot&nbsp;possibly&nbsp;receive&nbsp;input.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">continue</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Add&nbsp;a&nbsp;window&nbsp;to&nbsp;our&nbsp;list&nbsp;of&nbsp;input&nbsp;windows.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;InputWindow&nbsp;inputWindow&nbsp;=&nbsp;mTempInputWindows.add();&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Send&nbsp;windows&nbsp;to&nbsp;native&nbsp;code.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputManager.setInputWindows(mTempInputWindows.toNullTerminatedArray());&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_37_4208139" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	final class InputMonitor {
		......

		/* Updates the cached window information provided to the input dispatcher. */
		public void updateInputWindowsLw() {
			// Populate the input window list with information about all of the windows that
			// could potentially receive input.
			// As an optimization, we could try to prune the list of windows but this turns
			// out to be difficult because only the native code knows for sure which window
			// currently has touch focus.
			final ArrayList&lt;WindowState&gt; windows = mWindows;
			final int N = windows.size();
			for (int i = N - 1; i &gt;= 0; i--) {
				final WindowState child = windows.get(i);
				if (child.mInputChannel == null || child.mRemoved) {
					// Skip this window because it cannot possibly receive input.
					continue;
				}

				......

				// Add a window to our list of input windows.
				final InputWindow inputWindow = mTempInputWindows.add();

				......
			}

			// Send windows to native code.
			mInputManager.setInputWindows(mTempInputWindows.toNullTerminatedArray());

			......
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数将当前系统中带有InputChannel的Activity窗口都设置为InputManager的输入窗口，但是后面我们会看到，只有当前激活的窗口才会响应键盘消息。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 6.&nbsp;InputManager.setInputWindows</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/InputManager.java文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 28438px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_38" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_38" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=38&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputManager&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;setInputWindows(InputWindow[]&nbsp;windows)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nativeSetInputWindows(windows);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_38_9574095" name="code" class="java" style="display: none;">public class InputManager {
	......

	public void setInputWindows(InputWindow[] windows) {
		nativeSetInputWindows(windows);
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数调用了本地方法nativeSetInputWindows来进一步执行操作。<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 7.&nbsp;InputManager.nativeSetInputWindows<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/jni/com_android_server_InputManager.cpp&nbsp;文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 28777px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_39" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_39" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=39&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;android_server_InputManager_nativeSetInputWindows(JNIEnv*&nbsp;env,&nbsp;jclass&nbsp;clazz,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobjectArray&nbsp;windowObjArray)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(checkInputManagerUnitialized(env))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;gNativeInputManager-&gt;setInputWindows(env,&nbsp;windowObjArray);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_39_795596" name="code" class="cpp" style="display: none;">static void android_server_InputManager_nativeSetInputWindows(JNIEnv* env, jclass clazz,
        jobjectArray windowObjArray) {
    if (checkInputManagerUnitialized(env)) {
        return;
    }

    gNativeInputManager-&gt;setInputWindows(env, windowObjArray);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的gNativeInputManager我们前面分析InputManager的启动过程时已经见过了，这是一个本地InputManager对象，通过它进一步设置当前系统的输入窗口。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 8.&nbsp;NativeInputManager.setInputWindows</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/jni/com_android_server_InputManager.cpp&nbsp;文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 29147px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_40" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_40" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=40&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;NativeInputManager::setInputWindows(JNIEnv*&nbsp;env,&nbsp;jobjectArray&nbsp;windowObjArray)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;InputWindow&gt;&nbsp;windows;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;jsize&nbsp;length&nbsp;=&nbsp;env-&gt;GetArrayLength(windowObjArray);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(jsize&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;length;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;inputTargetObj&nbsp;=&nbsp;env-&gt;GetObjectArrayElement(windowObjArray,&nbsp;i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;inputTargetObj)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;</span><span class="comment">//&nbsp;found&nbsp;null&nbsp;element&nbsp;indicating&nbsp;end&nbsp;of&nbsp;used&nbsp;portion&nbsp;of&nbsp;the&nbsp;array</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows.push();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputWindow&amp;&nbsp;window&nbsp;=&nbsp;windows.editTop();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">bool</span><span>&nbsp;valid&nbsp;=&nbsp;populateWindow(env,&nbsp;inputTargetObj,&nbsp;window);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;valid)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows.pop();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env-&gt;DeleteLocalRef(inputTargetObj);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mInputManager-&gt;getDispatcher()-&gt;setInputWindows(windows);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_40_9508839" name="code" class="cpp" style="display: none;">void NativeInputManager::setInputWindows(JNIEnv* env, jobjectArray windowObjArray) {
	Vector&lt;InputWindow&gt; windows;

	jsize length = env-&gt;GetArrayLength(windowObjArray);
	for (jsize i = 0; i &lt; length; i++) {
		jobject inputTargetObj = env-&gt;GetObjectArrayElement(windowObjArray, i);
		if (! inputTargetObj) {
			break; // found null element indicating end of used portion of the array
		}

		windows.push();
		InputWindow&amp; window = windows.editTop();
		bool valid = populateWindow(env, inputTargetObj, window);
		if (! valid) {
			windows.pop();
		}

		env-&gt;DeleteLocalRef(inputTargetObj);
	}

	mInputManager-&gt;getDispatcher()-&gt;setInputWindows(windows);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先将Java层的Window转换成C++层的InputWindow，然后放在windows向量中，最后将这些输入窗口设置到InputDispatcher中去。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 9. InputDispatcher.setInputWindows</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 29754px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_41" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_41" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=41&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::setInputWindows(</span><span class="keyword">const</span><span>&nbsp;Vector&lt;InputWindow&gt;&amp;&nbsp;inputWindows)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Clear&nbsp;old&nbsp;window&nbsp;pointers.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;InputChannel&gt;&nbsp;oldFocusedWindowChannel;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mFocusedWindow)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldFocusedWindowChannel&nbsp;=&nbsp;mFocusedWindow-&gt;inputChannel;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFocusedWindow&nbsp;=&nbsp;NULL;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mWindows.clear();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Loop&nbsp;over&nbsp;new&nbsp;windows&nbsp;and&nbsp;rebuild&nbsp;the&nbsp;necessary&nbsp;window&nbsp;pointers&nbsp;for</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;tracking&nbsp;focus&nbsp;and&nbsp;touch.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mWindows.appendVector(inputWindows);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">size_t</span><span>&nbsp;numWindows&nbsp;=&nbsp;mWindows.size();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">size_t</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;numWindows;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;InputWindow*&nbsp;window&nbsp;=&nbsp;&amp;&nbsp;mWindows.itemAt(i);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(window-&gt;hasFocus)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFocusedWindow&nbsp;=&nbsp;window;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_41_8222083" name="code" class="cpp" style="display: none;">void InputDispatcher::setInputWindows(const Vector&lt;InputWindow&gt;&amp; inputWindows) {
	......

	{ // acquire lock
		AutoMutex _l(mLock);

		// Clear old window pointers.
		sp&lt;InputChannel&gt; oldFocusedWindowChannel;
		if (mFocusedWindow) {
			oldFocusedWindowChannel = mFocusedWindow-&gt;inputChannel;
			mFocusedWindow = NULL;
		}

		mWindows.clear();

		// Loop over new windows and rebuild the necessary window pointers for
		// tracking focus and touch.
		mWindows.appendVector(inputWindows);

		size_t numWindows = mWindows.size();
		for (size_t i = 0; i &lt; numWindows; i++) {
			const InputWindow* window = &amp; mWindows.itemAt(i);
			if (window-&gt;hasFocus) {
				mFocusedWindow = window;
				break;
			}
		}

		......

	} // release lock

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里InputDispatcher的成员变量mFocusedWindow就代表当前激活的窗口的。这个函数首先清空mFocusedWindow，然后再通过一个for循环检查当前的输入窗口中的哪一个窗口是获得焦点的，获得焦点的输入窗口即为当前激活的窗口。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这样，InputManager就把当前激活的Activity窗口保存在InputDispatcher中了，后面就可以把键盘消息分发给它来处理。</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到Step 1中的ViewRoot.setView函数中，接下来就调用下面语句来注册键盘消息接收通道的一端到InputManager中去：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 30655px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_42" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_42" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=42&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>mInputChannel&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;InputChannel();&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;sWindowSession.add(mWindow,&nbsp;mWindowAttributes,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getHostVisibility(),&nbsp;mAttachInfo.mContentInsets,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputChannel);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;<span class="keyword">catch</span><span>&nbsp;(RemoteException&nbsp;e)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;<span class="keyword">finally</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_42_9443582" name="code" class="java" style="display: none;">mInputChannel = new InputChannel();
try {
	res = sWindowSession.add(mWindow, mWindowAttributes,
			getHostVisibility(), mAttachInfo.mContentInsets,
			mInputChannel);
} catch (RemoteException e) {
	......
} finally {
	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面说过，这里的sWindowSession是WindowManagerService内部类Session的一个远程接口，通过它可以进入到WindowManagerService中去。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 10.&nbsp;WindowManagerService.Session.add</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java&nbsp;文件中：</p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 31038px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_43" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_43" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=43&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Session&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowSession.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;IBinder.DeathRecipient&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;add(IWindow&nbsp;window,&nbsp;WindowManager.LayoutParams&nbsp;attrs,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;viewVisibility,&nbsp;Rect&nbsp;outContentInsets,&nbsp;InputChannel&nbsp;outInputChannel)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;addWindow(</span><span class="keyword">this</span><span>,&nbsp;window,&nbsp;attrs,&nbsp;viewVisibility,&nbsp;outContentInsets,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outInputChannel);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_43_108675" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	private final class Session extends IWindowSession.Stub
			implements IBinder.DeathRecipient {
		......

		public int add(IWindow window, WindowManager.LayoutParams attrs,
				int viewVisibility, Rect outContentInsets, InputChannel outInputChannel) {
			return addWindow(this, window, attrs, viewVisibility, outContentInsets,
				outInputChannel);
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里调用WindowManagerService类的addWindow函数来进一步执行操作。<p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 11.&nbsp;WindowManagerService.addWindow</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java&nbsp;文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 31570px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_44" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_44" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=44&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;addWindow(Session&nbsp;session,&nbsp;IWindow&nbsp;client,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowManager.LayoutParams&nbsp;attrs,&nbsp;<span class="keyword">int</span><span>&nbsp;viewVisibility,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rect&nbsp;outContentInsets,&nbsp;InputChannel&nbsp;outInputChannel)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowState&nbsp;win&nbsp;=&nbsp;<span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>(mWindowMap)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;WindowState(session,&nbsp;client,&nbsp;token,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attachedWindow,&nbsp;attrs,&nbsp;viewVisibility);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(outInputChannel&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name&nbsp;=&nbsp;win.makeInputChannelName();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputChannel[]&nbsp;inputChannels&nbsp;=&nbsp;InputChannel.openInputChannelPair(name);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win.mInputChannel&nbsp;=&nbsp;inputChannels[<span class="number">0</span><span>];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannels[<span class="number">1</span><span>].transferToBinderOutParameter(outInputChannel);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputManager.registerInputChannel(win.mInputChannel);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_44_5266888" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	public int addWindow(Session session, IWindow client,
			WindowManager.LayoutParams attrs, int viewVisibility,
			Rect outContentInsets, InputChannel outInputChannel) {
		......

		WindowState win = null;

		synchronized(mWindowMap) {
			......

			win = new WindowState(session, client, token,
				attachedWindow, attrs, viewVisibility);

			......

			if (outInputChannel != null) {
				String name = win.makeInputChannelName();
				InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);
				win.mInputChannel = inputChannels[0];
				inputChannels[1].transferToBinderOutParameter(outInputChannel);
				mInputManager.registerInputChannel(win.mInputChannel);
			}

			......
		}

		......
	}

	......
}</pre><p></p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的outInputChannel即为前面在Step 1中创建的InputChannel，它不为NULL，因此，这里会通过InputChannel.openInputChannelPair函数来创建一对输入通道，其中一个位于WindowManagerService中，另外一个通过outInputChannel参数返回到应用程序中：<br><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 32359px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_45" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_45" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=45&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>inputChannels[</span><span class="number">1</span><span>].transferToBinderOutParameter(outInputChannel);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_45_8473254" name="code" class="java" style="display: none;">inputChannels[1].transferToBinderOutParameter(outInputChannel);</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;创建输入通道之前，WindowManagerService会为当前Activity窗口创建一个WindowState对象win，用来记录这个Activity窗口的状态信息。当创建这对输入管道成功以后，也会把其中的一个管道保存在这个WindowState对象win的成员变量mInputChannel中，后面要注销这个管道的时候，就是从这个WindownState对象中取回这个管道的：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 32554px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_46" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_46" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=46&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>win.mInputChannel&nbsp;=&nbsp;inputChannels[</span><span class="number">0</span><span>];&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_46_566806" name="code" class="java" style="display: none;">win.mInputChannel = inputChannels[0];</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来我们就看一下InputChannel.openInputChannelPair函数的实现。</p><p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 12.&nbsp;InputChannel.openInputChannelPair</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/InputChannel.java文件中：<br></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 32749px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_47" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_47" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=47&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputChannel&nbsp;</span><span class="keyword">implements</span><span>&nbsp;Parcelable&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/**</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Creates&nbsp;a&nbsp;new&nbsp;input&nbsp;channel&nbsp;pair.&nbsp;&nbsp;One&nbsp;channel&nbsp;should&nbsp;be&nbsp;provided&nbsp;to&nbsp;the&nbsp;input</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;dispatcher&nbsp;and&nbsp;the&nbsp;other&nbsp;to&nbsp;the&nbsp;application's&nbsp;input&nbsp;queue.</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;name&nbsp;The&nbsp;descriptive&nbsp;(non-unique)&nbsp;name&nbsp;of&nbsp;the&nbsp;channel&nbsp;pair.</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;A&nbsp;pair&nbsp;of&nbsp;input&nbsp;channels.&nbsp;&nbsp;They&nbsp;are&nbsp;symmetric&nbsp;and&nbsp;indistinguishable.</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;InputChannel[]&nbsp;openInputChannelPair(String&nbsp;name)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;nativeOpenInputChannelPair(name);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_47_8441017" name="code" class="java" style="display: none;">public final class InputChannel implements Parcelable {
	......

	/**
	* Creates a new input channel pair.  One channel should be provided to the input
	* dispatcher and the other to the application's input queue.
	* @param name The descriptive (non-unique) name of the channel pair.
	* @return A pair of input channels.  They are symmetric and indistinguishable.
	*/
	public static InputChannel[] openInputChannelPair(String name) {
		......

		return nativeOpenInputChannelPair(name);
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数调用本地方法nativeOpenInputChannelPair来进一步执行操作。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 13.&nbsp;InputChannel.nativeOpenInputChannelPair<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/core/jni/android_view_InputChannel.cpp文件中：<br></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 33224px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_48" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_48" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=48&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;jobjectArray&nbsp;android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv*&nbsp;env,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jclass&nbsp;clazz,&nbsp;jstring&nbsp;nameObj)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>*&nbsp;nameChars&nbsp;=&nbsp;env-&gt;GetStringUTFChars(nameObj,&nbsp;NULL);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String8&nbsp;name(nameChars);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env-&gt;ReleaseStringUTFChars(nameObj,&nbsp;nameChars);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;InputChannel&gt;&nbsp;serverChannel;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;InputChannel&gt;&nbsp;clientChannel;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;result&nbsp;=&nbsp;InputChannel::openInputChannelPair(name,&nbsp;serverChannel,&nbsp;clientChannel);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"Could&nbsp;not&nbsp;open&nbsp;input&nbsp;channel&nbsp;pair.&nbsp;&nbsp;status=%d"</span><span>,&nbsp;result);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jniThrowRuntimeException(env,&nbsp;<span class="string">"Could&nbsp;not&nbsp;open&nbsp;input&nbsp;channel&nbsp;pair."</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;NULL;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;TODO&nbsp;more&nbsp;robust&nbsp;error&nbsp;checking</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;serverChannelObj&nbsp;=&nbsp;android_view_InputChannel_createInputChannel(env,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">new</span><span>&nbsp;NativeInputChannel(serverChannel));&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;clientChannelObj&nbsp;=&nbsp;android_view_InputChannel_createInputChannel(env,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">new</span><span>&nbsp;NativeInputChannel(clientChannel));&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobjectArray&nbsp;channelPair&nbsp;=&nbsp;env-&gt;NewObjectArray(2,&nbsp;gInputChannelClassInfo.clazz,&nbsp;NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env-&gt;SetObjectArrayElement(channelPair,&nbsp;0,&nbsp;serverChannelObj);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env-&gt;SetObjectArrayElement(channelPair,&nbsp;1,&nbsp;clientChannelObj);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;channelPair;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_48_2486416" name="code" class="cpp" style="display: none;">static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env,
		jclass clazz, jstring nameObj) {
	 const char* nameChars = env-&gt;GetStringUTFChars(nameObj, NULL);
	 String8 name(nameChars);
	 env-&gt;ReleaseStringUTFChars(nameObj, nameChars);

	 sp&lt;InputChannel&gt; serverChannel;
	 sp&lt;InputChannel&gt; clientChannel;
	 status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);

	 if (result) {
		 LOGE("Could not open input channel pair.  status=%d", result);
		 jniThrowRuntimeException(env, "Could not open input channel pair.");
		 return NULL;
	 }

	 // TODO more robust error checking
	 jobject serverChannelObj = android_view_InputChannel_createInputChannel(env,
		 new NativeInputChannel(serverChannel));
	 jobject clientChannelObj = android_view_InputChannel_createInputChannel(env,
		 new NativeInputChannel(clientChannel));

	 jobjectArray channelPair = env-&gt;NewObjectArray(2, gInputChannelClassInfo.clazz, NULL);
	 env-&gt;SetObjectArrayElement(channelPair, 0, serverChannelObj);
	 env-&gt;SetObjectArrayElement(channelPair, 1, clientChannelObj);
	 return channelPair;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数根据传进来的参数name在C++层分别创建两个InputChannel，一个作为Server端使用，一个作为Client端使用，这里的Server端即是指InputManager，而Client端即是指应用程序。这两个本地的InputChannel是通过InputChannel::openInputChannelPair函数创建的，创建完成后，再相应地在Java层创建相应的两个InputChannel，然后返回。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 14.&nbsp;InputChannel.openInputChannelPair<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputTransport.cpp文件中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 33998px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_49" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_49" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=49&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputChannel::openInputChannelPair(</span><span class="keyword">const</span><span>&nbsp;String8&amp;&nbsp;name,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;InputChannel&gt;&amp;&nbsp;outServerChannel,&nbsp;sp&lt;InputChannel&gt;&amp;&nbsp;outClientChannel)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;result;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;serverAshmemFd&nbsp;=&nbsp;ashmem_create_region(name.string(),&nbsp;DEFAULT_MESSAGE_BUFFER_SIZE);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(serverAshmemFd&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;ashmem_set_prot_region(serverAshmemFd,&nbsp;PROT_READ&nbsp;|&nbsp;PROT_WRITE);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Dup&nbsp;the&nbsp;file&nbsp;descriptor&nbsp;because&nbsp;the&nbsp;server&nbsp;and&nbsp;client&nbsp;input&nbsp;channel&nbsp;objects&nbsp;that</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;are&nbsp;returned&nbsp;may&nbsp;have&nbsp;different&nbsp;lifetimes&nbsp;but&nbsp;they&nbsp;share&nbsp;the&nbsp;same&nbsp;shared&nbsp;memory&nbsp;region.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;clientAshmemFd;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientAshmemFd&nbsp;=&nbsp;dup(serverAshmemFd);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(clientAshmemFd&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;forward[2];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(pipe(forward))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;reverse[2];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(pipe(reverse))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String8&nbsp;serverChannelName&nbsp;=&nbsp;name;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverChannelName.append(<span class="string">"&nbsp;(server)"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outServerChannel&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputChannel(serverChannelName,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverAshmemFd,&nbsp;reverse[0],&nbsp;forward[1]);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String8&nbsp;clientChannelName&nbsp;=&nbsp;name;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientChannelName.append(<span class="string">"&nbsp;(client)"</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outClientChannel&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputChannel(clientChannelName,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientAshmemFd,&nbsp;forward[0],&nbsp;reverse[1]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_49_5692782" name="code" class="cpp" style="display: none;">status_t InputChannel::openInputChannelPair(const String8&amp; name,
		sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) {
	status_t result;

	int serverAshmemFd = ashmem_create_region(name.string(), DEFAULT_MESSAGE_BUFFER_SIZE);
	if (serverAshmemFd &lt; 0) {
		......
	} else {
		result = ashmem_set_prot_region(serverAshmemFd, PROT_READ | PROT_WRITE);
		if (result &lt; 0) {
			......
		} else {
			// Dup the file descriptor because the server and client input channel objects that
			// are returned may have different lifetimes but they share the same shared memory region.
			int clientAshmemFd;
			clientAshmemFd = dup(serverAshmemFd);
			if (clientAshmemFd &lt; 0) {
				......
			} else {
				int forward[2];
				if (pipe(forward)) {
					......
				} else {
					int reverse[2];
					if (pipe(reverse)) {
						......
					} else {
						String8 serverChannelName = name;
						serverChannelName.append(" (server)");
						outServerChannel = new InputChannel(serverChannelName,
							serverAshmemFd, reverse[0], forward[1]);

						String8 clientChannelName = name;
						clientChannelName.append(" (client)");
						outClientChannel = new InputChannel(clientChannelName,
							clientAshmemFd, forward[0], reverse[1]);
						return OK;
					}
					......
				}
				......
			}
		}
	}
	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在阅读这个函数之前，我们首先了解一下C++层的InputChannel的构造函数：<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 34958px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_50" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_50" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=50&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>InputChannel::InputChannel(</span><span class="keyword">const</span><span>&nbsp;String8&amp;&nbsp;name,&nbsp;int32_t&nbsp;ashmemFd,&nbsp;int32_t&nbsp;receivePipeFd,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;sendPipeFd)&nbsp;:&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mName(name),&nbsp;mAshmemFd(ashmemFd),&nbsp;mReceivePipeFd(receivePipeFd),&nbsp;mSendPipeFd(sendPipeFd)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_50_5834486" name="code" class="cpp" style="display: none;">InputChannel::InputChannel(const String8&amp; name, int32_t ashmemFd, int32_t receivePipeFd,
	int32_t sendPipeFd) :
	mName(name), mAshmemFd(ashmemFd), mReceivePipeFd(receivePipeFd), mSendPipeFd(sendPipeFd) {
	......
} </pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;为了创建一个InputChannel，我们需要准备四个参数，一个是输入通道的名称name，一个是<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6651971">匿名共享内存</a>文件描述符，一个是管道的读端文件描述符，一个是管道的写端文件描述符。在上面的openInputChannelPair函数，输入通道的名称已经作为参数传递进来，因此，还需要创建匿名共享内存文件，还有管道。这里需要创建两个管道，一个称为前向管道（forward pipe），一个称为反向管道（reverse pipe），它们交叉使用在Server端和Client端的InputChannel中，这样就使入Server和Client可以互相通信了。<p></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;具体来说，Server端和Client端的InputChannel分别是这样构成的：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>Server Input Channel: &nbsp;<em>ashmem - reverse(read) - forward(write)</em></strong></p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"><strong>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Client Input Channel: &nbsp;&nbsp;<em>ashmem - forward(read) - reverse(write)</em></strong><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面我们在<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序消息处理机制（Looper、Handler）分析</a>一文中学习Android应用程序的消息处理机制时知道，管道可以用作进程间通信，其中一个进程在管道的读端等待新的内空可读，另一个进程在管道的写端写入新的内容以唤醒在管道读端等待的进程，这样就实现了进程间通信。在我们这个情景中，Client端可以在前向管道（forward pipe）的读端睡眠等待新的内容可读，而Server端可以通过向前向管道（forward pipe）的写端写入新的内容来唤醒Client端，同样，把前向管道（forward pipe）换成反向管道（reverse pipe），也能实现Client端唤醒Server端。在后面我们分析InputDispatcher分发键盘消息时，会看到它们的用法。</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;有了这些背景知识后，相信上面的openInputChannelPair的代码就容易理解了，这里就不再详述了。</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;创建好了这两个输入通道后，回到Step 11中的WindowManagerService.addWindow函数中，一方面它把刚才创建的Client端的输入通道通过outInputChannel参数返回到应用程序中：</p><p align="left" style="margin-top:4px; margin-right:0px; margin-bottom:4px; margin-left:0px; padding-top:2px; padding-right:0px; padding-bottom:2px; padding-left:0px"></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 35636px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_51" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_51" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=51&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>inputChannels[</span><span class="number">1</span><span>].transferToBinderOutParameter(outInputChannel);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_51_8168800" name="code" class="java" style="margin: 4px 0px; display: none; background-color: rgb(240, 240, 240);">inputChannels[1].transferToBinderOutParameter(outInputChannel);</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 另一方面，它还要把刚才创建的Server端的输入通道注册到InputManager中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 35753px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_52" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_52" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=52&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>mInputManager.registerInputChannel(win.mInputChannel);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_52_3327014" name="code" class="java" style="display: none;">mInputManager.registerInputChannel(win.mInputChannel);</pre>&nbsp;&nbsp; &nbsp; &nbsp; Step 15. InputManager.registerInputChannel<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/services/java/com/android/server/InputManager.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 35910px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_53" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_53" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=53&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputManager&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/**</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Registers&nbsp;an&nbsp;input&nbsp;channel&nbsp;so&nbsp;that&nbsp;it&nbsp;can&nbsp;be&nbsp;used&nbsp;as&nbsp;an&nbsp;input&nbsp;event&nbsp;target.</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;inputChannel&nbsp;The&nbsp;input&nbsp;channel&nbsp;to&nbsp;register.</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;registerInputChannel(InputChannel&nbsp;inputChannel)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(inputChannel&nbsp;==&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span><span>&nbsp;</span><span class="keyword">new</span><span>&nbsp;IllegalArgumentException(</span><span class="string">"inputChannel&nbsp;must&nbsp;not&nbsp;be&nbsp;null."</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nativeRegisterInputChannel(inputChannel,&nbsp;<span class="keyword">false</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_53_4864158" name="code" class="java" style="display: none;">public class InputManager {
	......

	/**
	* Registers an input channel so that it can be used as an input event target.
	* @param inputChannel The input channel to register.
	*/
	public void registerInputChannel(InputChannel inputChannel) {
		if (inputChannel == null) {
			throw new IllegalArgumentException("inputChannel must not be null.");
		}

		nativeRegisterInputChannel(inputChannel, false);
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 它通过调用本地方法nativeRegisterInputChannel来执行进一步的操作。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 16.&nbsp;InputManager.nativeRegisterInputChannel</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/services/jni/com_android_server_InputManager.cpp 文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 36395px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_54" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_54" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=54&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;android_server_InputManager_nativeRegisterInputChannel(JNIEnv*&nbsp;env,&nbsp;jclass&nbsp;clazz,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;inputChannelObj,&nbsp;jboolean&nbsp;monitor)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;InputChannel&gt;&nbsp;inputChannel&nbsp;=&nbsp;android_view_InputChannel_getInputChannel(env,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannelObj);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;gNativeInputManager-&gt;registerInputChannel(&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env,&nbsp;inputChannel,&nbsp;inputChannelObj,&nbsp;monitor);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_54_8593911" name="code" class="cpp" style="display: none;">static void android_server_InputManager_nativeRegisterInputChannel(JNIEnv* env, jclass clazz,
		jobject inputChannelObj, jboolean monitor) {
	......

	sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,
	   inputChannelObj);
	......

	status_t status = gNativeInputManager-&gt;registerInputChannel(
	   env, inputChannel, inputChannelObj, monitor);
	
	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里首先通过Java层的InputChannel对象获得C++层的InputChannel对象，它们之间的对应关系是在前面的Step 13中设置好的，接着调用NativeInputManager的registerInputChannel执行进一步的操作。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 17. NativeInputManager.registerInputChannel</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/jni/com_android_server_InputManager.cpp 文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 36849px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_55" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_55" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=55&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;NativeInputManager::registerInputChannel(JNIEnv*&nbsp;env,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;sp&lt;InputChannel&gt;&amp;&nbsp;inputChannel,&nbsp;jobject&nbsp;inputChannelObj,&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;monitor)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(inputChannel,&nbsp;monitor);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_55_8943358" name="code" class="cpp" style="display: none;">status_t NativeInputManager::registerInputChannel(JNIEnv* env,
		const sp&lt;InputChannel&gt;&amp; inputChannel, jobject inputChannelObj, bool monitor) {
	......

	status = mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(inputChannel, monitor);
	
	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数主要是调用了InputDispatcher的registerInputChannel来真正执行注册输入通道的操作。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 18.&nbsp;InputDispatcher.registerInputChannel<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 37176px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_56" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_56" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=56&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputDispatcher::registerInputChannel(</span><span class="keyword">const</span><span>&nbsp;sp&lt;InputChannel&gt;&amp;&nbsp;inputChannel,&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;monitor)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(getConnectionIndexLocked(inputChannel)&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGW(<span class="string">"Attempted&nbsp;to&nbsp;register&nbsp;already&nbsp;registered&nbsp;input&nbsp;channel&nbsp;'%s'"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannel-&gt;getName().string());&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;BAD_VALUE;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Connection(inputChannel);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;connection-&gt;initialize();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(status)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"Failed&nbsp;to&nbsp;initialize&nbsp;input&nbsp;publisher&nbsp;for&nbsp;input&nbsp;channel&nbsp;'%s',&nbsp;status=%d"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannel-&gt;getName().string(),&nbsp;status);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;status;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;receiveFd&nbsp;=&nbsp;inputChannel-&gt;getReceivePipeFd();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mConnectionsByReceiveFd.add(receiveFd,&nbsp;connection);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(monitor)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMonitoringChannels.push(inputChannel);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mLooper-&gt;addFd(receiveFd,&nbsp;0,&nbsp;ALOOPER_EVENT_INPUT,&nbsp;handleReceiveCallback,&nbsp;<span class="keyword">this</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runCommandsLockedInterruptible();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_56_8528655" name="code" class="cpp" style="display: none;">status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel, bool monitor) {
	......

	{ // acquire lock
		AutoMutex _l(mLock);

		if (getConnectionIndexLocked(inputChannel) &gt;= 0) {
			LOGW("Attempted to register already registered input channel '%s'",
				inputChannel-&gt;getName().string());
			return BAD_VALUE;
		}

		sp&lt;Connection&gt; connection = new Connection(inputChannel);
		status_t status = connection-&gt;initialize();
		if (status) {
			LOGE("Failed to initialize input publisher for input channel '%s', status=%d",
				inputChannel-&gt;getName().string(), status);
			return status;
		}

		int32_t receiveFd = inputChannel-&gt;getReceivePipeFd();
		mConnectionsByReceiveFd.add(receiveFd, connection);

		if (monitor) {
			mMonitoringChannels.push(inputChannel);
		}

		mLooper-&gt;addFd(receiveFd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);

		runCommandsLockedInterruptible();
	} // release lock
	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先会通过getConnectionIndexLocked检查从参数传进来的InputChannel是否已经注册过了，如果已经注册过了，就返回一个BAD_VALUE值了，否则的话，就会创建一个Connection对象来封装即将要注册的inputChannel，我们可以不关心这个Connection对象的实现，接着还通过调用inputChannel-&gt;getReceivePipeFd获得一个管<br>道的读端描述符。回忆一下Step 14中的InputChannel.openInputChannelPair函数，我们创建了一个Server端的InputChannel，就是对应这里的inputChannel了，这个inputChannel的Receive Pipe Fd就是我们前面说的反向管道的读端描述符了。有了这个Receive Pipe Fd后，就以它作为Key值来把前面创建的Connection对象保存在InputDispatcher中，这样就基本完成键盘消息接收通道的注册了。但是，注册的工作还未完成，最后，还要把这个Receive Pipe Fd添加到InputDispatcher的成员变量mLooper中去，这里的成员变量mLooper的类型为Looper，我们在前面介绍InputManager的启动过程的Step 15中已经见过了，这里就不再详述了，不过这里仍然值得介绍一下它的addFd函数。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面一篇文章<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序消息处理机制（Looper、Handler）分析</a>中，我们在介绍到Android应用程序的消息循环一节时，曾经说过，在Looper类内部，会创建一个管道，然后Looper会睡眠在这个管道的读端，等待另外一个线程来往这个管道的写端写入新的内容，从而唤醒等待在这个管道读端的线程，除此之外，Looper还可以同时睡眠等待在其它的文件描述符上，因为它是通过Linux系统的epoll机制来批量等待指定的文件有新的内容可读的。这些其它的文件描述符就是通过Looper类的addFd成函数添加进去的了，在添加的时候，还可以指定回调函数，即当这个文件描述符所指向的文件有新的内容可读时，Looper就会调用这个hanldeReceiveCallback函数，有兴趣的读者可以自己研究一下Looper类的addFd函数的实现，它位于frameworks/base/libs/utils/Looper.cpp文件中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;分析到这里，Server端的InputChannel就注册完成了。回忆一下前面介绍InputManager启动过程的Step 14，这时InputDispatcherThread同时睡眠在InputDispatcher的成员变量mLooper内部的管道的读端以及这里的Server端InputChannel里面的反向管道的读端上，mLooper内部的管道的读端等待键盘事件的发生而被唤醒，而Server端InputChannel里面的反向管道的读端等待Client端InputChannel里面的反向管道的写端被写入新的内容而被唤醒。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Server端的InputChannel注册完成后，回到Step 11中的WindowManagerService.addWindow函数，接下来就是把Client端的InputChannel转换成addWindow的参数outInputChannel中，然后返回到Step 1中的ViewRoot.setView函数中，继续执行Client端的InputChannel的注册过程，即为应用程序这一侧注册键盘消息接收通道：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 38594px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_57" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_57" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=57&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(view&nbsp;</span><span class="keyword">instanceof</span><span>&nbsp;RootViewSurfaceTaker)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mInputQueueCallback&nbsp;=&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(mInputQueueCallback&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mInputQueue&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;InputQueue(mInputChannel);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mInputQueueCallback.onInputQueueCreated(mInputQueue);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;InputQueue.registerInputChannel(mInputChannel,&nbsp;mInputHandler,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Looper.myQueue());&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_57_306562" name="code" class="java" style="display: none;">if (view instanceof RootViewSurfaceTaker) {
	mInputQueueCallback =
		((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();
}
if (mInputQueueCallback != null) {
	mInputQueue = new InputQueue(mInputChannel);
	mInputQueueCallback.onInputQueueCreated(mInputQueue);
} else {
	InputQueue.registerInputChannel(mInputChannel, mInputHandler,
		Looper.myQueue());
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的变量view一般不为RootViewSurfaceTaker的实例，因此，最后会执行下面语句：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 38891px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_58" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_58" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=58&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>InputQueue.registerInputChannel(mInputChannel,&nbsp;mInputHandler,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;Looper.myQueue());&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_102_2896282" name="code" class="java" style="display: none;">InputQueue.registerInputChannel(mInputChannel, mInputHandler,
	Looper.myQueue());</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;它调用InputQueue的registerInputChannel函数为应用程序注册键盘消息接收通道，这里的mInputChannel即为我们在前面Step 14中创建的Client端的InputChannel；Looper.myQueue函数返回的便是应用程序主线程的消息队列，具体可以参考前面一篇文章<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序消息处理机制（Looper、Handler）分析</a>；参数mInputHandler是一个回调对象，当有键盘事件发生时，这个mInputHandler的handleKey函数就会被调用，在后面的分析中，我们将会看到。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 19. InputQueue.registerInputChannel</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/InputQueue.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 39210px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_59" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_59" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=59&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputQueue&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;registerInputChannel(InputChannel&nbsp;inputChannel,&nbsp;InputHandler&nbsp;inputHandler,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageQueue&nbsp;messageQueue)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(sLock)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nativeRegisterInputChannel(inputChannel,&nbsp;inputHandler,&nbsp;messageQueue);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_59_6129867" name="code" class="java" style="display: none;">public final class InputQueue {
	......

	public static void registerInputChannel(InputChannel inputChannel, InputHandler inputHandler,
			MessageQueue messageQueue) {
		......

		synchronized (sLock) {
			......

			nativeRegisterInputChannel(inputChannel, inputHandler, messageQueue);
		}
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数调用本地方法nativeRegisterInputChannel函数来执行进一步的操作。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 20.&nbsp;InputQueue.nativeRegisterInputChannel</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/core/jni/android_view_InputQueue.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 39692px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_60" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_60" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=60&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;android_view_InputQueue_nativeRegisterInputChannel(JNIEnv*&nbsp;env,&nbsp;jclass&nbsp;clazz,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;inputChannelObj,&nbsp;jobject&nbsp;inputHandlerObj,&nbsp;jobject&nbsp;messageQueueObj)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;gNativeInputQueue.registerInputChannel(&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env,&nbsp;inputChannelObj,&nbsp;inputHandlerObj,&nbsp;messageQueueObj);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_60_9859621" name="code" class="cpp" style="display: none;">static void android_view_InputQueue_nativeRegisterInputChannel(JNIEnv* env, jclass clazz,
		jobject inputChannelObj, jobject inputHandlerObj, jobject messageQueueObj) {
	status_t status = gNativeInputQueue.registerInputChannel(
	   env, inputChannelObj, inputHandlerObj, messageQueueObj);

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里继续调用NativeInputQueue的registerInputChannel函数来执行真正的键盘消息接收通道的工作。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 21. NativeInputQueue.registerInputChannel</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/jni/android_view_InputQueue.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 40012px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_61" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_61" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=61&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;NativeInputQueue::registerInputChannel(JNIEnv*&nbsp;env,&nbsp;jobject&nbsp;inputChannelObj,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;inputHandlerObj,&nbsp;jobject&nbsp;messageQueueObj)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;InputChannel&gt;&nbsp;inputChannel&nbsp;=&nbsp;android_view_InputChannel_getInputChannel(env,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannelObj);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Looper&gt;&nbsp;looper&nbsp;=&nbsp;android_os_MessageQueue_getLooper(env,&nbsp;messageQueueObj);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(getConnectionIndex(inputChannel)&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGW(<span class="string">"Attempted&nbsp;to&nbsp;register&nbsp;already&nbsp;registered&nbsp;input&nbsp;channel&nbsp;'%s'"</span><span>,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannel-&gt;getName().string());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;BAD_VALUE;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint16_t&nbsp;connectionId&nbsp;=&nbsp;mNextConnectionId++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Connection(connectionId,&nbsp;inputChannel,&nbsp;looper);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;result&nbsp;=&nbsp;connection-&gt;inputConsumer.initialize();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGW(<span class="string">"Failed&nbsp;to&nbsp;initialize&nbsp;input&nbsp;consumer&nbsp;for&nbsp;input&nbsp;channel&nbsp;'%s',&nbsp;status=%d"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannel-&gt;getName().string(),&nbsp;result);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;result;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection-&gt;inputHandlerObjGlobal&nbsp;=&nbsp;env-&gt;NewGlobalRef(inputHandlerObj);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;receiveFd&nbsp;=&nbsp;inputChannel-&gt;getReceivePipeFd();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mConnectionsByReceiveFd.add(receiveFd,&nbsp;connection);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;looper-&gt;addFd(receiveFd,&nbsp;0,&nbsp;ALOOPER_EVENT_INPUT,&nbsp;handleReceiveCallback,&nbsp;<span class="keyword">this</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_61_7177425" name="code" class="cpp" style="display: none;">status_t NativeInputQueue::registerInputChannel(JNIEnv* env, jobject inputChannelObj,
		jobject inputHandlerObj, jobject messageQueueObj) {
	sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,
		inputChannelObj);
	......

	sp&lt;Looper&gt; looper = android_os_MessageQueue_getLooper(env, messageQueueObj);

	{ // acquire lock
		AutoMutex _l(mLock);

		if (getConnectionIndex(inputChannel) &gt;= 0) {
			LOGW("Attempted to register already registered input channel '%s'",
				inputChannel-&gt;getName().string());
			return BAD_VALUE;
		}

		uint16_t connectionId = mNextConnectionId++;
		sp&lt;Connection&gt; connection = new Connection(connectionId, inputChannel, looper);
		status_t result = connection-&gt;inputConsumer.initialize();
		if (result) {
			LOGW("Failed to initialize input consumer for input channel '%s', status=%d",
				inputChannel-&gt;getName().string(), result);
			return result;
		}

		connection-&gt;inputHandlerObjGlobal = env-&gt;NewGlobalRef(inputHandlerObj);

		int32_t receiveFd = inputChannel-&gt;getReceivePipeFd();
		mConnectionsByReceiveFd.add(receiveFd, connection);

		looper-&gt;addFd(receiveFd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);
	} // release lock

	......
	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里注册应用程序的InputChannel的逻辑和前面介绍的Step 18中在InputDispatcher中注册Server端的InputChannel是一样的，所不同的是，这里用的looper是应用程序主线程中的消息循环对象Looper，而添加到这个looper对象中的Receive Pipe Fd是前面在Step 14中创建的前向管道的读端文件描述符，而使用的回调函数是NativeInputQueue的成员函数handleReceiveCallback。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;介绍到这里，应用程序注册键盘消息接收通道的过程就分析完成了。这个过程比较复杂，这里小结一下：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;A. 即将会被激活的Activity窗口，会通知InputManager，它是当前激活的窗口，因此，一旦发生键盘事件的时候，InputManager就把这个键盘事件抛给这个Activity处理；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;B. 应用程序会为这个Activity窗口和InputManager之间创建一个键盘消息接收通道，这个通道的一端由一个Server端的InputChannel构成，另一端由Client端的InputChannel构成，Server端的InputChannel注册在由InputManager所管理的InputDispatcher中，而Client端的InputChannel注册在由应用程序主线程的消息循环对象Looper中；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;C. 注册在InputDispatcher中的InputChannel由一个反向管道的读端和一个前向管道的写端组成，而注册在应用程序主线程的消息循环对象Looper中的InputChannel由这个前向管道的读端和反向管道的写端组成，这种交叉结构使得当有键盘事件发生时，InputDispatcher可以把这个事件通知给应用程序。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;应用程序注册好键盘消息接收通道后，接下来就开始分析InputManager分发键盘消息给应用程序的过程了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3.&nbsp;InputManager分发键盘消息给应用程序的过程分析</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在分析InputManager分发键盘消息给应用程序的过程之前，我们先假设现在没有键盘事件发生，因此，InputManager中的InputReader正在睡眠等待键盘事件的发生，而InputManager中的InputDispatcher正在等待InputReader从睡眠中醒过来并且唤醒它，而应用程序也正在消息循环中等待InputDispatcher从睡眠中醒过来并且唤醒它。这时候，用户按下键盘中的一个键，于是，一系列唤醒的事件就依次发生了，一直到应用程序中正在显示的Activity得到通知，有键盘事件发生了。我们先来看这个过程的序列图，然后再详细分析每一个步骤：</p><p><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/0_1319372816yZZx.gif" alt=""><br></p><p style="text-align: center;"><a target="_blank" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/0_1319372816yZZx.gif">点击查看大图</a></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. InputReader.pollOnce</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2. EventHub.getEvent</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这两个函数分别定义在frameworks/base/libs/ui/InputReader.cpp和frameworks/base/libs/ui/EventHub.cpp文件中，前面我们在分析InputManager的启动过程的Step 17和Step 18时，已经看到过这两个函数了。InputReaderThread线程会不民地循环调用InputReader.pollOnce函数来读入键盘事件，而实际的键盘事件读入操作是由EventHub.getEvent函数来进行的。如果当前没有键盘事件发生，InputReaderThread线程就会睡眠在EventHub.getEvent函数上，而当键盘事件发生后，就会把这个事件封装成一个RawEvent对象，然后返回到pollOnce函数中，执行process函数进一步处理：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 42482px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_62" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_62" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=62&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputReader::loopOnce()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;RawEvent&nbsp;rawEvent;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mEventHub-&gt;getEvent(&amp;&nbsp;rawEvent);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;process(&amp;&nbsp;rawEvent);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_62_6762722" name="code" class="cpp" style="display: none;">void InputReader::loopOnce() {
	RawEvent rawEvent;
	mEventHub-&gt;getEvent(&amp; rawEvent);

	......

	process(&amp; rawEvent);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3. InputReader.process<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputReader.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 42765px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_63" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_63" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=63&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputReader::process(</span><span class="keyword">const</span><span>&nbsp;RawEvent*&nbsp;rawEvent)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(rawEvent-&gt;type)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;EventHubInterface::DEVICE_ADDED:&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addDevice(rawEvent-&gt;deviceId);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;EventHubInterface::DEVICE_REMOVED:&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removeDevice(rawEvent-&gt;deviceId);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;EventHubInterface::FINISHED_DEVICE_SCAN:&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handleConfigurationChanged(rawEvent-&gt;when);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">default</span><span>:&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumeEvent(rawEvent);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_63_7668576" name="code" class="cpp" style="display: none;">void InputReader::process(const RawEvent* rawEvent) {
	switch (rawEvent-&gt;type) {
	case EventHubInterface::DEVICE_ADDED:
		addDevice(rawEvent-&gt;deviceId);
		break;

	case EventHubInterface::DEVICE_REMOVED:
		removeDevice(rawEvent-&gt;deviceId);
		break;

	case EventHubInterface::FINISHED_DEVICE_SCAN:
		handleConfigurationChanged(rawEvent-&gt;when);
		break;

	default:
		consumeEvent(rawEvent);
		break;
	}
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当键盘事件发生时，rawEvent-&gt;type的值为EV_KEY，这是一个宏定义，具体可以参考bionic/libc/kernel/common/linux/input.h文件：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 43232px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_64" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_64" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=64&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="preprocessor">#define&nbsp;EV_KEY&nbsp;0x01</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_64_2826790" name="code" class="cpp" style="display: none;">#define EV_KEY 0x01</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;因此，接下来会调用consumeEvent函数进一步处理。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 4.&nbsp;InputReader.consumeEvent</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputReader.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 43429px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_65" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_65" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=65&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputReader::consumeEvent(</span><span class="keyword">const</span><span>&nbsp;RawEvent*&nbsp;rawEvent)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;deviceId&nbsp;=&nbsp;rawEvent-&gt;deviceId;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;device&nbsp;registry&nbsp;reader&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RWLock::AutoRLock&nbsp;_rl(mDeviceRegistryLock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;deviceIndex&nbsp;=&nbsp;mDevices.indexOfKey(deviceId);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(deviceIndex&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGW(<span class="string">"Discarding&nbsp;event&nbsp;for&nbsp;unknown&nbsp;deviceId&nbsp;%d."</span><span>,&nbsp;deviceId);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputDevice*&nbsp;device&nbsp;=&nbsp;mDevices.valueAt(deviceIndex);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(device-&gt;isIgnored())&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//LOGD("Discarding&nbsp;event&nbsp;for&nbsp;ignored&nbsp;deviceId&nbsp;%d.",&nbsp;deviceId);</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;process(rawEvent);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;device&nbsp;registry&nbsp;reader&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_65_1888699" name="code" class="cpp" style="display: none;">void InputReader::consumeEvent(const RawEvent* rawEvent) {
	int32_t deviceId = rawEvent-&gt;deviceId;

	{ // acquire device registry reader lock
		RWLock::AutoRLock _rl(mDeviceRegistryLock);

		ssize_t deviceIndex = mDevices.indexOfKey(deviceId);
		if (deviceIndex &lt; 0) {
			LOGW("Discarding event for unknown deviceId %d.", deviceId);
			return;
		}

		InputDevice* device = mDevices.valueAt(deviceIndex);
		if (device-&gt;isIgnored()) {
			//LOGD("Discarding event for ignored deviceId %d.", deviceId);
			return;
		}

		device-&gt;process(rawEvent);
	} // release device registry reader lock
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 首先从rawEvent中取得触发键盘事件设备对象device，然后调用它的process函数进行处理。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 5. InputDevice.process</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/libs/ui/InputReader.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 43986px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_66" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_66" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=66&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDevice::process(</span><span class="keyword">const</span><span>&nbsp;RawEvent*&nbsp;rawEvent)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">size_t</span><span>&nbsp;numMappers&nbsp;=&nbsp;mMappers.size();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">size_t</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;numMappers;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputMapper*&nbsp;mapper&nbsp;=&nbsp;mMappers[i];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapper-&gt;process(rawEvent);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_66_1158351" name="code" class="cpp" style="display: none;">void InputDevice::process(const RawEvent* rawEvent) {
    size_t numMappers = mMappers.size();
    for (size_t i = 0; i &lt; numMappers; i++) {
        InputMapper* mapper = mMappers[i];
        mapper-&gt;process(rawEvent);
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这里的mMapper成员变量保存了一系列输入设备事件处理象，例如负责处理键盘事件的KeyboardKeyMapper对象、负责处理轨迹球事件的TrackballInputMapper对象以及负责处理触摸屏事件的TouchInputMapper对象， 它们是在InputReader类的成员函数createDevice中创建的。这里查询每一个InputMapper对象是否要对当前发生的事件进行处理。由于发生的是键盘事件，真正会对该事件进行处理的只有KeyboardKeyMapper对象。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 6.&nbsp;KeyboardInputMapper.process</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/libs/ui/InputReader.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 44369px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_67" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_67" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=67&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;KeyboardInputMapper::process(</span><span class="keyword">const</span><span>&nbsp;RawEvent*&nbsp;rawEvent)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(rawEvent-&gt;type)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;EV_KEY:&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;scanCode&nbsp;=&nbsp;rawEvent-&gt;scanCode;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(isKeyboardOrGamepadKey(scanCode))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processKey(rawEvent-&gt;when,&nbsp;rawEvent-&gt;value&nbsp;!=&nbsp;0,&nbsp;rawEvent-&gt;keyCode,&nbsp;scanCode,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rawEvent-&gt;flags);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_67_1300055" name="code" class="cpp" style="display: none;">void KeyboardInputMapper::process(const RawEvent* rawEvent) {
    switch (rawEvent-&gt;type) {
    case EV_KEY: {
        int32_t scanCode = rawEvent-&gt;scanCode;
        if (isKeyboardOrGamepadKey(scanCode)) {
            processKey(rawEvent-&gt;when, rawEvent-&gt;value != 0, rawEvent-&gt;keyCode, scanCode,
                    rawEvent-&gt;flags);
        }
        break;
    }
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先会检查一下键盘扫描码是否正确，如果正确的话，就会调用processKey函数进一步处理。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 7.&nbsp;KeyboardInputMapper.processKey</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputReader.cpp文件中：<br></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 44782px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_68" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_68" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=68&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;KeyboardInputMapper::processKey(nsecs_t&nbsp;when,&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;down,&nbsp;int32_t&nbsp;keyCode,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;scanCode,&nbsp;uint32_t&nbsp;policyFlags)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;newMetaState;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;downTime;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">bool</span><span>&nbsp;metaStateChanged&nbsp;=&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(down)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Rotate&nbsp;key&nbsp;codes&nbsp;according&nbsp;to&nbsp;orientation&nbsp;if&nbsp;needed.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Note:&nbsp;getDisplayInfo&nbsp;is&nbsp;non-reentrant&nbsp;so&nbsp;we&nbsp;can&nbsp;continue&nbsp;holding&nbsp;the&nbsp;lock.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mAssociatedDisplayId&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;orientation;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;getPolicy()-&gt;getDisplayInfo(mAssociatedDisplayId,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;&nbsp;orientation))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyCode&nbsp;=&nbsp;rotateKeyCode(keyCode,&nbsp;orientation);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Add&nbsp;key&nbsp;down.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;keyDownIndex&nbsp;=&nbsp;findKeyDownLocked(scanCode);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(keyDownIndex&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;key&nbsp;repeat,&nbsp;be&nbsp;sure&nbsp;to&nbsp;use&nbsp;same&nbsp;keycode&nbsp;as&nbsp;before&nbsp;in&nbsp;case&nbsp;of&nbsp;rotation</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyCode&nbsp;=&nbsp;mLocked.keyDowns.itemAt(keyDownIndex).keyCode;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;key&nbsp;down</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;((policyFlags&nbsp;&amp;&nbsp;POLICY_FLAG_VIRTUAL)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;mContext-&gt;shouldDropVirtualKey(when,&nbsp;getDevice(),&nbsp;keyCode,&nbsp;scanCode))&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mLocked.keyDowns.push();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyDown&amp;&nbsp;keyDown&nbsp;=&nbsp;mLocked.keyDowns.editTop();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyDown.keyCode&nbsp;=&nbsp;keyCode;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyDown.scanCode&nbsp;=&nbsp;scanCode;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mLocked.downTime&nbsp;=&nbsp;when;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Remove&nbsp;key&nbsp;down.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;keyDownIndex&nbsp;=&nbsp;findKeyDownLocked(scanCode);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(keyDownIndex&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;key&nbsp;up,&nbsp;be&nbsp;sure&nbsp;to&nbsp;use&nbsp;same&nbsp;keycode&nbsp;as&nbsp;before&nbsp;in&nbsp;case&nbsp;of&nbsp;rotation</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyCode&nbsp;=&nbsp;mLocked.keyDowns.itemAt(keyDownIndex).keyCode;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mLocked.keyDowns.removeAt(<span class="datatypes">size_t</span><span>(keyDownIndex));&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;key&nbsp;was&nbsp;not&nbsp;actually&nbsp;down</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGI(<span class="string">"Dropping&nbsp;key&nbsp;up&nbsp;from&nbsp;device&nbsp;%s&nbsp;because&nbsp;the&nbsp;key&nbsp;was&nbsp;not&nbsp;down.&nbsp;&nbsp;"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"keyCode=%d,&nbsp;scanCode=%d"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getDeviceName().string(),&nbsp;keyCode,&nbsp;scanCode);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;oldMetaState&nbsp;=&nbsp;mLocked.metaState;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newMetaState&nbsp;=&nbsp;updateMetaState(keyCode,&nbsp;down,&nbsp;oldMetaState);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(oldMetaState&nbsp;!=&nbsp;newMetaState)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mLocked.metaState&nbsp;=&nbsp;newMetaState;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metaStateChanged&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;downTime&nbsp;=&nbsp;mLocked.downTime;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(metaStateChanged)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getContext()-&gt;updateGlobalMetaState();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;getDispatcher()-&gt;notifyKey(when,&nbsp;getDeviceId(),&nbsp;AINPUT_SOURCE_KEYBOARD,&nbsp;policyFlags,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;down&nbsp;?&nbsp;AKEY_EVENT_ACTION_DOWN&nbsp;:&nbsp;AKEY_EVENT_ACTION_UP,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AKEY_EVENT_FLAG_FROM_SYSTEM,&nbsp;keyCode,&nbsp;scanCode,&nbsp;newMetaState,&nbsp;downTime);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_68_8933503" name="code" class="cpp" style="display: none;">void KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t keyCode,
		int32_t scanCode, uint32_t policyFlags) {
	int32_t newMetaState;
	nsecs_t downTime;
	bool metaStateChanged = false;

	{ // acquire lock
	 AutoMutex _l(mLock);

	 if (down) {
		 // Rotate key codes according to orientation if needed.
		 // Note: getDisplayInfo is non-reentrant so we can continue holding the lock.
		 if (mAssociatedDisplayId &gt;= 0) {
			 int32_t orientation;
			 if (! getPolicy()-&gt;getDisplayInfo(mAssociatedDisplayId, NULL, NULL, &amp; orientation)) {
				 return;
			 }

			 keyCode = rotateKeyCode(keyCode, orientation);
		 }

		 // Add key down.
		 ssize_t keyDownIndex = findKeyDownLocked(scanCode);
		 if (keyDownIndex &gt;= 0) {
			 // key repeat, be sure to use same keycode as before in case of rotation
			 keyCode = mLocked.keyDowns.itemAt(keyDownIndex).keyCode;
		 } else {
			 // key down
			 if ((policyFlags &amp; POLICY_FLAG_VIRTUAL)
				 &amp;&amp; mContext-&gt;shouldDropVirtualKey(when, getDevice(), keyCode, scanCode)) {
					 return;
			 }
			 mLocked.keyDowns.push();
			 KeyDown&amp; keyDown = mLocked.keyDowns.editTop();
			 keyDown.keyCode = keyCode;
			 keyDown.scanCode = scanCode;
		 }

		 mLocked.downTime = when;
	 } else {
		 // Remove key down.
		 ssize_t keyDownIndex = findKeyDownLocked(scanCode);
		 if (keyDownIndex &gt;= 0) {
			 // key up, be sure to use same keycode as before in case of rotation
			 keyCode = mLocked.keyDowns.itemAt(keyDownIndex).keyCode;
			 mLocked.keyDowns.removeAt(size_t(keyDownIndex));
		 } else {
			 // key was not actually down
			 LOGI("Dropping key up from device %s because the key was not down.  "
				 "keyCode=%d, scanCode=%d",
				 getDeviceName().string(), keyCode, scanCode);
			 return;
		 }
	 }

	 int32_t oldMetaState = mLocked.metaState;
	 newMetaState = updateMetaState(keyCode, down, oldMetaState);
	 if (oldMetaState != newMetaState) {
		 mLocked.metaState = newMetaState;
		 metaStateChanged = true;
	 }

	 downTime = mLocked.downTime;
	} // release lock


	if (metaStateChanged) {
		getContext()-&gt;updateGlobalMetaState();
	}

	getDispatcher()-&gt;notifyKey(when, getDeviceId(), AINPUT_SOURCE_KEYBOARD, policyFlags,
		down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,
		AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先对对按键作一些处理，例如，当某一个DPAD键被按下时，根据当时屏幕方向的不同，它所表示的意义也不同，因此，这里需要根据当时屏幕的方向来调整键盘码：<br><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 46293px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_69" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_69" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=69&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;Rotate&nbsp;key&nbsp;codes&nbsp;according&nbsp;to&nbsp;orientation&nbsp;if&nbsp;needed.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;Note:&nbsp;getDisplayInfo&nbsp;is&nbsp;non-reentrant&nbsp;so&nbsp;we&nbsp;can&nbsp;continue&nbsp;holding&nbsp;the&nbsp;lock.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(mAssociatedDisplayId&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;orientation;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;getPolicy()-&gt;getDisplayInfo(mAssociatedDisplayId,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;&nbsp;orientation))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;keyCode&nbsp;=&nbsp;rotateKeyCode(keyCode,&nbsp;orientation);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_69_4091717" name="code" class="cpp" style="display: none;">// Rotate key codes according to orientation if needed.
// Note: getDisplayInfo is non-reentrant so we can continue holding the lock.
if (mAssociatedDisplayId &gt;= 0) {
	int32_t orientation;
	if (! getPolicy()-&gt;getDisplayInfo(mAssociatedDisplayId, NULL, NULL, &amp; orientation)) {
		return;
	}

	keyCode = rotateKeyCode(keyCode, orientation);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果这个键是一直按着不放的，不管屏幕的方向如何，必须保证后面的键盘码和前面的一样：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 46590px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_70" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_70" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=70&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;Add&nbsp;key&nbsp;down.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>ssize_t&nbsp;keyDownIndex&nbsp;=&nbsp;findKeyDownLocked(scanCode);&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(keyDownIndex&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;key&nbsp;repeat,&nbsp;be&nbsp;sure&nbsp;to&nbsp;use&nbsp;same&nbsp;keycode&nbsp;as&nbsp;before&nbsp;in&nbsp;case&nbsp;of&nbsp;rotation</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;keyCode&nbsp;=&nbsp;mLocked.keyDowns.itemAt(keyDownIndex).keyCode;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;key&nbsp;down</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;((policyFlags&nbsp;&amp;&nbsp;POLICY_FLAG_VIRTUAL)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;mContext-&gt;shouldDropVirtualKey(when,&nbsp;getDevice(),&nbsp;keyCode,&nbsp;scanCode))&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mLocked.keyDowns.push();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;KeyDown&amp;&nbsp;keyDown&nbsp;=&nbsp;mLocked.keyDowns.editTop();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;keyDown.keyCode&nbsp;=&nbsp;keyCode;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;keyDown.scanCode&nbsp;=&nbsp;scanCode;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_70_4997571" name="code" class="cpp" style="display: none;">// Add key down.
ssize_t keyDownIndex = findKeyDownLocked(scanCode);
if (keyDownIndex &gt;= 0) {
	// key repeat, be sure to use same keycode as before in case of rotation
	keyCode = mLocked.keyDowns.itemAt(keyDownIndex).keyCode;
} else {
	// key down
	if ((policyFlags &amp; POLICY_FLAG_VIRTUAL)
		&amp;&amp; mContext-&gt;shouldDropVirtualKey(when, getDevice(), keyCode, scanCode)) {
		 return;
	}
	mLocked.keyDowns.push();
	KeyDown&amp; keyDown = mLocked.keyDowns.editTop();
	keyDown.keyCode = keyCode;
	keyDown.scanCode = scanCode;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 如果是第一次按下某个键，还必须把它保存在mLocked.keyDowns里面，就是为了处理上面讲的当这个键盘一直按着不放的时候屏幕方向发生改变的情况。<br>&nbsp;&nbsp; &nbsp; &nbsp; 如果是松开键盘上的某个键，就把它从mLocked.keyDowns里面删除：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 47029px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_71" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_71" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=71&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;Remove&nbsp;key&nbsp;down.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>ssize_t&nbsp;keyDownIndex&nbsp;=&nbsp;findKeyDownLocked(scanCode);&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(keyDownIndex&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;key&nbsp;up,&nbsp;be&nbsp;sure&nbsp;to&nbsp;use&nbsp;same&nbsp;keycode&nbsp;as&nbsp;before&nbsp;in&nbsp;case&nbsp;of&nbsp;rotation</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;keyCode&nbsp;=&nbsp;mLocked.keyDowns.itemAt(keyDownIndex).keyCode;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mLocked.keyDowns.removeAt(<span class="datatypes">size_t</span><span>(keyDownIndex));&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;key&nbsp;was&nbsp;not&nbsp;actually&nbsp;down</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;LOGI(<span class="string">"Dropping&nbsp;key&nbsp;up&nbsp;from&nbsp;device&nbsp;%s&nbsp;because&nbsp;the&nbsp;key&nbsp;was&nbsp;not&nbsp;down.&nbsp;&nbsp;"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"keyCode=%d,&nbsp;scanCode=%d"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getDeviceName().string(),&nbsp;keyCode,&nbsp;scanCode);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_71_122766" name="code" class="cpp" style="display: none;">// Remove key down.
ssize_t keyDownIndex = findKeyDownLocked(scanCode);
if (keyDownIndex &gt;= 0) {
	// key up, be sure to use same keycode as before in case of rotation
	keyCode = mLocked.keyDowns.itemAt(keyDownIndex).keyCode;
	mLocked.keyDowns.removeAt(size_t(keyDownIndex));
} else {
	// key was not actually down
	LOGI("Dropping key up from device %s because the key was not down.  "
		"keyCode=%d, scanCode=%d",
		getDeviceName().string(), keyCode, scanCode);
	return;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当然，对键盘事件的这些处理不是本文的重点，本文的重点是分析从键盘事件到当前激活的Activity窗口接收到这个键盘消息的过程。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后，KeyboardInputMappger函数通知InputDispatcher，有键盘事件发生了：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 47428px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_72" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_72" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=72&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>getDispatcher()-&gt;notifyKey(when,&nbsp;getDeviceId(),&nbsp;AINPUT_SOURCE_KEYBOARD,&nbsp;policyFlags,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;down&nbsp;?&nbsp;AKEY_EVENT_ACTION_DOWN&nbsp;:&nbsp;AKEY_EVENT_ACTION_UP,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;AKEY_EVENT_FLAG_FROM_SYSTEM,&nbsp;keyCode,&nbsp;scanCode,&nbsp;newMetaState,&nbsp;downTime);&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_72_7756214" name="code" class="cpp" style="display: none;">getDispatcher()-&gt;notifyKey(when, getDeviceId(), AINPUT_SOURCE_KEYBOARD, policyFlags,
	down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,
	AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 8. InputDispatcher.notifyKey<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 47621px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_73" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_73" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=73&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::notifyKey(nsecs_t&nbsp;eventTime,&nbsp;int32_t&nbsp;deviceId,&nbsp;int32_t&nbsp;source,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;policyFlags,&nbsp;int32_t&nbsp;action,&nbsp;int32_t&nbsp;flags,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;keyCode,&nbsp;int32_t&nbsp;scanCode,&nbsp;int32_t&nbsp;metaState,&nbsp;nsecs_t&nbsp;downTime)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;validateKeyEvent(action))&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/*&nbsp;According&nbsp;to&nbsp;http://source.android.com/porting/keymaps_keyboard_input.html</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Key&nbsp;definitions:&nbsp;Key&nbsp;definitions&nbsp;follow&nbsp;the&nbsp;syntax&nbsp;key&nbsp;SCANCODE&nbsp;KEYCODE&nbsp;[FLAGS...],</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;where&nbsp;SCANCODE&nbsp;is&nbsp;a&nbsp;number,&nbsp;KEYCODE&nbsp;is&nbsp;defined&nbsp;in&nbsp;your&nbsp;specific&nbsp;keylayout&nbsp;file</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(android.keylayout.xxx),&nbsp;and&nbsp;potential&nbsp;FLAGS&nbsp;are&nbsp;defined&nbsp;as&nbsp;follows:</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHIFT:&nbsp;While&nbsp;pressed,&nbsp;the&nbsp;shift&nbsp;key&nbsp;modifier&nbsp;is&nbsp;set</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ALT:&nbsp;While&nbsp;pressed,&nbsp;the&nbsp;alt&nbsp;key&nbsp;modifier&nbsp;is&nbsp;set</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAPS:&nbsp;While&nbsp;pressed,&nbsp;the&nbsp;caps&nbsp;lock&nbsp;key&nbsp;modifier&nbsp;is&nbsp;set</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since&nbsp;KeyEvent.java&nbsp;doesn't&nbsp;check&nbsp;if&nbsp;Cap&nbsp;lock&nbsp;is&nbsp;ON&nbsp;and&nbsp;we&nbsp;don't&nbsp;have&nbsp;a</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modifer&nbsp;state&nbsp;for&nbsp;cap&nbsp;lock,&nbsp;we&nbsp;will&nbsp;not&nbsp;support&nbsp;it.</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(policyFlags&nbsp;&amp;&nbsp;POLICY_FLAG_ALT)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metaState&nbsp;|=&nbsp;AMETA_ALT_ON&nbsp;|&nbsp;AMETA_ALT_LEFT_ON;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(policyFlags&nbsp;&amp;&nbsp;POLICY_FLAG_ALT_GR)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metaState&nbsp;|=&nbsp;AMETA_ALT_ON&nbsp;|&nbsp;AMETA_ALT_RIGHT_ON;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(policyFlags&nbsp;&amp;&nbsp;POLICY_FLAG_SHIFT)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metaState&nbsp;|=&nbsp;AMETA_SHIFT_ON&nbsp;|&nbsp;AMETA_SHIFT_LEFT_ON;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;policyFlags&nbsp;|=&nbsp;POLICY_FLAG_TRUSTED;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mPolicy-&gt;interceptKeyBeforeQueueing(eventTime,&nbsp;deviceId,&nbsp;action,&nbsp;<span class="comment">/*byref*/</span><span>&nbsp;flags,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyCode,&nbsp;scanCode,&nbsp;<span class="comment">/*byref*/</span><span>&nbsp;policyFlags);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">bool</span><span>&nbsp;needWake;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;repeatCount&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyEntry*&nbsp;newEntry&nbsp;=&nbsp;mAllocator.obtainKeyEntry(eventTime,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deviceId,&nbsp;source,&nbsp;policyFlags,&nbsp;action,&nbsp;flags,&nbsp;keyCode,&nbsp;scanCode,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metaState,&nbsp;repeatCount,&nbsp;downTime);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needWake&nbsp;=&nbsp;enqueueInboundEventLocked(newEntry);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(needWake)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mLooper-&gt;wake();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_73_9534121" name="code" class="cpp" style="display: none;">void InputDispatcher::notifyKey(nsecs_t eventTime, int32_t deviceId, int32_t source,
	uint32_t policyFlags, int32_t action, int32_t flags,
	int32_t keyCode, int32_t scanCode, int32_t metaState, nsecs_t downTime) {
	......

	if (! validateKeyEvent(action)) {
		return;
	}

	/* According to http://source.android.com/porting/keymaps_keyboard_input.html
	* Key definitions: Key definitions follow the syntax key SCANCODE KEYCODE [FLAGS...],
	* where SCANCODE is a number, KEYCODE is defined in your specific keylayout file
	* (android.keylayout.xxx), and potential FLAGS are defined as follows:
	*     SHIFT: While pressed, the shift key modifier is set
	*     ALT: While pressed, the alt key modifier is set
	*     CAPS: While pressed, the caps lock key modifier is set
	*     Since KeyEvent.java doesn't check if Cap lock is ON and we don't have a
	*     modifer state for cap lock, we will not support it.
	*/
	if (policyFlags &amp; POLICY_FLAG_ALT) {
		metaState |= AMETA_ALT_ON | AMETA_ALT_LEFT_ON;
	}
	if (policyFlags &amp; POLICY_FLAG_ALT_GR) {
		metaState |= AMETA_ALT_ON | AMETA_ALT_RIGHT_ON;
	}
	if (policyFlags &amp; POLICY_FLAG_SHIFT) {
		metaState |= AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON;
	}

	policyFlags |= POLICY_FLAG_TRUSTED;
	mPolicy-&gt;interceptKeyBeforeQueueing(eventTime, deviceId, action, /*byref*/ flags,
		keyCode, scanCode, /*byref*/ policyFlags);

	bool needWake;
	{ // acquire lock
		AutoMutex _l(mLock);

		int32_t repeatCount = 0;
		KeyEntry* newEntry = mAllocator.obtainKeyEntry(eventTime,
			deviceId, source, policyFlags, action, flags, keyCode, scanCode,
			metaState, repeatCount, downTime);

		needWake = enqueueInboundEventLocked(newEntry);
	} // release lock

	if (needWake) {
		mLooper-&gt;wake();
	}
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数首先是调用validateKeyEvent函数来验证action参数是否正确：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 48617px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_74" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_74" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=74&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;isValidKeyAction(int32_t&nbsp;action)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(action)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;AKEY_EVENT_ACTION_DOWN:&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;AKEY_EVENT_ACTION_UP:&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">default</span><span>:&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;validateKeyEvent(int32_t&nbsp;action)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;isValidKeyAction(action))&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(<span class="string">"Key&nbsp;event&nbsp;has&nbsp;invalid&nbsp;action&nbsp;code&nbsp;0x%x"</span><span>,&nbsp;action);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_74_6851925" name="code" class="cpp" style="display: none;">static bool isValidKeyAction(int32_t action) {
    switch (action) {
    case AKEY_EVENT_ACTION_DOWN:
    case AKEY_EVENT_ACTION_UP:
        return true;
    default:
        return false;
    }
}

static bool validateKeyEvent(int32_t action) {
    if (! isValidKeyAction(action)) {
        LOGE("Key event has invalid action code 0x%x", action);
        return false;
    }
    return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;正确的action参数的值只能为AKEY_EVENT_ACTION_DOWN（按下）或者AKEY_EVENT_ACTION_UP（松开）。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数action检查通过后，还通过policyFlags参数来检查一下同时是否有ALT和SHIFT键被按下：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 49088px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_75" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_75" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=75&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(policyFlags&nbsp;&amp;&nbsp;POLICY_FLAG_ALT)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;metaState&nbsp;|=&nbsp;AMETA_ALT_ON&nbsp;|&nbsp;AMETA_ALT_LEFT_ON;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">if</span><span>&nbsp;(policyFlags&nbsp;&amp;&nbsp;POLICY_FLAG_ALT_GR)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;metaState&nbsp;|=&nbsp;AMETA_ALT_ON&nbsp;|&nbsp;AMETA_ALT_RIGHT_ON;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(policyFlags&nbsp;&amp;&nbsp;POLICY_FLAG_SHIFT)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;metaState&nbsp;|=&nbsp;AMETA_SHIFT_ON&nbsp;|&nbsp;AMETA_SHIFT_LEFT_ON;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_75_4834038" name="code" class="cpp" style="display: none;">if (policyFlags &amp; POLICY_FLAG_ALT) {
	metaState |= AMETA_ALT_ON | AMETA_ALT_LEFT_ON;
}
if (policyFlags &amp; POLICY_FLAG_ALT_GR) {
	metaState |= AMETA_ALT_ON | AMETA_ALT_RIGHT_ON;
}
if (policyFlags &amp; POLICY_FLAG_SHIFT) {
	metaState |= AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后，调用enqueueInboundEventLocked函数把这个按键事件封装成一个KeyEntry结构加入到InputDispatcher类的mInboundQueue队列中去：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 49375px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_76" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_76" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=76&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;InputDispatcher::enqueueInboundEventLocked(EventEntry*&nbsp;entry)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">bool</span><span>&nbsp;needWake&nbsp;=&nbsp;mInboundQueue.isEmpty();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mInboundQueue.enqueueAtTail(entry);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(entry-&gt;type)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;EventEntry::TYPE_KEY:&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyEntry*&nbsp;keyEntry&nbsp;=&nbsp;<span class="keyword">static_cast</span><span>&lt;KeyEntry*&gt;(entry);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(isAppSwitchKeyEventLocked(keyEntry))&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(keyEntry-&gt;action&nbsp;==&nbsp;AKEY_EVENT_ACTION_DOWN)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mAppSwitchSawKeyDown&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(keyEntry-&gt;action&nbsp;==&nbsp;AKEY_EVENT_ACTION_UP)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mAppSwitchSawKeyDown)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&lt;span&nbsp;style=<span class="string">"white-space:pre"</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mAppSwitchDueTime&nbsp;=&nbsp;keyEntry-&gt;eventTime&nbsp;+&nbsp;APP_SWITCH_TIMEOUT;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mAppSwitchSawKeyDown&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needWake&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;needWake;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_76_2151843" name="code" class="cpp" style="display: none;">bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) {
    bool needWake = mInboundQueue.isEmpty();
    mInboundQueue.enqueueAtTail(entry);

    switch (entry-&gt;type) {
    case EventEntry::TYPE_KEY: {
        KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(entry);
        if (isAppSwitchKeyEventLocked(keyEntry)) {
            if (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) {
                mAppSwitchSawKeyDown = true;
            } else if (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) {
                if (mAppSwitchSawKeyDown) {
<span style="white-space:pre">		</span>    ......
                    mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT;
                    mAppSwitchSawKeyDown = false;
                    needWake = true;
                }
            }
        }
        break;
    }
    }

    return needWake;
}
</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从这个函数我们可以看出，在两种情况下，它的返回值为true，一是当加入该键盘事件到mInboundQueue之前，mInboundQueue为空，这表示InputDispatccherThread线程正在睡眠等待InputReaderThread线程的唤醒，因此，它返回true表示要唤醒InputDispatccherThread线程；二是加入该键盘事件到mInboundQueue之前，mInboundQueue不为空，但是此时用户按下的是Home键，按下Home键表示要切换App，我们知道，在切换App时，新的App会把它的键盘消息接收通道注册到InputDispatcher中去，并且会等待InputReader的唤醒，因此，在这种情况下，也需要返回true，表示要唤醒InputDispatccherThread线程。如果不是这两种情况，那么就说明InputDispatccherThread线程现在正在处理前面的键盘事件，不需要唤醒它。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到前面的notifyKey函数中，根据enqueueInboundEventLocked函数的返回值来决定是否要唤醒InputDispatccherThread线程：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 50146px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_77" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_77" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=77&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(needWake)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mLooper-&gt;wake();&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_77_8705496" name="code" class="cpp" style="display: none;">if (needWake) {
	mLooper-&gt;wake();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里，假设needWake为true，于是，就会调用mLooper对象的wake函数来唤醒InputDispatccherThread线程了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 9. Looper.wake</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/utils/Looper.cpp文件中，在前面一篇文章<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序消息处理机制（Looper、Handler）分析</a>中，我们已经分析过这个函数了，这里不再详述，简单来说，它的作用就是用来唤醒睡眠在Looper对象内部的管道读端的线程，在我们的这个场景中，睡眠在Looper对象内部的管道读端的线程就是InputDispatccherThread线程了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从上面InputManager启动过程的Step 15中，我们知道，此时InputDispatccherThread线程正在InputDispatcher类的dispatchOnceb函数中通过调用mLooper-&gt;loopOnce函数进入睡眠状态。当它被唤醒以后，它就会从InputDispatcher类的dispatchOnceb函数返回到InputDispatcherThread类的threadLoop函数，而InputDispatcherThread类的threadLoop函数是循环执行的，于是，它又会再次进入到InputDispatcher类的dispatchOnce函数来处理当前发生的键盘事件。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 10.&nbsp;InputDispatcher.dispatchOnce</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 50707px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_78" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_78" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=78&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::dispatchOnce()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;keyRepeatTimeout&nbsp;=&nbsp;mPolicy-&gt;getKeyRepeatTimeout();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;keyRepeatDelay&nbsp;=&nbsp;mPolicy-&gt;getKeyRepeatDelay();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;nextWakeupTime&nbsp;=&nbsp;LONG_LONG_MAX;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatchOnceInnerLocked(keyRepeatTimeout,&nbsp;keyRepeatDelay,&nbsp;&amp;&nbsp;nextWakeupTime);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_78_3515046" name="code" class="cpp" style="display: none;">void InputDispatcher::dispatchOnce() {
	nsecs_t keyRepeatTimeout = mPolicy-&gt;getKeyRepeatTimeout();
	nsecs_t keyRepeatDelay = mPolicy-&gt;getKeyRepeatDelay();

	nsecs_t nextWakeupTime = LONG_LONG_MAX;
	{ // acquire lock
		AutoMutex _l(mLock);
		dispatchOnceInnerLocked(keyRepeatTimeout, keyRepeatDelay, &amp; nextWakeupTime);

		......
	} // release lock

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;它调用dispatchOnceInnerLocked函数来进一步处理这个键盘事件。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 11.&nbsp;InputDispatcher.dispatchOnceInnerLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 51142px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_79" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_79" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=79&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::dispatchOnceInnerLocked(nsecs_t&nbsp;keyRepeatTimeout,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;keyRepeatDelay,&nbsp;nsecs_t*&nbsp;nextWakeupTime)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Ready&nbsp;to&nbsp;start&nbsp;a&nbsp;new&nbsp;event.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;we&nbsp;don't&nbsp;already&nbsp;have&nbsp;a&nbsp;pending&nbsp;event,&nbsp;go&nbsp;grab&nbsp;one.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;mPendingEvent)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInboundQueue.isEmpty())&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Inbound&nbsp;queue&nbsp;has&nbsp;at&nbsp;least&nbsp;one&nbsp;entry.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventEntry*&nbsp;entry&nbsp;=&nbsp;mInboundQueue.headSentinel.next;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInboundQueue.dequeue(entry);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mPendingEvent&nbsp;=&nbsp;entry;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(mPendingEvent-&gt;type)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;EventEntry::TYPE_KEY:&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyEntry*&nbsp;typedEntry&nbsp;=&nbsp;<span class="keyword">static_cast</span><span>&lt;KeyEntry*&gt;(mPendingEvent);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done&nbsp;=&nbsp;dispatchKeyLocked(currentTime,&nbsp;typedEntry,&nbsp;keyRepeatTimeout,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dropReason,&nbsp;nextWakeupTime);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_79_9753054" name="code" class="cpp" style="display: none;">void InputDispatcher::dispatchOnceInnerLocked(nsecs_t keyRepeatTimeout,
	nsecs_t keyRepeatDelay, nsecs_t* nextWakeupTime) {
	......

	// Ready to start a new event.
	// If we don't already have a pending event, go grab one.
	if (! mPendingEvent) {
		if (mInboundQueue.isEmpty()) {
			......
		} else {
			// Inbound queue has at least one entry.
			EventEntry* entry = mInboundQueue.headSentinel.next;

			......

			mInboundQueue.dequeue(entry);
			mPendingEvent = entry;
		}

		......
	}

	......

	switch (mPendingEvent-&gt;type) {
	......

	case EventEntry::TYPE_KEY: {
		KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent);
		......
		done = dispatchKeyLocked(currentTime, typedEntry, keyRepeatTimeout,
			&amp;dropReason, nextWakeupTime);
		break;
							   }

	......
	}

	......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们忽略了这个函数的次要逻辑，主要关注键盘事件的主要处理流程。首先，如果前面发生的键盘事件都已经处理完毕，那么这里的mPendingEvent就为NULL，又因为前面我们把刚刚发生的键盘事件加入了mInboundQueue队列，因此，这里mInboundQueue不为NULL，于是，这里就把mInboundQueue队列中的键盘事件取出来，放在mPendingEvent变量中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 52039px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_80" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_80" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=80&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>mInboundQueue.dequeue(entry);&nbsp;&nbsp;</span></span></li><li class=""><span>mPendingEvent&nbsp;=&nbsp;entry;&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_80_7386503" name="code" class="cpp" style="display: none;">mInboundQueue.dequeue(entry);
mPendingEvent = entry;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;由于这里发生的是键盘事件，即mPendingEvent-&gt;type的值为EventEntry::TYPE_KEY，于是，在接下来的switch语句中就会执行dispatchKeyLocked函数来分发键盘消息。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 12.&nbsp;InputDispatcher.dispatchKeyLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 52292px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_81" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_81" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=81&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;InputDispatcher::dispatchKeyLocked(&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;currentTime,&nbsp;KeyEntry*&nbsp;entry,&nbsp;nsecs_t&nbsp;keyRepeatTimeout,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DropReason*&nbsp;dropReason,&nbsp;nsecs_t*&nbsp;nextWakeupTime)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Identify&nbsp;targets.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;mCurrentInputTargetsValid)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;injectionResult&nbsp;=&nbsp;findFocusedWindowTargetsLocked(currentTime,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry,&nbsp;nextWakeupTime);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Dispatch&nbsp;the&nbsp;key.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;dispatchEventToCurrentInputTargetsLocked(currentTime,&nbsp;entry,&nbsp;<span class="keyword">false</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_81_9164410" name="code" class="cpp" style="display: none;">bool InputDispatcher::dispatchKeyLocked(
		nsecs_t currentTime, KeyEntry* entry, nsecs_t keyRepeatTimeout,
		DropReason* dropReason, nsecs_t* nextWakeupTime) {
	......

	// Identify targets.
	if (! mCurrentInputTargetsValid) {
		int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime,
			entry, nextWakeupTime);

		......
	}

	// Dispatch the key.
	dispatchEventToCurrentInputTargetsLocked(currentTime, entry, false);
	return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; InputDispatcher类中的mCurrentInputTargetsValid成员变量表示InputDispatcher是否已经标志出谁是当前激活的Activity窗口，如果没有，就需要通过findFocusedWindowTargetsLocked函数来把它找出来。当把当前激活的Activity窗口找出来以后，接下来就调用dispatchEventToCurrentInputTargetsLocked函数把键盘事件分发给它了。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们先来看一InputDispatcher是如何找到当前激活的Activity窗口的，然后再分析它把键盘事件分发给当前激活Activity窗口的过程。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 13.&nbsp;InputDispatcher.findFocusedWindowTargetsLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 52895px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_82" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_82" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=82&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>int32_t&nbsp;InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t&nbsp;currentTime,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;EventEntry*&nbsp;entry,&nbsp;nsecs_t*&nbsp;nextWakeupTime)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mCurrentInputTargets.clear();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;injectionResult;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;there&nbsp;is&nbsp;no&nbsp;currently&nbsp;focused&nbsp;window&nbsp;and&nbsp;no&nbsp;focused&nbsp;application</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;then&nbsp;drop&nbsp;the&nbsp;event.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;mFocusedWindow)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mFocusedApplication)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;injectionResult&nbsp;=&nbsp;handleTargetsNotReadyLocked(currentTime,&nbsp;entry,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFocusedApplication,&nbsp;NULL,&nbsp;nextWakeupTime);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">goto</span><span>&nbsp;Unresponsive;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;injectionResult&nbsp;=&nbsp;INPUT_EVENT_INJECTION_FAILED;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">goto</span><span>&nbsp;Failed;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Check&nbsp;permissions.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;checkInjectionPermission(mFocusedWindow,&nbsp;entry-&gt;injectionState))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;injectionResult&nbsp;=&nbsp;INPUT_EVENT_INJECTION_PERMISSION_DENIED;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">goto</span><span>&nbsp;Failed;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;the&nbsp;currently&nbsp;focused&nbsp;window&nbsp;is&nbsp;paused&nbsp;then&nbsp;keep&nbsp;waiting.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mFocusedWindow-&gt;paused)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;injectionResult&nbsp;=&nbsp;handleTargetsNotReadyLocked(currentTime,&nbsp;entry,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFocusedApplication,&nbsp;mFocusedWindow,&nbsp;nextWakeupTime);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">goto</span><span>&nbsp;Unresponsive;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;the&nbsp;currently&nbsp;focused&nbsp;window&nbsp;is&nbsp;still&nbsp;working&nbsp;on&nbsp;previous&nbsp;events&nbsp;then&nbsp;keep&nbsp;waiting.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;isWindowFinishedWithPreviousInputLocked(mFocusedWindow))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;injectionResult&nbsp;=&nbsp;handleTargetsNotReadyLocked(currentTime,&nbsp;entry,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFocusedApplication,&nbsp;mFocusedWindow,&nbsp;nextWakeupTime);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">goto</span><span>&nbsp;Unresponsive;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Success!&nbsp;&nbsp;Output&nbsp;targets.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;injectionResult&nbsp;=&nbsp;INPUT_EVENT_INJECTION_SUCCEEDED;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;addWindowTargetLocked(mFocusedWindow,&nbsp;InputTarget::FLAG_FOREGROUND,&nbsp;BitSet32(0));&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;injectionResult;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_82_1257962" name="code" class="cpp" style="display: none;">int32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime,
		const EventEntry* entry, nsecs_t* nextWakeupTime) {
	mCurrentInputTargets.clear();

	int32_t injectionResult;

	// If there is no currently focused window and no focused application
	// then drop the event.
	if (! mFocusedWindow) {
		if (mFocusedApplication) {
			......
			injectionResult = handleTargetsNotReadyLocked(currentTime, entry,
				mFocusedApplication, NULL, nextWakeupTime);
			goto Unresponsive;
		}

		......
		injectionResult = INPUT_EVENT_INJECTION_FAILED;
		goto Failed;
	}

	// Check permissions.
	if (! checkInjectionPermission(mFocusedWindow, entry-&gt;injectionState)) {
		injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;
		goto Failed;
	}

	// If the currently focused window is paused then keep waiting.
	if (mFocusedWindow-&gt;paused) {
		......
		injectionResult = handleTargetsNotReadyLocked(currentTime, entry,
			mFocusedApplication, mFocusedWindow, nextWakeupTime);
		goto Unresponsive;
	}

	// If the currently focused window is still working on previous events then keep waiting.
	if (! isWindowFinishedWithPreviousInputLocked(mFocusedWindow)) {
		......
		injectionResult = handleTargetsNotReadyLocked(currentTime, entry,
			mFocusedApplication, mFocusedWindow, nextWakeupTime);
		goto Unresponsive;
	}

	// Success!  Output targets.
	injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;
	addWindowTargetLocked(mFocusedWindow, InputTarget::FLAG_FOREGROUND, BitSet32(0));

	......

	return injectionResult;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回忆前面我们分析应用程序注册键盘消息接收通道的过程时，在Step 9中，当前处于激活状态的应用程序会通过调用InputDispatcher类setInputWindows函数把把当前获得焦点的Activity窗口设置到mFocusedWindow中去，因此，这里的mFocusedWindow不为NULL，于是，就通过了第一个if语句的检查。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第二个if语句检查权限问题，原来，这个键盘事件除了是由硬件触发的外，也可以由其它进程注入进来的，如果这个键盘事件是由其它进程注入进来的，那么entry-&gt;injectState就不为NULL，它里面包含了事件注册者的进程ID和用户ID，于是，这里就会调用checkInjectionPermission来检查这个事件注入者的进程ID和用户ID，看看它是否具有这个权限。这里我们不考虑这种情况，因此，这里的entry-&gt;injectState为NULL，于是，这个if语句的检查也通过了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第三个if语句检查当前激活的Activity窗口是否是处于paused状态，如果是的话，也不用进一步处理了。一般情况下，当前激活的Activity窗口都是处于resumed状态的，于是，这个if语句的检查也通过了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第四个if语句检查当前激活的Activity窗口是否还正在处理前一个键盘事件，如果是的话，那就要等待它处理完前一个键盘事件后再来处理新的键盘事件了。这里我们也假设当前激活的Activity窗口不是正在处理前面的键盘事件，因此，这个if语句的检查也通过了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后，就调用addWindowTargetLocked函数把当前激活的Activity窗口添加到InputDispatcher类的mCurrentInputTargets成员变量中去。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 14.&nbsp;InputDispatcher.addWindowTargetLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 54401px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_83" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_83" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=83&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::addWindowTargetLocked(</span><span class="keyword">const</span><span>&nbsp;InputWindow*&nbsp;window,&nbsp;int32_t&nbsp;targetFlags,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitSet32&nbsp;pointerIds)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mCurrentInputTargets.push();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;InputTarget&amp;&nbsp;target&nbsp;=&nbsp;mCurrentInputTargets.editTop();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;target.inputChannel&nbsp;=&nbsp;window-&gt;inputChannel;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;target.flags&nbsp;=&nbsp;targetFlags;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;target.xOffset&nbsp;=&nbsp;-&nbsp;window-&gt;frameLeft;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;target.yOffset&nbsp;=&nbsp;-&nbsp;window-&gt;frameTop;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;target.pointerIds&nbsp;=&nbsp;pointerIds;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_83_4226" name="code" class="cpp" style="display: none;">void InputDispatcher::addWindowTargetLocked(const InputWindow* window, int32_t targetFlags,
        BitSet32 pointerIds) {
    mCurrentInputTargets.push();

    InputTarget&amp; target = mCurrentInputTargets.editTop();
    target.inputChannel = window-&gt;inputChannel;
    target.flags = targetFlags;
    target.xOffset = - window-&gt;frameLeft;
    target.yOffset = - window-&gt;frameTop;
    target.pointerIds = pointerIds;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数简单，就是把传进来的参数window添加到mCurrentInputTargets中去就完事了，后面InputDispatcher就会从mCurrentInputTargets中取出恰当的Activity窗口，然后把键盘事件分发给它。<p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到Step 12中的dispatchKeyLocked函数，它接下来就调用dispatchEventToCurrentInputTargetsLocked来进一步处理了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 15.&nbsp;InputDispatcher.dispatchEventToCurrentInputTargetsLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 54875px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_84" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_84" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=84&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::dispatchEventToCurrentInputTargetsLocked(nsecs_t&nbsp;currentTime,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventEntry*&nbsp;eventEntry,&nbsp;<span class="datatypes">bool</span><span>&nbsp;resumeWithAppendedMotionSample)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">size_t</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;mCurrentInputTargets.size();&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;InputTarget&amp;&nbsp;inputTarget&nbsp;=&nbsp;mCurrentInputTargets.itemAt(i);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;getConnectionIndexLocked(inputTarget.inputChannel);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(connectionIndex&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prepareDispatchCycleLocked(currentTime,&nbsp;connection,&nbsp;eventEntry,&nbsp;&amp;&nbsp;inputTarget,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resumeWithAppendedMotionSample);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_84_7637674" name="code" class="cpp" style="display: none;">void InputDispatcher::dispatchEventToCurrentInputTargetsLocked(nsecs_t currentTime,
		EventEntry* eventEntry, bool resumeWithAppendedMotionSample) {
   ......

   for (size_t i = 0; i &lt; mCurrentInputTargets.size(); i++) {
	   const InputTarget&amp; inputTarget = mCurrentInputTargets.itemAt(i);

	   ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);
	   if (connectionIndex &gt;= 0) {
		   sp&lt;Connection&gt; connection = mConnectionsByReceiveFd.valueAt(connectionIndex);
		   prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp; inputTarget,
			   resumeWithAppendedMotionSample);
	   } else {
		   ......
   }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数的实现也比较简单，前面我们已经把当前需要接受键盘事件的Activity窗口添加到mCurrentInputTargets中去了，因此，这里就分别把它们取出来，然后调用prepareDispatchCycleLocked函数把键盘事件分发给它们处理。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面我们在分析应用程序注册键盘消息接收通道的过程时，在Step 18中（InputDispatcher.registerInputChannel），把Server端的InputChannel封装成了一个Connection，然后以这个InputChannel中的Receive Pipe Fd作为键值把这个Connection对象保存在mConnectionsByReceiveFd中。这里，既然我们已经通过mCurrentInputTargets得到了表示当前需要接收键盘事件的Activity窗口的InputTarget对象，而且这个InputTarget对象的inputChannel就表示当初在InputDispatcher中注册的Server端InputChannel，因此，这里就可以把这个Connection对象取出来，最后调用prepareDispatchCycleLocked函数来进一步处理。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 16.&nbsp;InputDispatcher.prepareDispatchCycleLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 55579px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_85" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_85" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=85&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::prepareDispatchCycleLocked(nsecs_t&nbsp;currentTime,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;sp&lt;Connection&gt;&amp;&nbsp;connection,&nbsp;EventEntry*&nbsp;eventEntry,&nbsp;</span><span class="keyword">const</span><span>&nbsp;InputTarget*&nbsp;inputTarget,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">bool</span><span>&nbsp;resumeWithAppendedMotionSample)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Resume&nbsp;the&nbsp;dispatch&nbsp;cycle&nbsp;with&nbsp;a&nbsp;freshly&nbsp;appended&nbsp;motion&nbsp;sample.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;First&nbsp;we&nbsp;check&nbsp;that&nbsp;the&nbsp;last&nbsp;dispatch&nbsp;entry&nbsp;in&nbsp;the&nbsp;outbound&nbsp;queue&nbsp;is&nbsp;for&nbsp;the&nbsp;same</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;motion&nbsp;event&nbsp;to&nbsp;which&nbsp;we&nbsp;appended&nbsp;the&nbsp;motion&nbsp;sample.&nbsp;&nbsp;If&nbsp;we&nbsp;find&nbsp;such&nbsp;a&nbsp;dispatch</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;entry,&nbsp;and&nbsp;if&nbsp;it&nbsp;is&nbsp;currently&nbsp;in&nbsp;progress&nbsp;then&nbsp;we&nbsp;try&nbsp;to&nbsp;stream&nbsp;the&nbsp;new&nbsp;sample.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">bool</span><span>&nbsp;wasEmpty&nbsp;=&nbsp;connection-&gt;outboundQueue.isEmpty();&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;wasEmpty&nbsp;&amp;&amp;&nbsp;resumeWithAppendedMotionSample)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;This&nbsp;is&nbsp;a&nbsp;new&nbsp;event.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Enqueue&nbsp;a&nbsp;new&nbsp;dispatch&nbsp;entry&nbsp;onto&nbsp;the&nbsp;outbound&nbsp;queue&nbsp;for&nbsp;this&nbsp;connection.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DispatchEntry*&nbsp;dispatchEntry&nbsp;=&nbsp;mAllocator.obtainDispatchEntry(eventEntry,&nbsp;<span class="comment">//&nbsp;increments&nbsp;ref</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputTarget-&gt;flags,&nbsp;inputTarget-&gt;xOffset,&nbsp;inputTarget-&gt;yOffset);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Enqueue&nbsp;the&nbsp;dispatch&nbsp;entry.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;the&nbsp;outbound&nbsp;queue&nbsp;was&nbsp;previously&nbsp;empty,&nbsp;start&nbsp;the&nbsp;dispatch&nbsp;cycle&nbsp;going.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(wasEmpty)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startDispatchCycleLocked(currentTime,&nbsp;connection);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_85_2447224" name="code" class="cpp" style="display: none;">void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime,
		const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget,
		bool resumeWithAppendedMotionSample) {
	 ......


	 // Resume the dispatch cycle with a freshly appended motion sample.
	 // First we check that the last dispatch entry in the outbound queue is for the same
	 // motion event to which we appended the motion sample.  If we find such a dispatch
	 // entry, and if it is currently in progress then we try to stream the new sample.
	 bool wasEmpty = connection-&gt;outboundQueue.isEmpty();

	 if (! wasEmpty &amp;&amp; resumeWithAppendedMotionSample) {
		 ......
		 return;
	 }

	 // This is a new event.
	 // Enqueue a new dispatch entry onto the outbound queue for this connection.
	 DispatchEntry* dispatchEntry = mAllocator.obtainDispatchEntry(eventEntry, // increments ref
		 inputTarget-&gt;flags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset);

	 ......

	 // Enqueue the dispatch entry.
	 connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);

	 // If the outbound queue was previously empty, start the dispatch cycle going.
	 if (wasEmpty) {
		 ......

		 startDispatchCycleLocked(currentTime, connection);
	 }
}</pre><p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 在开始处理键盘事件之前，这个函数会检查一下传进来的参数connection中的outboundQueue事件队列是否为空，如果不为空，就要看看当前要处理的事件和outboundQueue队列中的最后一个事件是不是同一个motion事件，如果是的话，并且从上面传进来的resumeWithAppendedMotionSample参数为true，这时候就要以流水线的方式来处理这些motion事件了。在我们这个情景中，要处理的是键盘事件，因此在上面Step 12中传进来的resumeWithAppendedMotionSample参数为false，因此，我们略过这种情况。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 接下来，就会把当前的键盘事件封装成一个DispatchEntry对象，然后添加到connection对象的outboundQueue队列中去，表示当前键盘事件是一个待处理的键盘事件。 &nbsp; &nbsp;</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 当connection中的outboundQueue事件队列不为空，即wasEmpty为false时，说明当前这个Activity窗口正在处键盘事件了，因此，就不需要调用startDispatchCycleLocked来启动Activity窗口来处理这个事件了，因为一旦这个Activity窗口正在处键盘事件，它就会一直处理下去，直到它里的connection对象的outboundQueue为空为止。当connection中的outboundQueue事件队列为空时，就需要调用startDispatchCycleLocked来通知这个Activity窗口来执行键盘事件处理的流程了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 17.&nbsp;InputDispatcher.startDispatchCycleLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 56679px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_86" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_86" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=86&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::startDispatchCycleLocked(nsecs_t&nbsp;currentTime,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;sp&lt;Connection&gt;&amp;&nbsp;connection)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;DispatchEntry*&nbsp;dispatchEntry&nbsp;=&nbsp;connection-&gt;outboundQueue.headSentinel.next;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Mark&nbsp;the&nbsp;dispatch&nbsp;entry&nbsp;as&nbsp;in&nbsp;progress.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;dispatchEntry-&gt;inProgress&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Update&nbsp;the&nbsp;connection's&nbsp;input&nbsp;state.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;EventEntry*&nbsp;eventEntry&nbsp;=&nbsp;dispatchEntry-&gt;eventEntry;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Publish&nbsp;the&nbsp;event.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(eventEntry-&gt;type)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;EventEntry::TYPE_KEY:&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyEntry*&nbsp;keyEntry&nbsp;=&nbsp;<span class="keyword">static_cast</span><span>&lt;KeyEntry*&gt;(eventEntry);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Apply&nbsp;target&nbsp;flags.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;action&nbsp;=&nbsp;keyEntry-&gt;action;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;flags&nbsp;=&nbsp;keyEntry-&gt;flags;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Publish&nbsp;the&nbsp;key&nbsp;event.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;connection-&gt;inputPublisher.publishKeyEvent(keyEntry-&gt;deviceId,&nbsp;keyEntry-&gt;source,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action,&nbsp;flags,&nbsp;keyEntry-&gt;keyCode,&nbsp;keyEntry-&gt;scanCode,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyEntry-&gt;metaState,&nbsp;keyEntry-&gt;repeatCount,&nbsp;keyEntry-&gt;downTime,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyEntry-&gt;eventTime);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Send&nbsp;the&nbsp;dispatch&nbsp;signal.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;connection-&gt;inputPublisher.sendDispatchSignal();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_86_9557284" name="code" class="cpp" style="display: none;">void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,
	const sp&lt;Connection&gt;&amp; connection) {
	......

	DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.headSentinel.next;

	// Mark the dispatch entry as in progress.
	dispatchEntry-&gt;inProgress = true;

	// Update the connection's input state.
	EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;
	......

	// Publish the event.
	status_t status;
	switch (eventEntry-&gt;type) {
	case EventEntry::TYPE_KEY: {
		KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(eventEntry);

		// Apply target flags.
		int32_t action = keyEntry-&gt;action;
		int32_t flags = keyEntry-&gt;flags;

		// Publish the key event.
		status = connection-&gt;inputPublisher.publishKeyEvent(keyEntry-&gt;deviceId, keyEntry-&gt;source,
			action, flags, keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,
			keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,
			keyEntry-&gt;eventTime);

		......
		break;
	}
    ......
	}

	// Send the dispatch signal.
	status = connection-&gt;inputPublisher.sendDispatchSignal();
	
	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数主要围绕传进来的Connection对象做两件事情，一是从它的outboundQueue队列中取出当前需要处理的键盘事件，然后把这个事件记录在它的内部对象inputPublisher中，二是通过它的内部对象inputPublisher通知它所关联的Activity窗口，现在有键盘事件需要处理了。第一件事情是通过调用它的InputPublisher对象的publishKeyEvent函数来完成的，而第二件事情是通过调用它的InputPublisher对象的sendDispatchSignal来完成的。我们先来看InputPublisher的成员函数publishKeyEvent的实现，然后再回来分析它的另外一个成员函数sendDispatchSignal的实现。<p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 18. InputPublisher.publishKeyEvent</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputTransport.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 57722px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_87" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_87" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=87&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputPublisher::publishKeyEvent(&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;deviceId,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;source,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;action,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;flags,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;keyCode,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;scanCode,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;metaState,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;repeatCount,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;downTime,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;eventTime)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;result&nbsp;=&nbsp;publishInputEvent(AINPUT_EVENT_TYPE_KEY,&nbsp;deviceId,&nbsp;source);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;result;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;key.action&nbsp;=&nbsp;action;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;key.flags&nbsp;=&nbsp;flags;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;key.keyCode&nbsp;=&nbsp;keyCode;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;key.scanCode&nbsp;=&nbsp;scanCode;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;key.metaState&nbsp;=&nbsp;metaState;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;key.repeatCount&nbsp;=&nbsp;repeatCount;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;key.downTime&nbsp;=&nbsp;downTime;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;key.eventTime&nbsp;=&nbsp;eventTime;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_87_9350324" name="code" class="cpp" style="display: none;">status_t InputPublisher::publishKeyEvent(
	int32_t deviceId,
	int32_t source,
	int32_t action,
	int32_t flags,
	int32_t keyCode,
	int32_t scanCode,
	int32_t metaState,
	int32_t repeatCount,
	nsecs_t downTime,
	nsecs_t eventTime) {
	......

	status_t result = publishInputEvent(AINPUT_EVENT_TYPE_KEY, deviceId, source);
	if (result &lt; 0) {
		return result;
	}

	mSharedMessage-&gt;key.action = action;
	mSharedMessage-&gt;key.flags = flags;
	mSharedMessage-&gt;key.keyCode = keyCode;
	mSharedMessage-&gt;key.scanCode = scanCode;
	mSharedMessage-&gt;key.metaState = metaState;
	mSharedMessage-&gt;key.repeatCount = repeatCount;
	mSharedMessage-&gt;key.downTime = downTime;
	mSharedMessage-&gt;key.eventTime = eventTime;
	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数主要就是把键盘事件记录在InputPublisher类的成员变量mSharedMessage中了，这个mSharedMessage成员变量指向的是一个匿名共享内存。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个匿名共享内存是什么时候创建的呢？前面我们在分析应用程序注册键盘消息接收通道的过程时，在Step 18中（InputDispatcher.registerInputChannel），在把Server端的InputChannel封装成一个 Connection对象时，会调用它的initialize成员函数来执行一些初始化工作，就是在这个时候创建这个匿名共享内存的了：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 58455px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_88" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_88" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=88&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Connection(inputChannel);&nbsp;&nbsp;</span></span></li><li class=""><span>status_t&nbsp;status&nbsp;=&nbsp;connection-&gt;initialize();&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_88_2000284" name="code" class="cpp" style="display: none;">sp&lt;Connection&gt; connection = new Connection(inputChannel);
status_t status = connection-&gt;initialize();</pre>&nbsp;&nbsp; &nbsp; &nbsp; 我们来看一下这个initialize函数的实现，它定义在frameworks/base/libs/ui/InputTransport.cpp文件中：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 58608px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_89" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_89" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=89&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputPublisher::initialize()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ashmemFd&nbsp;=&nbsp;mChannel-&gt;getAshmemFd();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;result&nbsp;=&nbsp;ashmem_get_size_region(ashmemFd);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mAshmemSize&nbsp;=&nbsp;(<span class="datatypes">size_t</span><span>)&nbsp;result;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage&nbsp;=&nbsp;<span class="keyword">static_cast</span><span>&lt;InputMessage*&gt;(mmap(NULL,&nbsp;mAshmemSize,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROT_READ&nbsp;|&nbsp;PROT_WRITE,&nbsp;MAP_SHARED,&nbsp;ashmemFd,&nbsp;0));&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mPinned&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;consumed&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;reset();&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_89_713528" name="code" class="cpp" style="display: none;">status_t InputPublisher::initialize() {
	......

	int ashmemFd = mChannel-&gt;getAshmemFd();
	int result = ashmem_get_size_region(ashmemFd);
	......

	mAshmemSize = (size_t) result;

	mSharedMessage = static_cast&lt;InputMessage*&gt;(mmap(NULL, mAshmemSize,
		PROT_READ | PROT_WRITE, MAP_SHARED, ashmemFd, 0));
	......

	mPinned = true;
	mSharedMessage-&gt;consumed = false;

	return reset();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;InputPublisher的成员变量mChannel就是指注册在InputDispatcher中的Server端InputChannel了。我们知道，这个InputChannel除了拥有一个反向管道的读端文件描述符和一个前向管道的写端文件描述符之后，还有一个匿名共享文件描述符，这个匿名共享文件描述符就是用来创建匿名共享内存mSharedMessage的了。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个匿名共享内存mSharedMessage的作用是什么呢？原来，在InputChannel中，前向管道和反向管道的作用只是用来在Server端和Client端之间相互通知有事件发生了，但是具体是什么样的事件，还需要去读取这个匿名共享内存的内容才知道。前面我们在分析应用程序注册键盘消息接收通道的过程时，在Step 14中（InputChannel.openInputChannelPair）创建Server端和Client端的InputChannel对时，创建一个匿名共享内存，这个匿名共享内存有两个文件描述符同时指向它，其中一个放在Server端的InputChannel中，另外一个放在Client端的InputChannel中。这样，当InputDispatcher通过Server端的InputChannel的前向管道来通知Client端有键盘事件发生时，Client端只要通过它的InputChannel中的匿名共享内存文件描述符去读取匿名共享内存中的内容，就可以知道发生了什么事情了。有关匿名共享内存的相关知识，请参考<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6651971">Android系统匿名共享内存Ashmem（Anonymous Shared Memory）简要介绍和学习计划</a>一文。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到Step 17中，接下来就是调用InputPublisher的成员函数sendDispatchSignal来通知Activity窗口处理键盘事件了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 19.&nbsp;InputPublishe.sendDispatchSignal<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputTransport.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 59463px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_90" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_90" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=90&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputPublisher::sendDispatchSignal()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;mWasDispatched&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;mChannel-&gt;sendSignal(INPUT_SIGNAL_DISPATCH);&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_90_4999689" name="code" class="cpp" style="display: none;">status_t InputPublisher::sendDispatchSignal() {
	......

	mWasDispatched = true;
	return mChannel-&gt;sendSignal(INPUT_SIGNAL_DISPATCH);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数很简单，它通过调用内部成员变量mChannel的sendSignal函数来通知相应的Activity窗口来处理键盘事件。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 20. InputChannel.sendSignal</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputTransport.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 59782px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_91" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_91" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=91&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputChannel::sendSignal(</span><span class="datatypes">char</span><span>&nbsp;signal)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;nWrite;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">do</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nWrite&nbsp;=&nbsp;::write(mSendPipeFd,&nbsp;&amp;&nbsp;signal,&nbsp;1);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">while</span><span>&nbsp;(nWrite&nbsp;==&nbsp;-1&nbsp;&amp;&amp;&nbsp;errno&nbsp;==&nbsp;EINTR);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(nWrite&nbsp;==&nbsp;1)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-errno;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_91_6569852" name="code" class="cpp" style="display: none;">status_t InputChannel::sendSignal(char signal) {
	ssize_t nWrite;
	do {
		nWrite = ::write(mSendPipeFd, &amp; signal, 1);
	} while (nWrite == -1 &amp;&amp; errno == EINTR);

	if (nWrite == 1) {
		......
		return OK;
	}

	return -errno;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里所谓的发送信号通知，其实是通过向其内部一个管道的写端写入一个字符来实现的。前面我们分析应用程序注册键盘消息接收通道的过程时，在Step 21中（NativeInputQueue.registerInputChannel），它把一个InputChannel注册到应用程序主线程中的Looper对象中，然后应用程序的主线程就通过这个Looper对象睡眠等待在这个InputChannel中的前向管道中有新的内容可读了，这里的mSendPipeFd就是对应这个前向管道的写端。现在既然向这个前向管道的写端写入新的内容了，于是，应用程序的主线程就被唤醒了。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面分析应用程序注册键盘消息接收通道过程的Step 21中，我们也说过，当应用程序的主线程因为这个InputChannel中的前向管道的写端唤醒时，NativeInputQueue的成员函数handleReceiveCallback就会被回调，因此，接下来，应用程序的主线程就会被唤醒，然后执行NativeInputQueue的成员函数handleReceiveCallback。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 21.&nbsp;NativeInputQueue.handleReceiveCallback</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/jni/android_view_InputQueue.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "><span style="font-family:monospace;"><span style="white-space: pre;"><span style="font-family:Arial, Verdana, sans-serif;"><span style="white-space: normal;"></span></span></span></span></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 60391px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_92" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_92" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=92&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;NativeInputQueue::handleReceiveCallback(</span><span class="datatypes">int</span><span>&nbsp;receiveFd,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;events,&nbsp;</span><span class="keyword">void</span><span>*&nbsp;data)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;NativeInputQueue*&nbsp;q&nbsp;=&nbsp;<span class="keyword">static_cast</span><span>&lt;NativeInputQueue*&gt;(data);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;JNIEnv*&nbsp;env&nbsp;=&nbsp;AndroidRuntime::getJNIEnv();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Connection&gt;&nbsp;connection;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;InputEvent*&nbsp;inputEvent;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;inputHandlerObjLocal;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;jlong&nbsp;finishedToken;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(q-&gt;mLock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;q-&gt;mConnectionsByReceiveFd.indexOfKey(receiveFd);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection&nbsp;=&nbsp;q-&gt;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;connection-&gt;inputConsumer.receiveDispatchSignal();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(status)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;</span><span class="comment">//&nbsp;remove&nbsp;the&nbsp;callback</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status&nbsp;=&nbsp;connection-&gt;inputConsumer.consume(&amp;&nbsp;connection-&gt;inputEventFactory,&nbsp;&amp;&nbsp;inputEvent);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finishedToken&nbsp;=&nbsp;generateFinishedToken(receiveFd,&nbsp;connection-&gt;id,&nbsp;connection-&gt;messageSeqNum);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputHandlerObjLocal&nbsp;=&nbsp;env-&gt;NewLocalRef(connection-&gt;inputHandlerObjGlobal);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;inputEventType&nbsp;=&nbsp;inputEvent-&gt;getType();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;inputEventObj;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;jmethodID&nbsp;dispatchMethodId;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(inputEventType)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;AINPUT_EVENT_TYPE_KEY:&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputEventObj&nbsp;=&nbsp;android_view_KeyEvent_fromNative(env,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">static_cast</span><span>&lt;KeyEvent*&gt;(inputEvent));&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatchMethodId&nbsp;=&nbsp;gInputQueueClassInfo.dispatchKeyEvent;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;env-&gt;CallStaticVoidMethod(gInputQueueClassInfo.clazz,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatchMethodId,&nbsp;inputHandlerObjLocal,&nbsp;inputEventObj,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jlong(finishedToken));&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;1;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_92_5839504" name="code" class="cpp" style="display: none;">int NativeInputQueue::handleReceiveCallback(int receiveFd, int events, void* data) {
	NativeInputQueue* q = static_cast&lt;NativeInputQueue*&gt;(data);
	JNIEnv* env = AndroidRuntime::getJNIEnv();

	sp&lt;Connection&gt; connection;
	InputEvent* inputEvent;
	jobject inputHandlerObjLocal;
	jlong finishedToken;
	{ // acquire lock
		AutoMutex _l(q-&gt;mLock);

		ssize_t connectionIndex = q-&gt;mConnectionsByReceiveFd.indexOfKey(receiveFd);
		......

			connection = q-&gt;mConnectionsByReceiveFd.valueAt(connectionIndex);
		......


			status_t status = connection-&gt;inputConsumer.receiveDispatchSignal();
		if (status) {
			......
				return 0; // remove the callback
		}

		......

		status = connection-&gt;inputConsumer.consume(&amp; connection-&gt;inputEventFactory, &amp; inputEvent);
		......

		finishedToken = generateFinishedToken(receiveFd, connection-&gt;id, connection-&gt;messageSeqNum);

		inputHandlerObjLocal = env-&gt;NewLocalRef(connection-&gt;inputHandlerObjGlobal);
	} // release lock

	......

	int32_t inputEventType = inputEvent-&gt;getType();

	jobject inputEventObj;
	jmethodID dispatchMethodId;
	switch (inputEventType) {
	case AINPUT_EVENT_TYPE_KEY:
		......
			inputEventObj = android_view_KeyEvent_fromNative(env,
			static_cast&lt;KeyEvent*&gt;(inputEvent));
		dispatchMethodId = gInputQueueClassInfo.dispatchKeyEvent;
		break;
	}
	......
	}

	......

	env-&gt;CallStaticVoidMethod(gInputQueueClassInfo.clazz,
						  dispatchMethodId, inputHandlerObjLocal, inputEventObj,
						  jlong(finishedToken));

	......

	return 1;
}</pre><p></p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先是通过参数data获得当初注册InputChannel的NativeInputQueue对象，具体可以参考前面介绍的应用程序注册键盘消息接收通道过程的Step 21。接下来再通过参数receiveFd获得保存在这个NativeInputQueue对象中的mConnectionsByReceiveFd成员变量中的Connection对象。有了这个Connection对象后，就可以获得它内部的InputConsumer对象，这个InputConsumer对象是和上面的Step 18中介绍的InputPublisher对象相应的。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在InputChannel内部中，分别有一个InputPublisher对象和一个InputConsumer对象，对于Server端的InputChannel来说，它使用的是InputPublisher对象，通过它进行键盘消息的分发，而对于Client端的InputChannel来说，它使用的是InputConsumer对象，通过它进行键盘消息的读取。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;获得了这个InputConsumer对象后首先是调用它的receiveDispatchSignal来确认是否是接收到了键盘消息的通知，如果是的话，再调用它的consume函数来把键盘事件读取出来，最后，调用Java层的回调对象InputQueue的DispatchKeyEvent来处理这个键盘事件。下面，我们就依次来分析这些过程。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 22.&nbsp;InputConsumer.receiveDispatchSignal</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputTransport.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 61960px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_93" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_93" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=93&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputConsumer::receiveDispatchSignal()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;signal;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;result&nbsp;=&nbsp;mChannel-&gt;receiveSignal(&amp;&nbsp;signal);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;result;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(signal&nbsp;!=&nbsp;INPUT_SIGNAL_DISPATCH)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;UNKNOWN_ERROR;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_93_9012850" name="code" class="cpp" style="display: none;">status_t InputConsumer::receiveDispatchSignal() {
	......

	char signal;
	status_t result = mChannel-&gt;receiveSignal(&amp; signal);
	if (result) {
		return result;
	}
	if (signal != INPUT_SIGNAL_DISPATCH) {
		......
		return UNKNOWN_ERROR;
	}
	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数很简单，它通过它内部对象mChannel来从前向管道的读端读入一个字符，看看是否是前面的Step 20中写入的INPUT_SIGNAL_DISPATCH字符。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; InputChannel类的receiveSignal函数也是定义在frameworks/base/libs/ui/InputTransport.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 62389px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_94" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_94" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=94&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputChannel::receiveSignal(</span><span class="datatypes">char</span><span>*&nbsp;outSignal)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;nRead;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">do</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nRead&nbsp;=&nbsp;::read(mReceivePipeFd,&nbsp;outSignal,&nbsp;1);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">while</span><span>&nbsp;(nRead&nbsp;==&nbsp;-1&nbsp;&amp;&amp;&nbsp;errno&nbsp;==&nbsp;EINTR);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(nRead&nbsp;==&nbsp;1)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;-errno;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_94_2742605" name="code" class="cpp" style="display: none;">status_t InputChannel::receiveSignal(char* outSignal) {
	ssize_t nRead;
	do {
		nRead = ::read(mReceivePipeFd, outSignal, 1);
	} while (nRead == -1 &amp;&amp; errno == EINTR);

	if (nRead == 1) {
		......
		return OK;
	}

	......
	return -errno;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 23.&nbsp;InputConsumer.consume<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputTransport.cpp文件中：</p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 62784px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_95" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_95" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=95&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputConsumer::consume(InputEventFactoryInterface*&nbsp;factory,&nbsp;InputEvent**&nbsp;outEvent)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;*outEvent&nbsp;=&nbsp;NULL;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ashmemFd&nbsp;=&nbsp;mChannel-&gt;getAshmemFd();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;result&nbsp;=&nbsp;ashmem_pin_region(ashmemFd,&nbsp;0,&nbsp;0);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mSharedMessage-&gt;consumed)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;INVALID_OPERATION;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Acquire&nbsp;but&nbsp;*never&nbsp;release*&nbsp;the&nbsp;semaphore.&nbsp;&nbsp;Contention&nbsp;on&nbsp;the&nbsp;semaphore&nbsp;is&nbsp;used&nbsp;to&nbsp;signal</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;to&nbsp;the&nbsp;publisher&nbsp;that&nbsp;the&nbsp;message&nbsp;has&nbsp;been&nbsp;consumed&nbsp;(or&nbsp;is&nbsp;in&nbsp;the&nbsp;process&nbsp;of&nbsp;being</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;consumed).&nbsp;&nbsp;Eventually&nbsp;the&nbsp;publisher&nbsp;will&nbsp;reinitialize&nbsp;the&nbsp;semaphore&nbsp;for&nbsp;the&nbsp;next&nbsp;message.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;sem_wait(&amp;&nbsp;mSharedMessage-&gt;semaphore);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mSharedMessage-&gt;consumed&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(mSharedMessage-&gt;type)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;AINPUT_EVENT_TYPE_KEY:&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyEvent*&nbsp;keyEvent&nbsp;=&nbsp;factory-&gt;createKeyEvent();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!&nbsp;keyEvent)&nbsp;</span><span class="keyword">return</span><span>&nbsp;NO_MEMORY;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;populateKeyEvent(keyEvent);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*outEvent&nbsp;=&nbsp;keyEvent;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_95_6472359" name="code" class="cpp" style="display: none;">status_t InputConsumer::consume(InputEventFactoryInterface* factory, InputEvent** outEvent) {
	......

	*outEvent = NULL;

	int ashmemFd = mChannel-&gt;getAshmemFd();
	int result = ashmem_pin_region(ashmemFd, 0, 0);
	......

	if (mSharedMessage-&gt;consumed) {
		......
		return INVALID_OPERATION;
	}

	// Acquire but *never release* the semaphore.  Contention on the semaphore is used to signal
	// to the publisher that the message has been consumed (or is in the process of being
	// consumed).  Eventually the publisher will reinitialize the semaphore for the next message.
	result = sem_wait(&amp; mSharedMessage-&gt;semaphore);
	......

	mSharedMessage-&gt;consumed = true;

	switch (mSharedMessage-&gt;type) {
	case AINPUT_EVENT_TYPE_KEY: {
		KeyEvent* keyEvent = factory-&gt;createKeyEvent();
		if (! keyEvent) return NO_MEMORY;

		populateKeyEvent(keyEvent);

		*outEvent = keyEvent;
		break;
	}
	......
	}

	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数很简单，只要对照前面的Step 18（InputPublisher.publishKeyEvent）来逻辑来看就可以了，后者是往匿名共享内存中写入键盘事件，前者是从这个匿名共享内存中把这个键盘事件的内容读取出来。<p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到Step 21中的handleReceiveCallback函数中，从InputConsumer中获得了键盘事件的内容（保存在本地变量inputEvent中）后，就开始要通知Java层的应用程序了。在前面分析应用程序注册键盘消息接收通道的过程时，在Step 21中（NativeInputQueue.registerInputChannel），会把传进来的对象inputHandlerObj保存在Connection对象中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 63710px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_96" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_96" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=96&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>connection-&gt;inputHandlerObjGlobal&nbsp;=&nbsp;env-&gt;NewGlobalRef(inputHandlerObj);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_96_4662215" name="code" class="cpp" style="display: none;">connection-&gt;inputHandlerObjGlobal = env-&gt;NewGlobalRef(inputHandlerObj);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个inputHandlerObj对象的类型为Java层的InputHandler对象，因此，这里首先把它取回来：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 63845px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_97" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_97" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=97&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>inputHandlerObjLocal&nbsp;=&nbsp;env-&gt;NewLocalRef(connection-&gt;inputHandlerObjGlobal);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_97_7835562" name="code" class="cpp" style="display: none;">inputHandlerObjLocal = env-&gt;NewLocalRef(connection-&gt;inputHandlerObjGlobal);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;取回来之后，我们要把作为参数来调用InputQueue类的dispatchKeyEvent静态成员函数来通知应用程序，有键盘事件发生了，因此，先找到InputQueue类的静态成员函数dispatchKeyEvent的ID：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 64006px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_98" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_98" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=98&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>dispatchMethodId&nbsp;=&nbsp;gInputQueueClassInfo.dispatchKeyEvent;&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_98_6548806" name="code" class="cpp" style="display: none;">dispatchMethodId = gInputQueueClassInfo.dispatchKeyEvent;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在回调用这个InputQueue类的dispatchKeyEvent静态成员函数之前，还要把前面获得的inputEvent对象转换成Java层的KeyEvent对象：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 64167px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_99" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_99" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=99&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>inputEventObj&nbsp;=&nbsp;android_view_KeyEvent_fromNative(env,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">static_cast</span><span>&lt;KeyEvent*&gt;(inputEvent));&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_99_4738663" name="code" class="cpp" style="display: none;">inputEventObj = android_view_KeyEvent_fromNative(env,
	static_cast&lt;KeyEvent*&gt;(inputEvent));</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;万事具备了，就可以通知Java层的InputQueue来处理这个键盘事件了：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 64320px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_100" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_100" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=100&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>env-&gt;CallStaticVoidMethod(gInputQueueClassInfo.clazz,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatchMethodId,&nbsp;inputHandlerObjLocal,&nbsp;inputEventObj,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jlong(finishedToken));&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_100_420265" name="code" class="cpp" style="display: none;">env-&gt;CallStaticVoidMethod(gInputQueueClassInfo.clazz,
		dispatchMethodId, inputHandlerObjLocal, inputEventObj,
		jlong(finishedToken));</pre><span style="white-space:pre">	</span>Step 24. InputQueue.dispatchKeyEvent<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/InputQueue.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 64525px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_101" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_101" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=101&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputQueue&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;dispatchKeyEvent(InputHandler&nbsp;inputHandler,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyEvent&nbsp;event,&nbsp;<span class="keyword">long</span><span>&nbsp;finishedToken)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;finishedCallback&nbsp;=&nbsp;FinishedCallback.obtain(finishedToken);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputHandler.handleKey(event,&nbsp;finishedCallback);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_101_5578478" name="code" class="java" style="display: none;">public final class InputQueue {
	......

	private static void dispatchKeyEvent(InputHandler inputHandler,
			KeyEvent event, long finishedToken) {
		Runnable finishedCallback = FinishedCallback.obtain(finishedToken);
		inputHandler.handleKey(event, finishedCallback);
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先会创建一个FinishedCallback类型的对象finishedCallback，FinishedCallback是InputQueue的一个内部类，它继承于Runnable类。这个finishedCallback对象是提供给当前Activity窗口的，当它处理完毕键盘事件后，需要通过消息分发的方式来回调这个finishedCallback对象，以及InputQueue类处理一个手尾的工作，后面我们会分析到。<br><p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的inputHandler对象是在前面分析应用程序注册键盘消息接收通道的过程时，在Step 1（ViewRoot.setView）中传进来的：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 64978px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_102" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_102" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=102&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>InputQueue.registerInputChannel(mInputChannel,&nbsp;mInputHandler,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;Looper.myQueue());&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_102_2896282" name="code" class="java" style="display: none;">InputQueue.registerInputChannel(mInputChannel, mInputHandler,
	Looper.myQueue());</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 它是ViewRoot类的一个成员变量mInputHandler。因此，这里将调用ViewRoot类的内部对象mInputHandler的成员函数handleKey来处理键盘事件。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 25. InputHandler.handleKey</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：<br></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 65217px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_103" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_103" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=103&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;InputHandler&nbsp;mInputHandler&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;InputHandler()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;handleKey(KeyEvent&nbsp;event,&nbsp;Runnable&nbsp;finishedCallback)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startInputEvent(finishedCallback);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatchKey(event,&nbsp;<span class="keyword">true</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_103_4466446" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	private final InputHandler mInputHandler = new InputHandler() {
		public void handleKey(KeyEvent event, Runnable finishedCallback) {
			startInputEvent(finishedCallback);
			dispatchKey(event, true);
		}
		......
	};

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数首先调用其外部类ViewRoot的startInputEvent成员函数来把回调对象finishedCallback保存下来：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 65586px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_104" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_104" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=104&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;startInputEvent(Runnable&nbsp;finishedCallback)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFinishedCallback&nbsp;=&nbsp;finishedCallback;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_104_2656302" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	private void startInputEvent(Runnable finishedCallback) {
		......

		mFinishedCallback = finishedCallback;
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;然后再调用其外部类ViewRoot的dispatchKey成员函数来进一步处这个键盘事件。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 26.&nbsp;ViewRoot.dispatchKey</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 65987px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_105" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_105" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=105&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;dispatchKey(KeyEvent&nbsp;event,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;sendDone)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message&nbsp;msg&nbsp;=&nbsp;obtainMessage(DISPATCH_KEY);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg.obj&nbsp;=&nbsp;event;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg.arg1&nbsp;=&nbsp;sendDone&nbsp;?&nbsp;<span class="number">1</span><span>&nbsp;:&nbsp;</span><span class="number">0</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendMessageAtTime(msg,&nbsp;event.getEventTime());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_105_4990616" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	private void dispatchKey(KeyEvent event, boolean sendDone) {
		......

		Message msg = obtainMessage(DISPATCH_KEY);
		msg.obj = event;
		msg.arg1 = sendDone ? 1 : 0;

		......

		sendMessageAtTime(msg, event.getEventTime());
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot不是直接处理这个键盘事件，而是把作为一个消息（DISPATCH_KEY）它放到消息队列中去处理，这个消息最后由ViewRoot类的deliverKeyEvent成员函数来处理。<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 27.&nbsp;ViewRoot.deliverKeyEvent<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 66514px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_106" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_106" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=106&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;deliverKeyEvent(KeyEvent&nbsp;event,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;sendDone)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;mView&nbsp;is&nbsp;null,&nbsp;we&nbsp;just&nbsp;consume&nbsp;the&nbsp;key&nbsp;event&nbsp;because&nbsp;it&nbsp;doesn't</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;make&nbsp;sense&nbsp;to&nbsp;do&nbsp;anything&nbsp;else&nbsp;with&nbsp;it.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;handled&nbsp;=&nbsp;mView&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;mView.dispatchKeyEventPreIme(event)&nbsp;:&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;it&nbsp;is&nbsp;possible&nbsp;for&nbsp;this&nbsp;window&nbsp;to&nbsp;interact&nbsp;with&nbsp;the&nbsp;input</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;method&nbsp;window,&nbsp;then&nbsp;we&nbsp;want&nbsp;to&nbsp;first&nbsp;dispatch&nbsp;our&nbsp;key&nbsp;events</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;to&nbsp;the&nbsp;input&nbsp;method.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mLastWasImTarget)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputMethodManager&nbsp;imm&nbsp;=&nbsp;InputMethodManager.peekInstance();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(imm&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>&nbsp;&amp;&amp;&nbsp;mView&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imm.dispatchKeyEvent(mView.getContext(),&nbsp;seq,&nbsp;event,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputMethodCallback);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_106_3180473" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	private void deliverKeyEvent(KeyEvent event, boolean sendDone) {
		// If mView is null, we just consume the key event because it doesn't
		// make sense to do anything else with it.
		boolean handled = mView != null
			? mView.dispatchKeyEventPreIme(event) : true;
		......

		// If it is possible for this window to interact with the input
		// method window, then we want to first dispatch our key events
		// to the input method.
		if (mLastWasImTarget) {
			InputMethodManager imm = InputMethodManager.peekInstance();
			if (imm != null &amp;&amp; mView != null) {
				......

				imm.dispatchKeyEvent(mView.getContext(), seq, event,
					mInputMethodCallback);
				return;
			}
		}
		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot在把这个键盘事件分发给当前激活的Activity窗口处理之前，首先会调用InputMethodManager的dispatchKeyEvent成员函数来处理这个键盘事件。InputMethodManager处理完这个键盘事件后，再回调用这里的mInputMethodCallback对象的finishedEvent成员函数来把键盘事件分发给当前激活的Activity窗口处理。当然，在把这个键盘事件分发给InputMethodManager处理之前，ViewRoot也会先把这个键盘事件分发给当前激活的Activity窗口的dispatchKeyEventPreIme成员函数处理。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 28. InputMethodManager.dispatchKeyEvent</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/inputmethod/InputMethodManager.java文件中。这是一个输入法相关的类，我们这里就不关注了，只要知道当输入法处理完成之后，它就会调用ViewRoot类的mInputMehtodCallback对象的finishedEvent成员函数。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 29. &nbsp;InputMethodCallack.finishedEvent</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 67445px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_107" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_107" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=107&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">static</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputMethodCallback&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IInputMethodCallback.Stub&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;WeakReference&lt;ViewRoot&gt;&nbsp;mViewRoot;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;InputMethodCallback(ViewRoot&nbsp;viewRoot)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mViewRoot&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;WeakReference&lt;ViewRoot&gt;(viewRoot);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;finishedEvent(</span><span class="keyword">int</span><span>&nbsp;seq,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;handled)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;ViewRoot&nbsp;viewRoot&nbsp;=&nbsp;mViewRoot.get();&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(viewRoot&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewRoot.dispatchFinishedEvent(seq,&nbsp;handled);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_107_2765769" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	static class InputMethodCallback extends IInputMethodCallback.Stub {
		private WeakReference&lt;ViewRoot&gt; mViewRoot;

		public InputMethodCallback(ViewRoot viewRoot) {
				mViewRoot = new WeakReference&lt;ViewRoot&gt;(viewRoot);
		}

		public void finishedEvent(int seq, boolean handled) {
			final ViewRoot viewRoot = mViewRoot.get();
			if (viewRoot != null) {
				viewRoot.dispatchFinishedEvent(seq, handled);
			}
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数最终调用ViewRoot的dispatchFinishedEvent来进一步处理。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 30.&nbsp;ViewRoot.dispatchFinishedEvent</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 68044px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_108" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_108" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=108&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;dispatchFinishedEvent(</span><span class="keyword">int</span><span>&nbsp;seq,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;handled)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message&nbsp;msg&nbsp;=&nbsp;obtainMessage(FINISHED_EVENT);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg.arg1&nbsp;=&nbsp;seq;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg.arg2&nbsp;=&nbsp;handled&nbsp;?&nbsp;<span class="number">1</span><span>&nbsp;:&nbsp;</span><span class="number">0</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendMessage(msg);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_108_4543676" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	public void dispatchFinishedEvent(int seq, boolean handled) {
		Message msg = obtainMessage(FINISHED_EVENT);
		msg.arg1 = seq;
		msg.arg2 = handled ? 1 : 0;
		sendMessage(msg);
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;和前面的Step 26一样，ViewRoot不是直接处理这个键盘事件，而是把它作为一个消息（FINISHED_EVENT）放在消息队列中去，最后，这个消息由ViewRoot的handleFinishedEvent函数来处理。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 31.&nbsp;ViewRoot.handleFinishedEvent</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 68481px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_109" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_109" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=109&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">void</span><span>&nbsp;handleFinishedEvent(</span><span class="keyword">int</span><span>&nbsp;seq,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;handled)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;KeyEvent&nbsp;event&nbsp;=&nbsp;(KeyEvent)retrievePendingEvent(seq);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(event&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;sendDone&nbsp;=&nbsp;seq&nbsp;&gt;=&nbsp;</span><span class="number">0</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!handled)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deliverKeyEventToViewHierarchy(event,&nbsp;sendDone);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(sendDone)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_109_3605584" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	void handleFinishedEvent(int seq, boolean handled) {
		final KeyEvent event = (KeyEvent)retrievePendingEvent(seq);
		......

		if (event != null) {
			final boolean sendDone = seq &gt;= 0;
			if (!handled) {
				deliverKeyEventToViewHierarchy(event, sendDone);
				return;
			} else if (sendDone) {
				......
			} else {
				......
			}
		}
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果InputMethodManager没有处理这个键盘事件，那么ViewRoot就会调用deliverKeyEventToViewHierarchy函数来把这个键盘事件分发给当前激活的Activity窗口来处理。<p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 32.&nbsp;ViewRoot.deliverKeyEventToViewHierarchy</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 69088px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_110" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_110" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=110&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;deliverKeyEventToViewHierarchy(KeyEvent&nbsp;event,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;sendDone)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mView&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>&nbsp;&amp;&amp;&nbsp;mAdded)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;keyHandled&nbsp;=&nbsp;mView.dispatchKeyEvent(event);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">finally</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(sendDone)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finishInputEvent();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_110_5939898" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	private void deliverKeyEventToViewHierarchy(KeyEvent event, boolean sendDone) {
		try {
			if (mView != null &amp;&amp; mAdded) {
				......

				boolean keyHandled = mView.dispatchKeyEvent(event);
			}

			......
		} finally {
			if (sendDone) {
				finishInputEvent();
			}
		}
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先会调用ViewRoot类的成员变量mView的dispatchKeyEvent来处理这个键盘事件，然后最调用ViewRoot类的finishInputEvent来处理手尾工作。<p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员变量mView的类型为DecorView，它是由ActivityThread类第一次Resume当前的Activity窗口时创建的，具体可以参考ActivityThread类的handleResumeActivity成员函数，这里就不关注了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 33. DecorView.dispatchKeyEvent</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java文件中，它是PhoneWindow类的一个内部类：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 69771px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_111" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_111" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=111&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;PhoneWindow&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Window&nbsp;</span><span class="keyword">implements</span><span>&nbsp;MenuBuilder.Callback&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;DecorView&nbsp;</span><span class="keyword">extends</span><span>&nbsp;FrameLayout&nbsp;</span><span class="keyword">implements</span><span>&nbsp;RootViewSurfaceTaker&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;dispatchKeyEvent(KeyEvent&nbsp;event)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;Callback&nbsp;cb&nbsp;=&nbsp;getCallback();&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;handled&nbsp;=&nbsp;cb&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>&nbsp;&amp;&amp;&nbsp;mFeatureId&nbsp;&lt;&nbsp;</span><span class="number">0</span><span>&nbsp;?&nbsp;cb.dispatchKeyEvent(event)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<span class="keyword">super</span><span>.dispatchKeyEvent(event);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_111_5525195" name="code" class="java" style="display: none;">public class PhoneWindow extends Window implements MenuBuilder.Callback {
	......

	private final class DecorView extends FrameLayout implements RootViewSurfaceTaker {
		......

		@Override
		public boolean dispatchKeyEvent(KeyEvent event) {
			......

			final Callback cb = getCallback();
			final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event)
				: super.dispatchKeyEvent(event);

			......
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里通过getCallback函数返回的是当前应用程序的激活的Activity窗口的Window.Callback接口，一般它不为NULL，因此，这个函数会调用Activity类的dispatchKeyEvent来处理这个键盘事件。<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 34. Activity.dispatchKeyEvent<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/app/Activity.java文件中：<br></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 70377px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_112" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_112" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=112&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Activity&nbsp;</span><span class="keyword">extends</span><span>&nbsp;ContextThemeWrapper&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;LayoutInflater.Factory,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Window.Callback,&nbsp;KeyEvent.Callback,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OnCreateContextMenuListener,&nbsp;ComponentCallbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;dispatchKeyEvent(KeyEvent&nbsp;event)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View&nbsp;decor&nbsp;=&nbsp;mDecor;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(decor&nbsp;==&nbsp;</span><span class="keyword">null</span><span>)&nbsp;decor&nbsp;=&nbsp;win.getDecorView();&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;event.dispatch(</span><span class="keyword">this</span><span>,&nbsp;decor&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;decor.getKeyDispatcherState()&nbsp;:&nbsp;<span class="keyword">null</span><span>,&nbsp;</span><span class="keyword">this</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_112_8382896" name="code" class="java" style="display: none;">public class Activity extends ContextThemeWrapper
		implements LayoutInflater.Factory,
		Window.Callback, KeyEvent.Callback,
		OnCreateContextMenuListener, ComponentCallbacks {
	......

	public boolean dispatchKeyEvent(KeyEvent event) {
		......

		View decor = mDecor;
		if (decor == null) decor = win.getDecorView();
		return event.dispatch(this, decor != null
			? decor.getKeyDispatcherState() : null, this);
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这里，Activity不是直接处理这个键盘事件，而是通过KeyEvent的dispatch转发一下。注意，KeyEvent的成中函数dispatch的第一个参数的类型是KeyEvent.Callback，而Activity实现了这个接口，因此，这里可以传this引用过去。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 35. KeyEvent.dispatch</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/core/java/android/view/KeyEvent.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 70920px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_113" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_113" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=113&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;KeyEvent&nbsp;</span><span class="keyword">extends</span><span>&nbsp;InputEvent&nbsp;</span><span class="keyword">implements</span><span>&nbsp;Parcelable&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;dispatch(Callback&nbsp;receiver,&nbsp;DispatcherState&nbsp;state,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;target)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span><span>&nbsp;(mAction)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;ACTION_DOWN:&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;res&nbsp;=&nbsp;receiver.onKeyDown(mKeyCode,&nbsp;</span><span class="keyword">this</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;res;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;ACTION_UP:&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;receiver.onKeyUp(mKeyCode,&nbsp;</span><span class="keyword">this</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span><span>&nbsp;ACTION_MULTIPLE:&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;count&nbsp;=&nbsp;mRepeatCount;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;code&nbsp;=&nbsp;mKeyCode;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(receiver.onKeyMultiple(code,&nbsp;count,&nbsp;</span><span class="keyword">this</span><span>))&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_113_7968193" name="code" class="java" style="display: none;">public class KeyEvent extends InputEvent implements Parcelable {
	......

	public final boolean dispatch(Callback receiver, DispatcherState state,
			Object target) {
		switch (mAction) {
		case ACTION_DOWN: {
			......
			boolean res = receiver.onKeyDown(mKeyCode, this);
			......
			return res;
		}
		case ACTION_UP:
			......
			return receiver.onKeyUp(mKeyCode, this);
		case ACTION_MULTIPLE:
			final int count = mRepeatCount;
			final int code = mKeyCode;
			if (receiver.onKeyMultiple(code, count, this)) {
				return true;
			}
			......
			return false;
		}
		return false;
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这里就根据一个键是按下（ACTION_DOWN）、还是松开（ACTION_UP）或者是一个相同的键被多次按下和松开（ACTION_MULTIPLE）等不同事件类型来分别调用Activity的onKeyDown、onKeyUp和onKeyMultiple函数了。<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Activity窗口处理完这个键盘事件后，层层返回，最后回到Step 32中，调用finishInputEvent事件来处理一些手尾工，下面我们将会看到这些手尾工是什么。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 36. ViewRoot.finishInputEvent</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：<br></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 71723px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_114" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_114" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=114&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;finishInputEvent()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mFinishedCallback&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFinishedCallback.run();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFinishedCallback&nbsp;=&nbsp;<span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_114_3126407" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	private void finishInputEvent() {
		......

		if (mFinishedCallback != null) {
			mFinishedCallback.run();
			mFinishedCallback = null;
		} else {
			......
		}
	}

	......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ViewRoot类里面的成员变量mFinishedCallback是在前面Step 25中由InputQueue设置的，它是一个Runnable对象，实际类型是定义在InputQueue的内部类FinishedCallback，因此，这里调用它的run方法时，接下来就会调用InputQueue的内部类FinishedCallback的run成员函数：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 72180px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_115" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_115" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=115&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputQueue&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;FinishedCallback&nbsp;</span><span class="keyword">implements</span><span>&nbsp;Runnable&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;run()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(sLock)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nativeFinished(mFinishedToken);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_115_8284620" name="code" class="java" style="display: none;">public final class InputQueue {
	......

	private static class FinishedCallback implements Runnable {
		......

		public void run() {
			synchronized (sLock) {
				......

				nativeFinished(mFinishedToken);
				
				......
			}
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里它调用外部类InputQueue的本地方法nativeFinished来进一步处理。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 37. &nbsp;InputQueue.nativeFinished</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/jni/android_view_InputQueue.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 72737px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_116" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_116" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=116&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;android_view_InputQueue_nativeFinished(JNIEnv*&nbsp;env,&nbsp;jclass&nbsp;clazz,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jlong&nbsp;finishedToken)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;gNativeInputQueue.finished(&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env,&nbsp;finishedToken,&nbsp;<span class="keyword">false</span><span>&nbsp;</span><span class="comment">/*ignoreSpuriousFinish*/</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_116_7030884" name="code" class="cpp" style="display: none;">static void android_view_InputQueue_nativeFinished(JNIEnv* env, jclass clazz,
		jlong finishedToken) {
	status_t status = gNativeInputQueue.finished(
		env, finishedToken, false /*ignoreSpuriousFinish*/);

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数只是简单只调用NativeInputQueue的finished方法来进一处处理。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 38. NativeInputQueue.finished</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/jni/android_view_InputQueue.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 73042px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_117" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_117" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=117&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;NativeInputQueue::finished(JNIEnv*&nbsp;env,&nbsp;jlong&nbsp;finishedToken,&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;ignoreSpuriousFinish)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;int32_t&nbsp;receiveFd;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;uint16_t&nbsp;connectionId;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;uint16_t&nbsp;messageSeqNum;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;parseFinishedToken(finishedToken,&nbsp;&amp;receiveFd,&nbsp;&amp;connectionId,&nbsp;&amp;messageSeqNum);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;mConnectionsByReceiveFd.indexOfKey(receiveFd);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection-&gt;messageInProgress&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;connection-&gt;inputConsumer.sendFinishedSignal();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_117_3584538" name="code" class="cpp" style="display: none;">status_t NativeInputQueue::finished(JNIEnv* env, jlong finishedToken, bool ignoreSpuriousFinish) {
	int32_t receiveFd;
	uint16_t connectionId;
	uint16_t messageSeqNum;
	parseFinishedToken(finishedToken, &amp;receiveFd, &amp;connectionId, &amp;messageSeqNum);

	{ // acquire lock
		AutoMutex _l(mLock);

		ssize_t connectionIndex = mConnectionsByReceiveFd.indexOfKey(receiveFd);
		......

		sp&lt;Connection&gt; connection = mConnectionsByReceiveFd.valueAt(connectionIndex);
		......

		connection-&gt;messageInProgress = false;

		status_t status = connection-&gt;inputConsumer.sendFinishedSignal();
		
		......
	} // release lock

	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数最重要的参数便是finishedToken了，通过它可以获得之前通知Java层的InputQueue类来处理键盘事件的Connection对象，它的值是在上面的Step 21（NativeInputQueue.handleReceiveCallback）中生成的：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 73614px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_118" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_118" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=118&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>finishedToken&nbsp;=&nbsp;generateFinishedToken(receiveFd,&nbsp;connection-&gt;id,&nbsp;connection-&gt;messageSeqNum);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_118_7314292" name="code" class="cpp" style="display: none;">finishedToken = generateFinishedToken(receiveFd, connection-&gt;id, connection-&gt;messageSeqNum);
</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数generateFinishedToken的定义如下：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 73749px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_119" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_119" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=119&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>jlong&nbsp;NativeInputQueue::generateFinishedToken(int32_t&nbsp;receiveFd,&nbsp;uint16_t&nbsp;connectionId,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint16_t&nbsp;messageSeqNum)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;(jlong(receiveFd)&nbsp;&lt;&lt;&nbsp;32)&nbsp;|&nbsp;(jlong(connectionId)&nbsp;&lt;&lt;&nbsp;16)&nbsp;|&nbsp;jlong(messageSeqNum);&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_119_520659" name="code" class="cpp" style="display: none;">jlong NativeInputQueue::generateFinishedToken(int32_t receiveFd, uint16_t connectionId,
        uint16_t messageSeqNum) {
    return (jlong(receiveFd) &lt;&lt; 32) | (jlong(connectionId) &lt;&lt; 16) | jlong(messageSeqNum);
}
</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;它的实现很简单，只是把receiveFd（前向管道的读端文件描述符）、connectionId（Client端的InputChannel对应的Connection对象在NativeInputQueue中的索引）和messageSeqNum（键盘消息的序列号）三个数值通过移位的方式编码在一个jlong值里面，即编码在上面的finishedToken参数里面。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;因此，在上面的finished函数里面，首先就是要对参数值finishedToken进行解码，把receiveFd、connectionId和messageSeqNum三个值分别取回来：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 74053px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_120" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_120" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=120&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>parseFinishedToken(finishedToken,&nbsp;&amp;receiveFd,&nbsp;&amp;connectionId,&nbsp;&amp;messageSeqNum);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_120_6202259" name="code" class="cpp" style="display: none;">parseFinishedToken(finishedToken, &amp;receiveFd, &amp;connectionId, &amp;messageSeqNum);</pre>&nbsp;&nbsp; &nbsp; &nbsp; parseFinishedToken的定义如下：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 74170px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_121" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_121" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=121&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;NativeInputQueue::parseFinishedToken(jlong&nbsp;finishedToken,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t*&nbsp;outReceiveFd,&nbsp;uint16_t*&nbsp;outConnectionId,&nbsp;uint16_t*&nbsp;outMessageIndex)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*outReceiveFd&nbsp;=&nbsp;int32_t(finishedToken&nbsp;&gt;&gt;&nbsp;32);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;*outConnectionId&nbsp;=&nbsp;uint16_t(finishedToken&nbsp;&gt;&gt;&nbsp;16);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*outMessageIndex&nbsp;=&nbsp;uint16_t(finishedToken);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_121_2407249" name="code" class="cpp" style="display: none;">void NativeInputQueue::parseFinishedToken(jlong finishedToken,
        int32_t* outReceiveFd, uint16_t* outConnectionId, uint16_t* outMessageIndex) {
    *outReceiveFd = int32_t(finishedToken &gt;&gt; 32);
    *outConnectionId = uint16_t(finishedToken &gt;&gt; 16);
    *outMessageIndex = uint16_t(finishedToken);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 有了这个receiveFd和connectionId之后，就可以把相应的Connection对象取回来了：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 74377px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_122" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_122" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=122&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;mConnectionsByReceiveFd.indexOfKey(receiveFd);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_122_6137003" name="code" class="cpp" style="display: none;">ssize_t connectionIndex = mConnectionsByReceiveFd.indexOfKey(receiveFd);
		......

sp&lt;Connection&gt; connection = mConnectionsByReceiveFd.valueAt(connectionIndex);</pre>&nbsp;&nbsp; &nbsp; &nbsp; 接下来就是调用这个connection对象中的inputConsumer对象来发送信号通知Server端的InputChannel，应用程序这一侧处理完刚才发生的键盘事件了：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 74574px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_123" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_123" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=123&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;status&nbsp;=&nbsp;connection-&gt;inputConsumer.sendFinishedSignal();&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_123_1295217" name="code" class="cpp" style="margin: 4px 0px; display: none; background-color: rgb(240, 240, 240);">status_t status = connection-&gt;inputConsumer.sendFinishedSignal();</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 39. InputConsumer.sendFinishedSignal</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/libs/ui/InputTransport.cpp文件中：<br></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 74731px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_124" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_124" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=124&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputConsumer::sendFinishedSignal()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;mChannel-&gt;sendSignal(INPUT_SIGNAL_FINISHED);&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_124_1121276" name="code" class="cpp" style="display: none;">status_t InputConsumer::sendFinishedSignal() {
	......

	return mChannel-&gt;sendSignal(INPUT_SIGNAL_FINISHED);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数的实现很简单，只是调用其内部对象mChannel的sendSignal函数来执行发送信号的通知。前面我们已经说过，这里的mChannel的类型为InputChannel，它是注册在应用程序一侧的Client端InputChannel，它的成员函数sendSignal的定义我们在上面的Step 20中已经分析过了，这里不再详述，不过，这里和上面Step 20不一样的地方是，它里的通知方向是从反向管道的写端（在应用程序这一侧）到反向管道的读端（在InputDispatcher这一侧）。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面我们在分析应用程序注册键盘消息接收通道的过程时，在Step 18（InputDispatcher.registerInputChannel）中，说到InputDispatcher把一个反向管道的读端文件描述符添加到WindowManagerService所运行的线程中的Looper对象中去，然后就会在这个反向管道的读端上睡眠等待有这个管道有新的内容可读。现在，InputConsumer往这个反向管道写入新的内容了，于是，InputDispatcher就被唤醒过来了，唤醒过来后，它所调用的函数是InputDispatcher.handleReceiveCallback函数，这与前面的Step 21的逻辑是一样的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 40. InputDispatcher.handleReceiveCallack</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：<br></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 75274px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_125" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_125" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=125&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;InputDispatcher::handleReceiveCallback(</span><span class="datatypes">int</span><span>&nbsp;receiveFd,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;events,&nbsp;</span><span class="keyword">void</span><span>*&nbsp;data)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;InputDispatcher*&nbsp;d&nbsp;=&nbsp;<span class="keyword">static_cast</span><span>&lt;InputDispatcher*&gt;(data);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(d-&gt;mLock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;d-&gt;mConnectionsByReceiveFd.indexOfKey(receiveFd);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsecs_t&nbsp;currentTime&nbsp;=&nbsp;now();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;d-&gt;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;connection-&gt;inputPublisher.receiveFinishedSignal();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(status)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;</span><span class="comment">//&nbsp;remove&nbsp;the&nbsp;callback</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d-&gt;finishDispatchCycleLocked(currentTime,&nbsp;connection);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;1;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_125_9103389" name="code" class="cpp" style="display: none;">int InputDispatcher::handleReceiveCallback(int receiveFd, int events, void* data) {
	InputDispatcher* d = static_cast&lt;InputDispatcher*&gt;(data);

	{ // acquire lock
		AutoMutex _l(d-&gt;mLock);

		ssize_t connectionIndex = d-&gt;mConnectionsByReceiveFd.indexOfKey(receiveFd);
		......

		nsecs_t currentTime = now();

		sp&lt;Connection&gt; connection = d-&gt;mConnectionsByReceiveFd.valueAt(connectionIndex);
		......

		status_t status = connection-&gt;inputPublisher.receiveFinishedSignal();
		if (status) {
			......
			return 0; // remove the callback
		}

		d-&gt;finishDispatchCycleLocked(currentTime, connection);
		......

		return 1;
	} // release lock
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先是通过传进来的receiveFd参数（反向管道的读端文件描述符）的值取得相应的Connection对象：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 75885px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_126" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_126" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=126&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;d-&gt;mConnectionsByReceiveFd.indexOfKey(receiveFd);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;d-&gt;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_126_5897806" name="code" class="cpp" style="display: none;">ssize_t connectionIndex = d-&gt;mConnectionsByReceiveFd.indexOfKey(receiveFd);
     ......

sp&lt;Connection&gt; connection = d-&gt;mConnectionsByReceiveFd.valueAt(connectionIndex);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;然后通过调用这个connection对象的内部对象inputPublisher的receiveFinishedSignal函数来确认是否真的收到键盘事件处理完成的信号，确认之后，就会调用InputDispatcher对象d的finishDispatchCycleLocked函数来执行一些善后工作。下面我们就依次分析这两个过程。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 41. InputPublisher.receiverFinishedSignal</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputTransport.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 76188px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_127" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_127" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=127&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputPublisher::receiveFinishedSignal()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;....&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">char</span><span>&nbsp;signal;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;result&nbsp;=&nbsp;mChannel-&gt;receiveSignal(&amp;&nbsp;signal);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(result)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;result;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(signal&nbsp;!=&nbsp;INPUT_SIGNAL_FINISHED)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;UNKNOWN_ERROR;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_127_3531255" name="code" class="cpp" style="display: none;">status_t InputPublisher::receiveFinishedSignal() {
    ....

    char signal;
    status_t result = mChannel-&gt;receiveSignal(&amp; signal);
    if (result) {
        return result;
    }
    if (signal != INPUT_SIGNAL_FINISHED) {
        .......
        return UNKNOWN_ERROR;
    }
    return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的逻辑和前面的Step 22中NativeInputQueue确认是否真的收到键盘事件分发的信号的逻辑是一致的，都是通过InputChannel的receiveSignal函数来确认是否在管道中收到了某一个约定的字符值，不过，这里约定的字符值为INPUT_SIGNAL_FINISHED。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到前面的Step 40中，确认了是真的收到了键盘事件处理完成的信号后，就调用InputDispatcher的finishDispatchCycleLocked函数来执行一些善后工作了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 42. InputDispatcher.finishDispatchCycleLocked<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 76723px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_128" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_128" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=128&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;InputDispatcher::finishDispatchCycleLocked(nsecs_t&nbsp;currentTime,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;sp&lt;Connection&gt;&amp;&nbsp;connection)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Notify&nbsp;other&nbsp;system&nbsp;components.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;onDispatchCycleFinishedLocked(currentTime,&nbsp;connection);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Reset&nbsp;the&nbsp;publisher&nbsp;since&nbsp;the&nbsp;event&nbsp;has&nbsp;been&nbsp;consumed.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;We&nbsp;do&nbsp;this&nbsp;now&nbsp;so&nbsp;that&nbsp;the&nbsp;publisher&nbsp;can&nbsp;release&nbsp;some&nbsp;of&nbsp;its&nbsp;internal&nbsp;resources</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;while&nbsp;waiting&nbsp;for&nbsp;the&nbsp;next&nbsp;dispatch&nbsp;cycle&nbsp;to&nbsp;begin.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;connection-&gt;inputPublisher.reset();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;startNextDispatchCycleLocked(currentTime,&nbsp;connection);&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_128_641316" name="code" class="cpp" style="display: none;">void InputDispatcher::finishDispatchCycleLocked(nsecs_t currentTime,
		const sp&lt;Connection&gt;&amp; connection) {
	......

	// Notify other system components.
	onDispatchCycleFinishedLocked(currentTime, connection);

	// Reset the publisher since the event has been consumed.
	// We do this now so that the publisher can release some of its internal resources
	// while waiting for the next dispatch cycle to begin.
	status_t status = connection-&gt;inputPublisher.reset();
	......

	startNextDispatchCycleLocked(currentTime, connection);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数主要就是做了三件事情：<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 一是通知其它系统，InputDispatcher完成了一次键盘事件的处理：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 77132px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_129" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_129" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=129&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;Notify&nbsp;other&nbsp;system&nbsp;components.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>onDispatchCycleFinishedLocked(currentTime,&nbsp;connection);&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_129_3847682" name="code" class="cpp" style="display: none;">// Notify other system components.
onDispatchCycleFinishedLocked(currentTime, connection);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;二是调用相应的connection对象的内部对象inputPublisher来的reset函数来回收一些资源，它里面其实就是释放前面在Step 18（InputPublisher.publishKeyEvent）使用的匿名共享内存了：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 77293px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_130" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_130" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=130&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;Reset&nbsp;the&nbsp;publisher&nbsp;since&nbsp;the&nbsp;event&nbsp;has&nbsp;been&nbsp;consumed.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;We&nbsp;do&nbsp;this&nbsp;now&nbsp;so&nbsp;that&nbsp;the&nbsp;publisher&nbsp;can&nbsp;release&nbsp;some&nbsp;of&nbsp;its&nbsp;internal&nbsp;resources</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//&nbsp;while&nbsp;waiting&nbsp;for&nbsp;the&nbsp;next&nbsp;dispatch&nbsp;cycle&nbsp;to&nbsp;begin.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>status_t&nbsp;status&nbsp;=&nbsp;connection-&gt;inputPublisher.reset();&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_130_7054048" name="code" class="cpp" style="display: none;">// Reset the publisher since the event has been consumed.
// We do this now so that the publisher can release some of its internal resources
// while waiting for the next dispatch cycle to begin.
status_t status = connection-&gt;inputPublisher.reset();</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;三是调用InputDispatcher的startNextDispatchCycleLocked函数来处理下一个键盘事件：<p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 77464px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_131" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_131" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=131&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>startNextDispatchCycleLocked(currentTime,&nbsp;connection);&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_131_3292057" name="code" class="cpp" style="margin: 4px 0px; display: none; background-color: rgb(240, 240, 240);">startNextDispatchCycleLocked(currentTime, connection);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;因为正在处理当前这个键盘事件的时候，很有可能又同时发生了其它的键盘事件，因此，这里InputDispatcher还不能停下来，需要继续调用startNextDispatchCycleLocked继续处理键盘事件，不过下一个键盘事件的处理过程和我们现在分析的过程就是一样的了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;至此，InputManager分发键盘消息给应用程序的过程就分析完成了，这是一个比较复杂的过程，不过，只要我们抓住主要的线索，就不难理解了，现在我们就小结一下这个过程的四个主要线索：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;A. 键盘事件发生，InputManager中的InputReader被唤醒，此前InputReader睡眠在/dev/input/event0这个设备文件上；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;B.&nbsp;InputReader被唤醒后，它接着唤醒InputManager中的InputDispatcher，此前InputDispatcher睡眠在InputManager所运行的线程中的Looper对象里面的管道的读端上；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;C. InputDispatcher被唤醒后，它接着唤醒应用程序的主线程来处理这个键盘事件，此前应用程序的主线程睡眠在Client端InputChannel中的前向管道的读端上；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;D. 应用程序处理处理键盘事件之后，它接着唤醒InputDispatcher来执行善后工作，此前InputDispatcher睡眠在Server端InputChannel的反向管道的读端上，注意这里与第二个线索处的区别。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;4.&nbsp;应用程序注销键盘消息接收通道的过程分析<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当Activity窗口创建时，它会向InputManager注册键盘消息接收通道，而当Activity窗口销毁时，它就会向InputManager注销前面注册的键盘消息接收通道了，本节内容就来看看应用程序注销键盘消息接收通道的过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当我们按下键盘上的Back键时，当前激活的Activity窗口就会被失去焦点，但是这时候它还没有被销毁，它的状态被设置为Stopped；当新的Activity窗口即将要显示时，它会通知WindowManagerService，这时候WindowManagerService就会处理当前处理Stopped状态的Activity窗口了，要执行的操作就是销毁它们了，在销毁的时候，就会注销它们之前所注册的键盘消息接收通道。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;新的Activity窗口通知WindowManagerService它即将要显示的过程比较复杂，但是它与我们本节要介绍的内容不是很相关，因此，这里就略过大部过程了，我们从ActvitiyRecord的windowsVisible函数开始分析。注意，这里的ActivityRecord是新的Activity窗口在ActivityManangerService的代表，而那些处于Stopped状态的Activity窗口</p><p>会放在ActivityStack类的一个等待可见的mWaitingVisibleActivities列表里面，事实于，对于那些Stopped状态的Activity窗口来说，它们是等待销毁，而不是等待可见。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;像前面一样，我们先来看一张应用程序注销键盘消息接收通道的过程的序列图，然后根据这个序列图来详细分析互一个步骤：</p><p><img width="710" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/0_1319373166rRrp.gif" alt=""><br></p><p style="text-align: center;"><a target="_blank" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/0_1319373166rRrp.gif">点击查看大图</a></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. ActivityRecord.windowsVisible</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/am/ActivityRecord.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 79034px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_132" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_132" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=132&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">class</span><span>&nbsp;ActivityRecord&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IApplicationToken.Stub&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;nowVisible;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;is&nbsp;this&nbsp;activity's&nbsp;window&nbsp;visible?</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;idle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;has&nbsp;the&nbsp;activity&nbsp;gone&nbsp;idle?</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;windowsVisible()&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>(service)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!nowVisible)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nowVisible&nbsp;=&nbsp;<span class="keyword">true</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!idle)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;this&nbsp;activity&nbsp;was&nbsp;already&nbsp;idle,&nbsp;then&nbsp;we&nbsp;now&nbsp;need&nbsp;to</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;make&nbsp;sure&nbsp;we&nbsp;perform&nbsp;the&nbsp;full&nbsp;stop&nbsp;of&nbsp;any&nbsp;activities</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;that&nbsp;are&nbsp;waiting&nbsp;to&nbsp;do&nbsp;so.&nbsp;&nbsp;This&nbsp;is&nbsp;because&nbsp;we&nbsp;won't</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;do&nbsp;that&nbsp;while&nbsp;they&nbsp;are&nbsp;still&nbsp;waiting&nbsp;for&nbsp;this&nbsp;one&nbsp;to</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;become&nbsp;visible.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;N&nbsp;=&nbsp;stack.mWaitingVisibleActivities.size();&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(N&nbsp;&gt;&nbsp;</span><span class="number">0</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="keyword">int</span><span>&nbsp;i=</span><span class="number">0</span><span>;&nbsp;i&lt;N;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ActivityRecord&nbsp;r&nbsp;=&nbsp;(ActivityRecord)&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.mWaitingVisibleActivities.get(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.waitingVisible&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.mWaitingVisibleActivities.clear();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message&nbsp;msg&nbsp;=&nbsp;Message.obtain();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg.what&nbsp;=&nbsp;ActivityStack.IDLE_NOW_MSG;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.mHandler.sendMessage(msg);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_132_5942016" name="code" class="java" style="display: none;">class ActivityRecord extends IApplicationToken.Stub {
	......
	boolean nowVisible;     // is this activity's window visible?
	boolean idle;           // has the activity gone idle?
	......


	public void windowsVisible() {
		synchronized(service) {
			......

			if (!nowVisible) {
				nowVisible = true;
				if (!idle) {
					.......
				} else {
					// If this activity was already idle, then we now need to
					// make sure we perform the full stop of any activities
					// that are waiting to do so.  This is because we won't
					// do that while they are still waiting for this one to
					// become visible.
					final int N = stack.mWaitingVisibleActivities.size();
					if (N &gt; 0) {
						for (int i=0; i&lt;N; i++) {
							ActivityRecord r = (ActivityRecord)
								stack.mWaitingVisibleActivities.get(i);
							r.waitingVisible = false;
							......
						}
						stack.mWaitingVisibleActivities.clear();

						Message msg = Message.obtain();
						msg.what = ActivityStack.IDLE_NOW_MSG;
						stack.mHandler.sendMessage(msg);

					}
				}
				......
			}
		}
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;应用程序中的每一个Activity在ActivityManagerService都有一个代表ActivityRecord，它们以堆栈的形式组织在ActivityManaerService中的ActivityStack中。一个即将要显示，但是还没有显示的Activity，它在ActivityManagerService中的ActivityRecord的成员变量nowVisible为false，而成员变量idle为ture，表示这个即将要显示的Activity窗口处于空闲状态。因此，在上面的这个函数中，会执行下面的语句：<p></p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 80003px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_133" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_133" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=133&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;N&nbsp;=&nbsp;stack.mWaitingVisibleActivities.size();&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">if</span><span>&nbsp;(N&nbsp;&gt;&nbsp;</span><span class="number">0</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="keyword">int</span><span>&nbsp;i=</span><span class="number">0</span><span>;&nbsp;i&lt;N;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ActivityRecord&nbsp;r&nbsp;=&nbsp;(ActivityRecord)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.mWaitingVisibleActivities.get(i);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.waitingVisible&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;stack.mWaitingVisibleActivities.clear();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;Message&nbsp;msg&nbsp;=&nbsp;Message.obtain();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;msg.what&nbsp;=&nbsp;ActivityStack.IDLE_NOW_MSG;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;stack.mHandler.sendMessage(msg);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_133_3575465" name="code" class="java" style="display: none;">final int N = stack.mWaitingVisibleActivities.size();
if (N &gt; 0) {
	for (int i=0; i&lt;N; i++) {
		ActivityRecord r = (ActivityRecord)
		stack.mWaitingVisibleActivities.get(i);
		r.waitingVisible = false;
		......
	}
	stack.mWaitingVisibleActivities.clear();

	Message msg = Message.obtain();
	msg.what = ActivityStack.IDLE_NOW_MSG;
	stack.mHandler.sendMessage(msg);

}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面我们说过，当用户按下键盘上的Back键时，当前激活的Activity记录就被放在ActivityStack对象stack的成员变量mWaitingVisibleActivities中了，这时候就要对它进行处理了。首先是将它们的Activity记录的waitingVisible设置为false，然后就把它们从ActivityStack对象stack的成员变量mWaitingVisibleActivities清空，最后向ActivityStack对象stack发送一个ActivityStack.IDLE_NOW_MSG消息。这个消息最终是由ActivityStack类的activityIdleInternal函数来处理的。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2. ActivityStack.activityIdleInternal</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/am/ActivityStack.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 80556px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_134" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_134" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=134&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ActivityStack&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;activityIdleInternal(IBinder&nbsp;token,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;fromTimeout,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configuration&nbsp;config)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&lt;ActivityRecord&gt;&nbsp;stops&nbsp;=&nbsp;<span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;NS&nbsp;=&nbsp;</span><span class="number">0</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(mService)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Atomically&nbsp;retrieve&nbsp;all&nbsp;of&nbsp;the&nbsp;other&nbsp;things&nbsp;to&nbsp;do.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stops&nbsp;=&nbsp;processStoppingActivitiesLocked(<span class="keyword">true</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NS&nbsp;=&nbsp;stops&nbsp;!=&nbsp;<span class="keyword">null</span><span>&nbsp;?&nbsp;stops.size()&nbsp;:&nbsp;</span><span class="number">0</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Stop&nbsp;any&nbsp;activities&nbsp;that&nbsp;are&nbsp;scheduled&nbsp;to&nbsp;do&nbsp;so&nbsp;but&nbsp;have&nbsp;been</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;waiting&nbsp;for&nbsp;the&nbsp;next&nbsp;one&nbsp;to&nbsp;start.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(i=</span><span class="number">0</span><span>;&nbsp;i&lt;NS;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ActivityRecord&nbsp;r&nbsp;=&nbsp;(ActivityRecord)stops.get(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(mService)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r.finishing)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finishCurrentActivityLocked(r,&nbsp;FINISH_IMMEDIATELY);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_134_893270" name="code" class="java" style="display: none;">public class ActivityStack {
	......

	final void activityIdleInternal(IBinder token, boolean fromTimeout,
			Configuration config) {
		......

		ArrayList&lt;ActivityRecord&gt; stops = null;
		......

		int NS = 0;
		......

		synchronized (mService) {
			......

			// Atomically retrieve all of the other things to do.
			stops = processStoppingActivitiesLocked(true);
			NS = stops != null ? stops.size() : 0;
			......
		}

		int i;

		......

		// Stop any activities that are scheduled to do so but have been
		// waiting for the next one to start.
		for (i=0; i&lt;NS; i++) {
			ActivityRecord r = (ActivityRecord)stops.get(i);
			synchronized (mService) {
				if (r.finishing) {
					finishCurrentActivityLocked(r, FINISH_IMMEDIATELY);
				} else {
					......
				}
			}
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先会调用processStoppingActivitiesLocked函数把所有处于Stopped状态的Activity取回来，然后逐个分析它们，如果它们的ActivityRecord中的finishing成员变量为true，就说明这个Activity需要销毁了，于是，就调用finishCurrentActivityLocked函数来销毁它们。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3.&nbsp;ActivityStack.finishCurrentActivityLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/am/ActivityStack.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 81583px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_135" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_135" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=135&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ActivityStack&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;ActivityRecord&nbsp;finishCurrentActivityLocked(ActivityRecord&nbsp;r,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;mode)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;finishCurrentActivityLocked(r,&nbsp;index,&nbsp;mode);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;ActivityRecord&nbsp;finishCurrentActivityLocked(ActivityRecord&nbsp;r,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;index,&nbsp;</span><span class="keyword">int</span><span>&nbsp;mode)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;make&nbsp;sure&nbsp;the&nbsp;record&nbsp;is&nbsp;cleaned&nbsp;out&nbsp;of&nbsp;other&nbsp;places.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mStoppingActivities.remove(r);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mWaitingVisibleActivities.remove(r);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;ActivityState&nbsp;prevState&nbsp;=&nbsp;r.state;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.state&nbsp;=&nbsp;ActivityState.FINISHING;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mode&nbsp;==&nbsp;FINISH_IMMEDIATELY&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;prevState&nbsp;==&nbsp;ActivityState.STOPPED&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;prevState&nbsp;==&nbsp;ActivityState.INITIALIZING)&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;If&nbsp;this&nbsp;activity&nbsp;is&nbsp;already&nbsp;stopped,&nbsp;we&nbsp;can&nbsp;just&nbsp;finish</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;it&nbsp;right&nbsp;now.</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;destroyActivityLocked(r,&nbsp;</span><span class="keyword">true</span><span>)&nbsp;?&nbsp;</span><span class="keyword">null</span><span>&nbsp;:&nbsp;r;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;r;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_135_8559737" name="code" class="java" style="display: none;">public class ActivityStack {
	......

	private final ActivityRecord finishCurrentActivityLocked(ActivityRecord r,
			int mode) {
		......

		return finishCurrentActivityLocked(r, index, mode);
	}

	private final ActivityRecord finishCurrentActivityLocked(ActivityRecord r,
			int index, int mode) {
		......

		// make sure the record is cleaned out of other places.
		mStoppingActivities.remove(r);
		mWaitingVisibleActivities.remove(r);
		......

		final ActivityState prevState = r.state;
		r.state = ActivityState.FINISHING;

		if (mode == FINISH_IMMEDIATELY
			|| prevState == ActivityState.STOPPED
			|| prevState == ActivityState.INITIALIZING) {
			// If this activity is already stopped, we can just finish
			// it right now.
			return destroyActivityLocked(r, true) ? null : r;
		} else {
			......
		}

		return r;
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从上面的Step 2中传进来的参数mode为FINISH_IMMEDIATELY，并且这个即将要被销毁的Activity的状态为Stopped，因此，接下来就会调用destroyActivityLocked函数来销毁它。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 4.&nbsp;ActivityStack.destroyActivityLocked</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/am/ActivityStack.java文件中：</p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 82458px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_136" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_136" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=136&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ActivityStack&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;destroyActivityLocked(ActivityRecord&nbsp;r,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;removeFromApp)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span><span>&nbsp;removedFromHistory&nbsp;=&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;hadApp&nbsp;=&nbsp;r.app&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(hadApp)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.app.thread.scheduleDestroyActivity(r,&nbsp;r.finishing,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.configChangeFlags);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;removedFromHistory;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_136_4208320" name="code" class="java" style="display: none;">public class ActivityStack {
	......

	final boolean destroyActivityLocked(ActivityRecord r,
			boolean removeFromApp) {
		......

		boolean removedFromHistory = false;

		......

		final boolean hadApp = r.app != null;

		if (hadApp) {
			......

			try {
				......
				r.app.thread.scheduleDestroyActivity(r, r.finishing,
					r.configChangeFlags);
			} catch (Exception e) {
				......
			}

			......
		} else {
			......
		}

		......

		return removedFromHistory;
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 在前面一篇文章<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>中，我们说到，每一个应用程序进程在ActivityManagerService中，都ProcessRecord记录与之对应，而每一个Activity，都是运行在一个进程上下文中，因此，在ActivityManagerService中，每一个ActivityRecord的app成员变量都应该指向一个ProcessRecord记录，于是，这里得到的hadApp为true。在ProcessRecord类中，有一个成员变量thread，它的类型为IApplicationThread。在文章<a target="_blank" href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>中，我们也曾经说过，每一个应用程序在启动的时候，它都会在内部创建一个ActivityThread对象，而在这个ActivityThread对象中，有一个成员变量mAppThread，它的类型为ApplicationThread，这是一个Binder对象，专门用来负责在应用程序和ActivityManagerService之间执行进程间通信工作的。应用程序在启动的时候，就会将这个Binder对象传递给ActivityManagerService，而ActivityManagerService就会把它保存在相应的ProcessRecord记录的thread成员变量中。因此，ProcessRecord记录的thread成员变量其实就是ApplicationThread对象的远程接口，于是，执行下面这个语句的时候：<p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 83439px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_137" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_137" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=137&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>r.app.thread.scheduleDestroyActivity(r,&nbsp;r.finishing,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;r.configChangeFlags);&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_137_446329" name="code" class="java" style="display: none;">r.app.thread.scheduleDestroyActivity(r, r.finishing,
	r.configChangeFlags);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;就会进入到ApplicationThread类中的scheduleDestroyActivity函数来。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 5.&nbsp;ApplicationThread.scheduleDestroyActivity</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/app/ActivityThread.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 83654px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_138" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_138" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=138&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ActivityThread&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ApplicationThread&nbsp;</span><span class="keyword">extends</span><span>&nbsp;ApplicationThreadNative&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;scheduleDestroyActivity(IBinder&nbsp;token,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;finishing,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;configChanges)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queueOrSendMessage(H.DESTROY_ACTIVITY,&nbsp;token,&nbsp;finishing&nbsp;?&nbsp;<span class="number">1</span><span>&nbsp;:&nbsp;</span><span class="number">0</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configChanges);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_138_5255878" name="code" class="java" style="display: none;">public final class ActivityThread {
	......

	private final class ApplicationThread extends ApplicationThreadNative {
		......

		public final void scheduleDestroyActivity(IBinder token, boolean finishing,
				int configChanges) {

			queueOrSendMessage(H.DESTROY_ACTIVITY, token, finishing ? 1 : 0,
					configChanges);
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数调用外部类ActivityThread的queueOrSendMessage函数来往应用程序的消息队列中发送一个H.DESTROY_ACTIVITY消息，这个消息最终由ActivityThread类的handleDestroyActivity函数来处理。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 6.&nbsp;ActivityThread.handleDestroyActivity</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/app/ActivityThread.java文件中：</p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 84187px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_139" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_139" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=139&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ActivityThread&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;handleDestroyActivity(IBinder&nbsp;token,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;finishing,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;configChanges,&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;getNonConfigInstance)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ActivityClientRecord&nbsp;r&nbsp;=&nbsp;performDestroyActivity(token,&nbsp;finishing,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configChanges,&nbsp;getNonConfigInstance);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowManager&nbsp;wm&nbsp;=&nbsp;r.activity.getWindowManager();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View&nbsp;v&nbsp;=&nbsp;r.activity.mDecor;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(v&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r.activity.mWindowAdded)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wm.removeViewImmediate(v);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_139_381072" name="code" class="java" style="display: none;">public final class ActivityThread {
	......

	private final void handleDestroyActivity(IBinder token, boolean finishing,
			int configChanges, boolean getNonConfigInstance) {
		......

		ActivityClientRecord r = performDestroyActivity(token, finishing,
			configChanges, getNonConfigInstance);
		if (r != null) {
			WindowManager wm = r.activity.getWindowManager();
			View v = r.activity.mDecor;
			if (v != null) {
				......

				if (r.activity.mWindowAdded) {
					wm.removeViewImmediate(v);
				}
				
				......
			}
			......
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里首先调用performDestroyActivity来执行一些销毁Activity的操作，期间就会调用Activity的onDestroy函数让Activity本身有机会执行一些销毁前的工作了。这里通过r.activity.getWindowManager函数返回的是一个LocalWindowManager对象，而通过r.activity.mDecor得到的是一个DecorView对象，这些都是在Activity启动的时候设置好的。函数最后调用LocalWindowManager对象wm的removeViewImmediate函员来从LocalWindowManager移除这个DecorView对象。<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 7.&nbsp;LocalWindowManager.removeViewImmediate</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/Window.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 84992px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_140" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_140" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=140&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">abstract</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Window&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;LocalWindowManager&nbsp;</span><span class="keyword">implements</span><span>&nbsp;WindowManager&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;removeViewImmediate(View&nbsp;view)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mWindowManager.removeViewImmediate(view);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;WindowManager&nbsp;mWindowManager;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_140_2158979" name="code" class="java" style="display: none;">public abstract class Window {
	......

	private class LocalWindowManager implements WindowManager {
		......

		public final void removeViewImmediate(View view) {
			mWindowManager.removeViewImmediate(view);
		}

		......

		private final WindowManager mWindowManager;
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;LocalWindowManager类的成员变量mWindowManager是一个WndowManagerImpl对象，这个函数只是简单地调用WndowManagerImpl类的removeViewImmediate来进一步处理。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 8.&nbsp;WndowManagerImpl.removeViewImmediate</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/core/java/android/view/WindowManagerImpl.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 85503px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_141" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_141" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=141&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerImpl&nbsp;</span><span class="keyword">implements</span><span>&nbsp;WindowManager&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;removeViewImmediate(View&nbsp;view)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(</span><span class="keyword">this</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">int</span><span>&nbsp;index&nbsp;=&nbsp;findViewLocked(view,&nbsp;</span><span class="keyword">true</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ViewRoot&nbsp;root&nbsp;=&nbsp;mRoots[index];&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.die(<span class="keyword">true</span><span>);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_141_9792427" name="code" class="java" style="display: none;">public class WindowManagerImpl implements WindowManager {
	......

	public void removeViewImmediate(View view) {
		synchronized (this) {
			int index = findViewLocked(view, true);
			ViewRoot root = mRoots[index];
			......

			root.die(true);
			
			......
		}
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数首先是找到这个view所属的ViewRoot对象root，然后调用这个root对象的die函数来销毁它。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 9. ViewRoot.die</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 85988px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_142" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_142" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=142&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;die(</span><span class="keyword">boolean</span><span>&nbsp;immediate)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(immediate)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doDie();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_142_2998794" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	public void die(boolean immediate) {
		if (immediate) {
			doDie();
		} else {
			......
		}
	}
	
	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;上面Step 8传进来的immediate参数为true，因此，这里直接调用doDie函数来进一步处理。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 10.&nbsp;ViewRoot.doDie</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 86431px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_143" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_143" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=143&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">void</span><span>&nbsp;doDie()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(</span><span class="keyword">this</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mAdded)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mAdded&nbsp;=&nbsp;<span class="keyword">false</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatchDetachedFromWindow();&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_143_8157007" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	void doDie() {
		......

		synchronized (this) {
			......

			if (mAdded) {
				mAdded = false;
				dispatchDetachedFromWindow();
			}
		}
	}
	
	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当我们把Activity窗口中的View添加到一个ViewRoot对象时，就会把它的成员变量mAdded设置为true，这样就表示这个ViewRoot中有View存在，于是，这里就会调用dispatchDetachedFromWindow函数来进一步处理。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 11.&nbsp;ViewRoot.ispatchDetachedFromWindow</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/ViewRoot.java文件中：</p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 86976px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_144" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_144" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=144&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ViewRoot&nbsp;</span><span class="keyword">extends</span><span>&nbsp;Handler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ViewParent,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View.AttachInfo.Callbacks&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">void</span><span>&nbsp;dispatchDetachedFromWindow()&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInputChannel&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInputQueueCallback&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputQueue.unregisterInputChannel(mInputChannel);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sWindowSession.remove(mWindow);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(RemoteException&nbsp;e)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_144_9727170" name="code" class="java" style="display: none;">public final class ViewRoot extends Handler implements ViewParent,
		View.AttachInfo.Callbacks {
	......

	void dispatchDetachedFromWindow() {
		......

		if (mInputChannel != null) {
			if (mInputQueueCallback != null) {
				......
			} else {
				InputQueue.unregisterInputChannel(mInputChannel);
			}
		}

		try {
			sWindowSession.remove(mWindow);
		} catch (RemoteException e) {
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面在介绍应用程序注册键盘消息接收通道的过程时，在Step 18，我们说到，ViewRoot类中的mInputQueueCallback为null，表示由这个ViewRoot自己来管理键盘输入事件，因此，这里首先会调用InputQueue的unregisterInputChannel函数来注销注册在应用程序这一侧的Client端InputChannel，然后再调用sWindowSession的remove函数来注销注册在InputManager这一侧的Server端InputChannel，这个逻辑是和前面介绍应用程序注册键盘消息接收通道的逻辑相对应的，前面分别注册了这两个InputChannel，现在Activity要销毁了，当然就要把它们注销了。<p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们先来看注销注册在应用程序这一侧的Client端InputChannel，然后再回过头来分析注销注册在InputManager这一侧的Server端InputChannel。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 12.&nbsp;InputQueue.unregisterInputChannel</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/java/android/view/InputQueue.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 87791px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_145" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_145" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=145&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputQueue&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;unregisterInputChannel(InputChannel&nbsp;inputChannel)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>&nbsp;(sLock)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nativeUnregisterInputChannel(inputChannel);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_145_4885385" name="code" class="java" style="display: none;">public final class InputQueue {
	......

	public static void unregisterInputChannel(InputChannel inputChannel) {
		......

		synchronized (sLock) {
			......

			nativeUnregisterInputChannel(inputChannel);
		}
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数只是简单地调用本地方法nativeUnregisterInputChannel来执行具体的操作。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 13.&nbsp;InputQueue.nativeUnregisterInputChannel<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/core/jni/android_view_InputQueue.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 88238px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_146" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_146" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=146&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;android_view_InputQueue_nativeUnregisterInputChannel(JNIEnv*&nbsp;env,&nbsp;jclass&nbsp;clazz,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;inputChannelObj)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;gNativeInputQueue.unregisterInputChannel(env,&nbsp;inputChannelObj);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_146_4503701" name="code" class="cpp" style="display: none;">static void android_view_InputQueue_nativeUnregisterInputChannel(JNIEnv* env, jclass clazz,
		jobject inputChannelObj) {
	status_t status = gNativeInputQueue.unregisterInputChannel(env, inputChannelObj);

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里调用NativeInputQueue的成员函数unregisterInputChannel来进一步处理。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 14.&nbsp;NativeInputQueue.unregisterInputChannel<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/core/jni/android_view_InputQueue.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 88538px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_147" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_147" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=147&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;NativeInputQueue::unregisterInputChannel(JNIEnv*&nbsp;env,&nbsp;jobject&nbsp;inputChannelObj)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;InputChannel&gt;&nbsp;inputChannel&nbsp;=&nbsp;android_view_InputChannel_getInputChannel(env,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannelObj);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;getConnectionIndex(inputChannel);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mConnectionsByReceiveFd.removeItemsAt(connectionIndex);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection-&gt;status&nbsp;=&nbsp;Connection::STATUS_ZOMBIE;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection-&gt;looper-&gt;removeFd(inputChannel-&gt;getReceivePipeFd());&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env-&gt;DeleteGlobalRef(connection-&gt;inputHandlerObjGlobal);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection-&gt;inputHandlerObjGlobal&nbsp;=&nbsp;NULL;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_147_1298118" name="code" class="cpp" style="display: none;">status_t NativeInputQueue::unregisterInputChannel(JNIEnv* env, jobject inputChannelObj) {
	sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,
		inputChannelObj);
	......

	{ // acquire lock
		AutoMutex _l(mLock);

		ssize_t connectionIndex = getConnectionIndex(inputChannel);
		......

		sp&lt;Connection&gt; connection = mConnectionsByReceiveFd.valueAt(connectionIndex);
		mConnectionsByReceiveFd.removeItemsAt(connectionIndex);

		connection-&gt;status = Connection::STATUS_ZOMBIE;

		connection-&gt;looper-&gt;removeFd(inputChannel-&gt;getReceivePipeFd());

		env-&gt;DeleteGlobalRef(connection-&gt;inputHandlerObjGlobal);
		connection-&gt;inputHandlerObjGlobal = NULL;
		......
	} // release lock

	......
	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;真正的注销工作就是这里实现的了，读者可以对照前面介绍应用程序注册键盘消息接收通道过程中的Step 21（NativeInputQueue.registerInputChannel）来分析，它首先是将在之前创建的Connection对象从NativeInputQueue中的mConnectionByReceiveFd向量中删除：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 89190px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_148" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_148" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=148&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;getConnectionIndex(inputChannel);&nbsp;&nbsp;</span></span></li><li class=""><span>......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li><li class="alt"><span>mConnectionsByReceiveFd.removeItemsAt(connectionIndex);&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_148_883414" name="code" class="cpp" style="display: none;">ssize_t connectionIndex = getConnectionIndex(inputChannel);
......

sp&lt;Connection&gt; connection = mConnectionsByReceiveFd.valueAt(connectionIndex);
mConnectionsByReceiveFd.removeItemsAt(connectionIndex);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;然后再把这个Client端InputChannel的前向管道的读端文件描述符从应用程序主线程中的Looper对象中删除：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 89397px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_149" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_149" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=149&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>connection-&gt;looper-&gt;removeFd(inputChannel-&gt;getReceivePipeFd());&nbsp;&nbsp;</span></span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_149_5136555" name="code" class="cpp" style="display: none;">connection-&gt;looper-&gt;removeFd(inputChannel-&gt;getReceivePipeFd());</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这样，这个Activity窗口以后就不会接收到键盘事件了。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后将Connection对象中的回调对象inputHandlerOjbGlobal对象删除：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 89566px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_150" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_150" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=150&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>env-&gt;DeleteGlobalRef(connection-&gt;inputHandlerObjGlobal);&nbsp;&nbsp;</span></span></li><li class=""><span>connection-&gt;inputHandlerObjGlobal&nbsp;=&nbsp;NULL;&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_150_1930972" name="code" class="cpp" style="display: none;">env-&gt;DeleteGlobalRef(connection-&gt;inputHandlerObjGlobal);
connection-&gt;inputHandlerObjGlobal = NULL;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回忆一下前面我们在分析InputManager分发键盘消息给应用程序处理时，曾经说到，每当有键盘事件发生时，InputManager首先就会调用NativeInputQueue类的handleReceiveCallback函数。在这个handleReceiveCallback函数里面，NativeInputQueue会找到相应的Connection对象，然后把它里面的内部对象inputHandlerOjbGlobal作为参数来调用Java层的InputQueue类的dispatchKeyEvent函数来通知应用程序，有键盘事件发生了。在InputQueue类的dispatchKeyEvent函数里面，就是通过这个inputHandlerOjbGlobal对象来直正通知到当前激活的Activity窗口来处理这个键盘事件的。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;注册在应用程序这一侧的Client端InputChannel被注销以后，回到前面的Step 11中，我们继续分析注销注册在InputManager这一侧的Server端InputChannel。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 15. WindowManagerService.Session.remove</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "><span style="font-family:monospace;"><span style="white-space: pre;"><span style="font-family:Arial, Verdana, sans-serif;"><span style="white-space: normal;"></span></span></span></span></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 89977px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_151" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_151" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=151&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Session&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowSession.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;IBinder.DeathRecipient&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;remove(IWindow&nbsp;window)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removeWindow(<span class="keyword">this</span><span>,&nbsp;window);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_151_7089185" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	private final class Session extends IWindowSession.Stub
			implements IBinder.DeathRecipient {
		......

		public void remove(IWindow window) {
			removeWindow(this, window);
		}

		......
	}

	......
}</pre><p></p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数只是简单地调用其外部类WindowManagerService的removeWindow函数来进一步执行操作。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 16.&nbsp;WindowManagerService.removeWindow<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 90460px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_152" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_152" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=152&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;removeWindow(Session&nbsp;session,&nbsp;IWindow&nbsp;client)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">synchronized</span><span>(mWindowMap)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowState&nbsp;win&nbsp;=&nbsp;windowForClientLocked(session,&nbsp;client,&nbsp;<span class="keyword">false</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(win&nbsp;==&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removeWindowLocked(session,&nbsp;win);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_152_818940" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	public void removeWindow(Session session, IWindow client) {
		synchronized(mWindowMap) {
			WindowState win = windowForClientLocked(session, client, false);
			if (win == null) {
				return;
			}
			removeWindowLocked(session, win);
		}
	}

	......
}</pre><p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回忆一下前面我们在分析应用程序注册键盘消息管道的过程时，在Step 11（WindowManagerService.addWindow）中，WindowManagerService为这个即将要激活的Activity窗口创建了一个WindowState对象win，创建的时候，使用了从ViewRoot中传过来的两个参数，分别是一个Session对象session和一个IWindow对象client。&nbsp;</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 在这个函数中，ViewRoot传过来的两个参数session和client和上面说的两个参数是一致的，因此，这个函数首先通过参数session和client得到一个WindowState对象win，然后调用removeWindowLocked来把它从WindowManagerService删除。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 17.&nbsp;WindowManagerService.removeWindowLocked<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 91083px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_153" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_153" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=153&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;removeWindowLocked(Session&nbsp;session,&nbsp;WindowState&nbsp;win)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win.disposeInputChannel();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_153_2389103" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	public void removeWindowLocked(Session session, WindowState win) {
		......

		win.disposeInputChannel();

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们忽略了这个函数的其它逻辑，只关注注销之前注册的Server端InputChannel的逻辑，这里，注销的操作就是调用win的disposeInputChannel进行的了。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 18. WindowState.disposeInputChannel</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/WindowManagerService.java文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 91546px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_154" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_154" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=154&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowManagerService&nbsp;</span><span class="keyword">extends</span><span>&nbsp;IWindowManager.Stub&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">implements</span><span>&nbsp;Watchdog.Monitor&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">final</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;WindowState&nbsp;</span><span class="keyword">implements</span><span>&nbsp;WindowManagerPolicy.WindowState&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">void</span><span>&nbsp;disposeInputChannel()&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(mInputChannel&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputManager.unregisterInputChannel(mInputChannel);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputChannel.dispose();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mInputChannel&nbsp;=&nbsp;<span class="keyword">null</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_154_4167010" name="code" class="java" style="display: none;">public class WindowManagerService extends IWindowManager.Stub
		implements Watchdog.Monitor {
	......

	private final class WindowState implements WindowManagerPolicy.WindowState {
		......

		void disposeInputChannel() {
			if (mInputChannel != null) {
				mInputManager.unregisterInputChannel(mInputChannel);

				mInputChannel.dispose();
				mInputChannel = null;
			}
		}

		......
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;上面说到，在前面分析应用程序注册键盘消息管道的过程时，在Step 11（WindowManagerService.addWindow）中，为当前这个Activity窗口创建了一个WindowState对象，接着创建了一个输入管道后，把Server端的InputChannel保存了在这个WindowState对象的成员变量mInputChannel中，因此，这里，就可以把它取回来，然后调用mInputManager对象的unregisterInputChannel函数来把它注销掉了。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 19. InputManager.unregisterInputChannel</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/java/com/android/server/InputManager.java文件中：<br></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 816px; top: 92179px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_155" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_155" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=155&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;InputManager&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;unregisterInputChannel(InputChannel&nbsp;inputChannel)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nativeUnregisterInputChannel(inputChannel);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_155_8768816" name="code" class="java" style="display: none;">public class InputManager {
	......

	public void unregisterInputChannel(InputChannel inputChannel) {
		......

		nativeUnregisterInputChannel(inputChannel);
	}

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数很简单，它调用本地方法nativeUnregisterInputChannel来进一步处理。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 20.&nbsp;InputManager.nativeUnregisterInputChannel</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/services/jni/com_android_server_InputManager.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 92562px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_156" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_156" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=156&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;android_server_InputManager_nativeUnregisterInputChannel(JNIEnv*&nbsp;env,&nbsp;jclass&nbsp;clazz,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject&nbsp;inputChannelObj)&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;InputChannel&gt;&nbsp;inputChannel&nbsp;=&nbsp;android_view_InputChannel_getInputChannel(env,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputChannelObj);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;status_t&nbsp;status&nbsp;=&nbsp;gNativeInputManager-&gt;unregisterInputChannel(env,&nbsp;inputChannel);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_156_9466927" name="code" class="cpp" style="display: none;">static void android_server_InputManager_nativeUnregisterInputChannel(JNIEnv* env, jclass clazz,
		jobject inputChannelObj) {
	......


	sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,
						inputChannelObj);
	......


	status_t status = gNativeInputManager-&gt;unregisterInputChannel(env, inputChannel);

	......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数首先调用android_view_InputChannel_getInputChannel函数根据Java层的InputChannel对象找到C++层的InputChannel对象，然后调用NativeInputManager的unregisterInputChannel函数来执行注销的操作。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 21.&nbsp;NativeInputManager.unregisterInputChannel<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在frameworks/base/services/jni/com_android_server_InputManager.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 93032px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_157" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_157" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=157&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;NativeInputManager::unregisterInputChannel(JNIEnv*&nbsp;env,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const</span><span>&nbsp;sp&lt;InputChannel&gt;&amp;&nbsp;inputChannel)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;mInputManager-&gt;getDispatcher()-&gt;unregisterInputChannel(inputChannel);&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_157_4625141" name="code" class="cpp" style="display: none;">status_t NativeInputManager::unregisterInputChannel(JNIEnv* env,
		const sp&lt;InputChannel&gt;&amp; inputChannel) {
	......

	return mInputManager-&gt;getDispatcher()-&gt;unregisterInputChannel(inputChannel);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数与前面分析应用程序注册键盘消息通道的Step 17（NativeInputManager.registerInputChannel）相对应，主要是调用InputDispatcher对象的unregisterInputChannel函数来执行真正注销的操作。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 22.&nbsp;InputDispatcher.unregisterInputChannel<br>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/libs/ui/InputDispatcher.cpp文件中：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 93343px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_158" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_158" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=158&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>status_t&nbsp;InputDispatcher::unregisterInputChannel(</span><span class="keyword">const</span><span>&nbsp;sp&lt;InputChannel&gt;&amp;&nbsp;inputChannel)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="comment">//&nbsp;acquire&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMutex&nbsp;_l(mLock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;getConnectionIndexLocked(inputChannel);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mConnectionsByReceiveFd.removeItemsAt(connectionIndex);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mLooper-&gt;removeFd(inputChannel-&gt;getReceivePipeFd());&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="comment">//&nbsp;release&nbsp;lock</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;OK;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_158_5846640" name="code" class="cpp" style="display: none;">status_t InputDispatcher::unregisterInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel) {
	......

	{ // acquire lock
		AutoMutex _l(mLock);

		ssize_t connectionIndex = getConnectionIndexLocked(inputChannel);
		......

		sp&lt;Connection&gt; connection = mConnectionsByReceiveFd.valueAt(connectionIndex);
		mConnectionsByReceiveFd.removeItemsAt(connectionIndex);

		......

		mLooper-&gt;removeFd(inputChannel-&gt;getReceivePipeFd());

		.....

	} // release lock

	......

	return OK;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步与前面的Step 14注销应用程序一侧的Client端InputChannel是差不多的，只不过这里是从InputDispatcher中把Server端的InputChannel注销掉。首先是根据传进来的参数inputChannel找到它在InputDispatcher中对应的Connection对象在mConnectionsByReceiveFd中的索引，然后把它从mConnectionsByReceiveFd中删除：<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><a href="https://code.csdn.net/snippets/130143" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/CODE_ico.png" width="12" height="12" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;"></a><a href="https://code.csdn.net/snippets/130143/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ico_fork.svg" width="12" height="12" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;"></a><div style="position: absolute; left: 814px; top: 93985px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_159" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_159" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=159&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>ssize_t&nbsp;connectionIndex&nbsp;=&nbsp;getConnectionIndexLocked(inputChannel);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>sp&lt;Connection&gt;&nbsp;connection&nbsp;=&nbsp;mConnectionsByReceiveFd.valueAt(connectionIndex);&nbsp;&nbsp;</span></li><li class="alt"><span>mConnectionsByReceiveFd.removeItemsAt(connectionIndex);&nbsp;&nbsp;</span></li></ol></div><pre code_snippet_id="130143" snippet_file_name="blog_20131227_159_2084649" name="code" class="cpp" style="display: none;">ssize_t connectionIndex = getConnectionIndexLocked(inputChannel);
    ......

sp&lt;Connection&gt; connection = mConnectionsByReceiveFd.valueAt(connectionIndex);
mConnectionsByReceiveFd.removeItemsAt(connectionIndex);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后，还需要把这个InputChannel中的反向管道读端文件描述符从InputDispatcher的内部对象mLooper中删除，因为这个文件描述符是在前面注册Server端的InputChannel时加入到mLooper对象去的，具体可以参考上面分析应用程序注册键盘消息接收通道的过程中的Step 18（InputDispatcher.registerInputChannel）。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这样，&nbsp;应用程序注销键盘消息接收通道的过程就分析完成了，整个应用程序键盘消息处理机制也分析完成了，这是一个比较复杂的过程，要完全理解它还需要花费一些努力和时间，不过，理解了这个过程之后，对Android应用程序框架层的理解就更进一步了。</p><p style="text-align: center; margin: 4px 0px; padding: 2px 0px;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a target="_blank" href="http://weibo.com/shengyangluo">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br></p>
</div>




<!-- Baidu Button BEGIN -->

<div class="bdsharebuttonbox bdshare-button-style0-16" style="float: right;" data-bd-bind="1410331993042">
<a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="bds_more" data-cmd="more" style="background-position:0 0 !important; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=d754dcc0.png) !important"></a>
<a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间" style="background-position:0 -52px !important"></a>
<a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博" style="background-position:0 -104px !important"></a>
<a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博" style="background-position:0 -260px !important"></a>
<a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="bds_renren" data-cmd="renren" title="分享到人人网" style="background-position:0 -208px !important"></a>
<a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="bds_weixin" data-cmd="weixin" title="分享到微信" style="background-position:0 -1612px !important"></a>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script>
<!-- Baidu Button END -->

<!--192.168.100.35-->
<ul class="article_next_prev">
            <li class="prev_article"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_shangyipian&#39;]);location.href=&#39;/luoshengyang/article/details/6817933&#39;;">上一篇</span><a href="http://blog.csdn.net/luoshengyang/article/details/6817933" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_shangyipian&#39;])">Android应用程序消息处理机制（Looper、Handler）分析</a></li>
            <li class="next_article"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_xiayipian&#39;]);location.href=&#39;/luoshengyang/article/details/6905587&#39;;">下一篇</span><a href="http://blog.csdn.net/luoshengyang/article/details/6905587" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_xiayipian&#39;])">Android应用程序线程消息循环模型分析</a></li>
</ul>

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=1536434" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/bds_s_v2.js"></script>

<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->


        <div id="digg" articleid="6882903">
            <dl id="btnDigg" class="digg digg_disable">
                <dt onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_ding&#39;])">顶</dt>
                <dd>58</dd>
            </dl>
            <dl id="btnBury" class="digg digg_disable">
                <dt onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_cai&#39;])">踩</dt>
                <dd>1</dd>
            </dl>
        </div>
</div>
      <dl class="blog-associat-tag">
        <dt>主题推荐</dt>
        <dd>
                <a href="http://www.csdn.net/tag/android%E5%BA%94%E7%94%A8" target="_blank" class="blog-tage-red">android应用</a> 
                <a href="http://www.csdn.net/tag/optimization" target="_blank" class="blog-tage-red">optimization</a> 
                <a href="http://www.csdn.net/tag/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" class="blog-tage-red">操作系统</a> 
                <a href="http://www.csdn.net/tag/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A" target="_blank" class="blog-tage-red">新浪微博</a> 
                <a href="http://www.csdn.net/tag/%E6%BA%90%E4%BB%A3%E7%A0%81" target="_blank" class="blog-tage-red">源代码</a> 
        </dd>
    </dl> 


<dl class="blog-ass-articl tracking-ad" data-mod="popu_36" id="res-relatived"> 
     <dt><span>猜你在找</span></dt>    
<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/I2Cbus/article/details/21739261" title="Android如何完全调试framework层代码" strategy="CFRecommendAlgorithm" target="_blank">Android如何完全调试framework层代码</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/long19851105/article/details/5910050" title="用gdb和gdbserver调试android native code" strategy="CFRecommendAlgorithm" target="_blank">用gdb和gdbserver调试android native code</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/andycpp/article/details/8861549" title="“割绳子”的作者，你如此歧视、无视、鄙视中国人，这是何苦呢" strategy="CFRecommendAlgorithm" target="_blank">“割绳子”的作者，你如此歧视、无视、鄙视中国人，这是何苦呢</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/nie312122330/article/details/17993403" title="android仿win8 metro磁贴布局" strategy="CFRecommendAlgorithm" target="_blank">android仿win8 metro磁贴布局</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/voluptas/article/details/6339855" title="见过最好的git入门教程" strategy="CFRecommendAlgorithm" target="_blank">见过最好的git入门教程</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/mad1989/article/details/25071957" title="Android通过Runtime.getRuntime().exec实现Ping和Traceroute命令时readLine阻塞问题解决" strategy="CFRecommendAlgorithm" target="_blank">Android通过Runtime.getRuntime().exec实现Ping和Traceroute命令时readLine阻塞问题解决</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/fontlose/article/details/8241968" title="linux驱动学习之ioctl接口" strategy="CFRecommendAlgorithm" target="_blank">linux驱动学习之ioctl接口</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/oneRain88/article/details/7426121" title="Cocos2d-x学习（一）：HelloWorld" strategy="CFRecommendAlgorithm" target="_blank">Cocos2d-x学习（一）：HelloWorld</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/blueice8601/article/details/7666427" title="linux驱动面试题目汇总" strategy="CFRecommendAlgorithm" target="_blank">linux驱动面试题目汇总</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/verticallimit/article/details/24826009" title="自己选择的路、跪着也要走完" strategy="CFRecommendAlgorithm" target="_blank">自己选择的路、跪着也要走完</a></dd></dl>

<script type="text/javascript">
    var searchtitletags = 'Android应用程序键盘（Keyboard）消息处理机制分析' + ',' + 'android应用,optimization,操作系统,新浪微博,源代码';
    searchService({
        index: 'blog',
        query: searchtitletags,
        from: 10,
        size: 10,
        appendTo: '#res-relatived',
        url: 'recommend',
        his: 2,
        client: "blog_cf_enhance",
        tmpl: '<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="#{ url }" title="#{ title }" strategy="#{ strategy }">#{ title }</a></dd>'
    });

 </script>   


    <div id="ad_cen">
   
          <script type="text/javascript">
              new Ad(4, 'ad_cen');
          </script>
    <iframe id="ad_frm_0" frameborder="0" scrolling="no" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ad.html" style="border-width: 0px; overflow: hidden; width: 746px; height: 90px;"></iframe></div>
<div class="comment_class">
    <div id="comment_title" class="panel_head">
        <span class="see_comment">查看评论</span><a name="comments"></a></div>
    <div id="comment_list"><dl class="comment_item comment_topic" id="comment_item_4261779"><dt class="comment_head" floor="114">114楼 <span class="user"><a class="username" href="http://blog.csdn.net/zjq2008wd" target="_blank">Ron_Tang</a> <span class="ptime">昨天 16:09发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4261779" username="zjq2008wd"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zjq2008wd" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zjq2008wd.jpg" width="40" height="40"></a></dd><dd class="comment_body">您好，罗大哥，我是您书的读者。<br>阅读您书，可知InputChannel内含有管道，这个管道应该是WindowManagerService创建的，创建一对。Server InputChanel可以使用此管道可以理解，那应用程序主线程client端如何能够使用此管道呢？之前了解过，只有父子进程或兄弟进程能够共享文件描述符。<br>请教其中缘由，是因为binder介入吗？或是两个进程存在父子关系？<br>谢谢，期盼您的答复</dd><dl class="comment_item comment_reply" id="comment_item_4261991"><dt class="comment_head" floor="114">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">昨天 16:55发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4261991" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复zjq2008wd：是的，Binder IPC可以在进程间传递文件描述符，你可以看一下书里面6.5小节的内容。</dd><dl class="comment_item comment_reply" id="comment_item_4262139"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/zjq2008wd" target="_blank">Ron_Tang</a> <span class="ptime">昨天 17:40发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4262139" username="zjq2008wd"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zjq2008wd" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zjq2008wd.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复Luoshengyang：恩，好的，谢谢！</dd></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_3704171"><dt class="comment_head" floor="113">113楼 <span class="user"><a class="username" href="http://blog.csdn.net/rainmeterlinux" target="_blank">rainmeterLotus</a> <span class="ptime">2014-04-03 19:53发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3704171" username="rainmeterlinux"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/rainmeterlinux" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_rainmeterlinux.jpg" width="40" height="40"></a></dd><dd class="comment_body">在“InputManager分发键盘消息给应用程序过程分析”开始处的InputReader.pollOnce，InputReader中没有pollOnce方法啊，只有一个loopOnce!</dd><dl class="comment_item comment_reply" id="comment_item_4086407"><dt class="comment_head" floor="113">Re: <span class="user"><a class="username" href="http://blog.csdn.net/dr8737010" target="_blank">BadPattern</a> <span class="ptime">2014-07-26 18:16发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4086407" username="dr8737010"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/dr8737010" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_dr8737010.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复rainmeterlinux：安卓后来的代码键盘这块处理很多细节做了调整， 函数命名也变了，不过感觉大体思路还是这样</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_3616747"><dt class="comment_head" floor="112">112楼 <span class="user"><a class="username" href="http://blog.csdn.net/woaieillen" target="_blank">woaieillen</a> <span class="ptime">2014-03-20 09:05发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3616747" username="woaieillen"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/woaieillen" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_woaieillen.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师，请教一下，在浮动窗口中(如windowmanager)能否截获到键盘按键？<br>我想做一个可支持键盘按键、可支持浮动窗口的播放器，浮动播放时，可以响应键盘事件，同时也不影响后面acitiyt的生命周期。<br>能否分发按键时，优先响应浮动窗口，然后在继续往下传递？</dd></dl><dl class="comment_item comment_topic" id="comment_item_3410829"><dt class="comment_head" floor="111">111楼 <span class="user"><a class="username" href="http://blog.csdn.net/xuexingyang" target="_blank">xuexingyang</a> <span class="ptime">2014-01-16 18:45发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3410829" username="xuexingyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/xuexingyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_xuexingyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">老罗，问你个问题：<br>在android系统上，连上蓝牙键盘后，可以使用蓝牙键盘控制android系统了，但是不知道为什么断开蓝牙键盘后，仍然可以使用蓝牙键盘输入一些按键，只是速度有些慢了，请问是怎么回事啊？谢谢</dd></dl><dl class="comment_item comment_topic" id="comment_item_3395153"><dt class="comment_head" floor="110">110楼 <span class="user"><a class="username" href="http://blog.csdn.net/zkw12358" target="_blank">lonuery</a> <span class="ptime">2014-01-13 08:55发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3395153" username="zkw12358"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zkw12358" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zkw12358.jpg" width="40" height="40"></a></dd><dd class="comment_body"><fieldset><legend>引用“u010457784”的评论：</legend>罗老师，请教个问题。我想知道如何才能在android的service中获取按键事件呢？activit...</fieldset><br>同求问，也正在做这方面的东西，但现在毫无头绪</dd></dl><dl class="comment_item comment_topic" id="comment_item_3382441"><dt class="comment_head" floor="109">109楼 <span class="user"><a class="username" href="http://blog.csdn.net/quxingyuan" target="_blank">quxingyuan</a> <span class="ptime">2014-01-08 12:50发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3382441" username="quxingyuan"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/quxingyuan" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_quxingyuan.jpg" width="40" height="40"></a></dd><dd class="comment_body">老罗，正在学习这方面的，能把序列图发送下吗，邮箱740460101@qq.com，谢谢。</dd></dl><dl class="comment_item comment_topic" id="comment_item_3371247"><dt class="comment_head" floor="108">108楼 <span class="user"><a class="username" href="http://blog.csdn.net/u010457784" target="_blank">阿布1991</a> <span class="ptime">2014-01-04 09:45发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3371247" username="u010457784"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/u010457784" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_u010457784.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师，请教个问题。我想知道如何才能在android的service中获取按键事件呢？activity中有onkeyup方法，但是service中没有啊。如果通过ndk c去读，肯定要做个死循环，这样对系统的消耗太大了。请问还有什么好的办法么？？</dd></dl><dl class="comment_item comment_topic" id="comment_item_3306969"><dt class="comment_head" floor="107">107楼 <span class="user"><a class="username" href="http://blog.csdn.net/kongbaidepao" target="_blank">空白的泡</a> <span class="ptime">2013-12-19 16:13发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3306969" username="kongbaidepao"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/kongbaidepao" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_kongbaidepao.jpg" width="40" height="40"></a></dd><dd class="comment_body">老师 好腻害。佩服 佩服= =</dd></dl><dl class="comment_item comment_topic" id="comment_item_3146931"><dt class="comment_head" floor="106">106楼 <span class="user"><a class="username" href="http://blog.csdn.net/sugelawa" target="_blank">sugelawa</a> <span class="ptime">2013-11-14 21:48发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3146931" username="sugelawa"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sugelawa" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_sugelawa.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师，拜读了您的巨著，受益良多，感谢您的工作。<br>有个问题想请教一下，如果想捕获所有的input事件(经过InputReader加工过的)，如何可以做到呢？有没有可能把我的程序注册为接收所有事件的InputChannel?或者有没有可能在InputDispatcher中Hook?非常感谢！</dd><dl class="comment_item comment_reply" id="comment_item_3148241"><dt class="comment_head" floor="106">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2013-11-15 09:31发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3148241" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复sugelawa：只能Hook了</dd><dl class="comment_item comment_reply" id="comment_item_3148567"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/sugelawa" target="_blank">sugelawa</a> <span class="ptime">2013-11-15 10:56发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3148567" username="sugelawa"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sugelawa" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_sugelawa.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复Luoshengyang：非常感谢。另外您以Key Events为例分析了InputReader，但Touch Events更具复杂性，一直没透彻理解，您能否抽空撰文小小分析下以指点路人，将不胜感激？</dd><dl class="comment_item comment_reply" id="comment_item_3149001"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2013-11-15 13:05发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3149001" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复sugelawa：也没有相差多少，主要下面两点：<br>1. 对于Key Event，InputDispatcher直接分发给当前获得焦点的窗口；对于Touch Event，InputDispatcher先计算一下Tounch Point位于哪一个窗口范围，然后再分发给该窗口。<br>2. Move类型的Touch Event，会批量分发，不像其它Event一样，来一个分发一个。</dd><dl class="comment_item comment_reply" id="comment_item_3150737" style="margin-left:0;"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/sugelawa" target="_blank">sugelawa</a> <span class="ptime">2013-11-15 22:39发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3150737" username="sugelawa"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sugelawa" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_sugelawa.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复Luoshengyang：好的，多谢了~</dd></dl></dl></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_2923445"><dt class="comment_head" floor="105">105楼 <span class="user"><a class="username" href="http://blog.csdn.net/iplayvs2008" target="_blank">灵魂悸动</a> <span class="ptime">2013-09-17 13:31发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2923445" username="iplayvs2008"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/iplayvs2008" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_iplayvs2008.jpg" width="40" height="40"></a></dd><dd class="comment_body">Step 20. InputQueue.nativeRegisterInputChannel<br>         这个函数定义在frameworks/base/core/jni/android_view_InputQueue.cpp文件中：---------------------------------老罗，这个从java代码跳到cpp代码，是如何跟踪的？</dd></dl><dl class="comment_item comment_topic" id="comment_item_2817563"><dt class="comment_head" floor="104">104楼 <span class="user"><a class="username" href="http://blog.csdn.net/rongwei84n" target="_blank">rongwei84n</a> <span class="ptime">2013-08-12 10:47发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2817563" username="rongwei84n"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/rongwei84n" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_rongwei84n.jpg" width="40" height="40"></a></dd><dd class="comment_body">和上一篇Android应用程序消息机制 串起来看。非常痛快的感觉！谢谢楼主！<br>顺便说一句，Android4.0的InputQueue.java的回调接口已经换成了InputEventReceiver.java的dispatchInputEvent()方法了，好像这个类名看起来更符合功能点。。<br>再次谢谢楼主精彩的博文。。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2804135"><dt class="comment_head" floor="103">103楼 <span class="user"><a class="username" href="http://blog.csdn.net/hexiaoxiao_love" target="_blank">偷帐号者去屎</a> <span class="ptime">2013-08-07 17:33发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2804135" username="hexiaoxiao_love"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/hexiaoxiao_love" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_hexiaoxiao_love.jpg" width="40" height="40"></a></dd><dd class="comment_body">四张时序图，第一、三张很不清晰，点击看大图也不行。第二、四张有些地方也不够清晰。<br>楼主或者其他好心人有的话发一份到我邮箱，谢谢。<br>552144981@qq.com <br>或者hexiaoxiao_love@163.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2606736"><dt class="comment_head" floor="102">102楼 <span class="user"><a class="username" href="http://blog.csdn.net/chenxiaogang_324" target="_blank">chenxiaogang_324</a> <span class="ptime">2013-04-25 13:03发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2606736" username="chenxiaogang_324"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/chenxiaogang_324" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_chenxiaogang_324.jpg" width="40" height="40"></a></dd><dd class="comment_body">请问您一下，这个键盘消息是直接发送给当前的窗口处理的吗？那power键呢？这个应该是在系统处理的吧?求回答。多谢了。</dd><dl class="comment_item comment_reply" id="comment_item_2607075"><dt class="comment_head" floor="102">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2013-04-25 16:06发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2607075" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复chenxiaogang_324：是的，系统处理，在PhoneWindowManager.interceptKeyBeforeQueueing里面处理。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2602412"><dt class="comment_head" floor="101">101楼 <span class="user"><a class="username" href="http://blog.csdn.net/zlnice515" target="_blank">zlnice515</a> <span class="ptime">2013-04-22 15:27发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2602412" username="zlnice515"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zlnice515" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zlnice515.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师：<br>        你好！看了你这篇博文学习了很多。对键盘响应有了部分了解。我有个问题想请教你一下。就是锁屏密码锁界面上，点击输入框弹出键盘进行输入，随便输入几个字符后点击backspace键进行回退，发现用第三方键盘进行删除，点击一次删除了2个字符，但是用google输入法进行上述操作点击一次就删除一个字符。开始以为是三方输入法的问题，但是我在setting里面设置密码锁屏的地方进行上面描述测试又是正常的。所以想请教下这种问题会出现在哪里？如果跟这类问题的切入点是什么地方？比如在什么地方加log打日志来跟进。还请罗老师指点迷津。谢谢</dd></dl><dl class="comment_item comment_topic" id="comment_item_2599555"><dt class="comment_head" floor="100">100楼 <span class="user"><a class="username" href="http://blog.csdn.net/pochuanpiao" target="_blank">pochuanpiao</a> <span class="ptime">2013-04-19 13:39发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2599555" username="pochuanpiao"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/pochuanpiao" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_pochuanpiao.jpg" width="40" height="40"></a></dd><dd class="comment_body">老罗，函数handleReceiveCallback的第二个参数events，是表示的channel的异常信息吗？<br>可以解释下吗？</dd><dl class="comment_item comment_reply" id="comment_item_2600042"><dt class="comment_head" floor="100">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2013-04-19 18:26发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2600042" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复pochuanpiao：events表示发生的事件的类型，你看看epoll怎么用就会知道的了。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2570533"><dt class="comment_head" floor="99">99楼 <span class="user"><a class="username" href="http://blog.csdn.net/red5613" target="_blank">red5613</a> <span class="ptime">2013-03-28 15:06发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2570533" username="red5613"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/red5613" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_red5613.jpg" width="40" height="40"></a></dd><dd class="comment_body">对整个android系统的运作流程了解的太通透了，我现在连怎么延长长按键时间都还不会，膜拜呀</dd></dl><dl class="comment_item comment_topic" id="comment_item_2554402"><dt class="comment_head" floor="98">98楼 <span class="user"><a class="username" href="http://blog.csdn.net/llyrike" target="_blank">llyrike</a> <span class="ptime">2013-03-14 18:42发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2554402" username="llyrike"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/llyrike" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_llyrike.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师，您好！<br>我在做的不是中规中矩的android手机，stm8控制一个按键盘，并通过串口与跑android的主芯片通信，这红情况下我如何把返回、快进等这样的功能对应到按键上呢？<br>还是指点，非常感谢。</dd><dl class="comment_item comment_reply" id="comment_item_2554841"><dt class="comment_head" floor="98">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2013-03-15 09:46发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2554841" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复llyrike：Android系统本来就是支持外接键盘的，只要有相应的驱动就行了。。。</dd><dl class="comment_item comment_reply" id="comment_item_2576488"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/llyrike" target="_blank">llyrike</a> <span class="ptime">2013-04-02 13:26发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2576488" username="llyrike"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/llyrike" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_llyrike.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复Luoshengyang：俺也想要时序图，罗老师。非常感谢</dd></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_2552309"><dt class="comment_head" floor="97">97楼 <span class="user"><a class="username" href="http://blog.csdn.net/zbl_zbl" target="_blank">zbl_zbl</a> <span class="ptime">2013-03-13 10:55发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2552309" username="zbl_zbl"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zbl_zbl" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zbl_zbl.jpg" width="40" height="40"></a></dd><dd class="comment_body">老罗的书比博客还详细。支持下！<br>罗哥有没有打算研究下Android触屏事件的处理？期待这方面的博客。<br>提个建议啊，能不能博客里所有的序列图提供个下载链接或者共享到群里，在这里面是真心看不清啊。</dd><dl class="comment_item comment_reply" id="comment_item_2552325"><dt class="comment_head" floor="97">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2013-03-13 11:01发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2552325" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复zbl_zbl：触屏事件和键盘事件的处理流程几乎是一样，只是可能有些细节不一样，鼓励大家举一反三，因为Android系统的东西实在是太多了，实在是无法面面俱到。序列图其实在群共享里有的，我早就上传上去了。</dd><dl class="comment_item comment_reply" id="comment_item_2552361"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/zbl_zbl" target="_blank">zbl_zbl</a> <span class="ptime">2013-03-13 11:19发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2552361" username="zbl_zbl"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zbl_zbl" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zbl_zbl.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复Luoshengyang：欣赏你的态度！！！！<br>貌似群共享里的序列图不全啊</dd><dl class="comment_item comment_reply" id="comment_item_2552373"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2013-03-13 11:26发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2552373" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复zbl_zbl：后面涉及到UI架构的文章的图还没有上传，写完有时间再整理一下上传。</dd></dl></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_2548416"><dt class="comment_head" floor="96">96楼 <span class="user"><a class="username" href="http://blog.csdn.net/wo4chenkewen" target="_blank">达芬奇特斯拉</a> <span class="ptime">2013-03-08 19:13发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2548416" username="wo4chenkewen"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/wo4chenkewen" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_wo4chenkewen.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师，<br>神人啊，求收我等为徒。 学习android童鞋，我看都看累了。我向你发了邮件，不知道你收到了没有。还有你能写android4.0的书吗？我希望你能加我邮件，我邮件地址：wo4chenkewen@gmail.com</dd><dl class="comment_item comment_reply" id="comment_item_2548997"><dt class="comment_head" floor="96">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2013-03-09 17:34发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2548997" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复wo4chenkewen：没有计划再出书了，看博客吧。。。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2540933"><dt class="comment_head" floor="95">95楼 <span class="user"><a class="username" href="http://blog.csdn.net/gu_yue" target="_blank">gu_yue</a> <span class="ptime">2013-02-28 15:15发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2540933" username="gu_yue"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/gu_yue" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_gu_yue.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师，请教两个问题。<br>1、在快速敲击键盘的过程中，启动一个Activity。有时某一个键的down被第一个Activity得到了，up被新启动的Activity得到。怎么样防止这种情况发生呀？<br>2、偶尔ViewRoot会Dispatching key KeyEvent 两次给新启动的应用（按键很快的时候。google的pinyin输入法为默认输入法时，其它的输入法没问题。），在新启动的应用中会有该键的两次onKeyDown，一次onKeyUp（确认InputChannel只传输了一次该键值的down和up）。<br>   请不吝赐教。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2538481"><dt class="comment_head" floor="94">94楼 <span class="user"><a class="username" href="http://blog.csdn.net/cpwolaichile" target="_blank">cpwolaichile</a> <span class="ptime">2013-02-26 14:44发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2538481" username="cpwolaichile"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/cpwolaichile" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_cpwolaichile.jpg" width="40" height="40"></a></dd><dd class="comment_body">需要时序图阿<br>382577110@qq.com<br>Thanks</dd></dl><dl class="comment_item comment_topic" id="comment_item_2536236"><dt class="comment_head" floor="93">93楼 <span class="user"><a class="username" href="http://blog.csdn.net/cpwolaichile" target="_blank">cpwolaichile</a> <span class="ptime">2013-02-23 15:10发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2536236" username="cpwolaichile"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/cpwolaichile" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_cpwolaichile.jpg" width="40" height="40"></a></dd><dd class="comment_body">Hi all :<br><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/luoshengyang/article/details/6882903#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 859px; top: 98463px; width: 18px; height: 18px; z-index: 99;"><embed id="ZeroClipboardMovie_160" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="18" height="18" name="ZeroClipboardMovie_160" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=160&amp;width=18&amp;height=18" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>snprintf(keylayoutFilename,&nbsp;</span><span class="keyword">sizeof</span><span>(keylayoutFilename),&nbsp;</span><span class="string">"%s/usr/keylayout/%s.kl"</span><span>,&nbsp;root,&nbsp;tmpfn);&nbsp;&nbsp;</span></span></li></ol></div><pre name="code2" class="cpp" style="display: none;">snprintf(keylayoutFilename, sizeof(keylayoutFilename), "%s/usr/keylayout/%s.kl", root, tmpfn);
</pre><br>Good! However,I don't know how to loading the keylayout files.for example(Generic.kl qwerty.kl)<br> Not in EventHub.cpp$getEvent(..) <br>Not in framework/base/libs/androidfw/ <br>Not in framework/base/service/input<br>base on Android4.1!<br>I need yours help!</dd><dl class="comment_item comment_reply" id="comment_item_2610195"><dt class="comment_head" floor="93">Re: <span class="user"><a class="username" href="http://blog.csdn.net/sxhebing" target="_blank">sxhebing</a> <span class="ptime">2013-04-27 17:45发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2610195" username="sxhebing"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sxhebing" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_sxhebing.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复cpwolaichile：Hello, it will called loadConfigurationLocked(device) in EventHub::openDeviceLocked  base on android 4.1.finally it will called getInputDeviceConfigurationFilePathByDeviceIdentifier .you can find it in ./base/libs/androidfw/InputDevice.cpp  . it will load the file's name by device-&gt;identifier.name and  type by INPUT_DEVICE_CONFIGURATION_FILE_TYPE_CONFIGURATION (default is 0 that is  .idc file, so if you want to load *.kl,maybe change it from 0 to 1.) I hope  it can be helpful for you!</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2530245"><dt class="comment_head" floor="92">92楼 <span class="user"><a class="username" href="http://blog.csdn.net/xuyss" target="_blank">xuyss</a> <span class="ptime">2013-02-16 17:19发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2530245" username="xuyss"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/xuyss" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_xuyss.jpg" width="40" height="40"></a></dd><dd class="comment_body">mark</dd></dl><dl class="comment_item comment_topic" id="comment_item_2500023"><dt class="comment_head" floor="91">91楼 <span class="user"><a class="username" href="http://blog.csdn.net/victorywu" target="_blank">victorywu</a> <span class="ptime">2013-01-10 20:50发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2500023" username="victorywu"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/victorywu" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_victorywu.jpg" width="40" height="40"></a></dd><dd class="comment_body">大哥 我崇拜你 。<br>可否讲解一下android对多点触控上报点的计算方式，<br>条件：注意触摸屏支持多点，但是不上传tracking_id，<br>可否讲解这种情况下input是如何对多点进行计算的。<br>谢谢，可否要一个联系方式 加我 QQ 493316701。<br>不胜感激。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2494694"><dt class="comment_head" floor="90">90楼 <span class="user"><a class="username" href="http://blog.csdn.net/zhangfu328" target="_blank">孤独的根号san</a> <span class="ptime">2013-01-07 16:49发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2494694" username="zhangfu328"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zhangfu328" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zhangfu328.jpg" width="40" height="40"></a></dd><dd class="comment_body">是否可以把时序图也发一张给我?823041435@qq.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2481512"><dt class="comment_head" floor="89">89楼 <span class="user"><a class="username" href="http://blog.csdn.net/wangyuexiongqi" target="_blank">未知发布者</a> <span class="ptime">2012-12-25 17:22发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2481512" username="wangyuexiongqi"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/wangyuexiongqi" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_wangyuexiongqi.jpg" width="40" height="40"></a></dd><dd class="comment_body">求时序图一张<br>nutsryan@qq.com 不胜感激</dd></dl><dl class="comment_item comment_topic" id="comment_item_2472172"><dt class="comment_head" floor="88">88楼 <span class="user"><a class="username" href="http://blog.csdn.net/neet0730" target="_blank">neet0730</a> <span class="ptime">2012-12-17 19:08发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2472172" username="neet0730"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/neet0730" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_neet0730.jpg" width="40" height="40"></a></dd><dd class="comment_body">忘了附上電郵@@<br>neet0720@gmail.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2472171"><dt class="comment_head" floor="87">87楼 <span class="user"><a class="username" href="http://blog.csdn.net/neet0730" target="_blank">neet0730</a> <span class="ptime">2012-12-17 19:07发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2472171" username="neet0730"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/neet0730" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_neet0730.jpg" width="40" height="40"></a></dd><dd class="comment_body">老羅的分析非常地給力阿!受益良多<br>可否也發一張時序圖給我呢! <br>非常感謝!!!!!!!</dd></dl><dl class="comment_item comment_topic" id="comment_item_2456241"><dt class="comment_head" floor="86">86楼 <span class="user"><a class="username" href="http://blog.csdn.net/lhzhang1985" target="_blank">lhzhang1985</a> <span class="ptime">2012-12-05 09:36发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2456241" username="lhzhang1985"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/lhzhang1985" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_lhzhang1985.jpg" width="40" height="40"></a></dd><dd class="comment_body">文章很精彩，很受益。就是时序图有些看不清楚，不然看起来更加直观，可否将本文的时序图发一份给我。非常感谢。<br>470924008@qq.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2450899"><dt class="comment_head" floor="85">85楼 <span class="user"><a class="username" href="http://blog.csdn.net/blackzw" target="_blank">blackzw</a> <span class="ptime">2012-11-30 10:49发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2450899" username="blackzw"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/blackzw" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_blackzw.jpg" width="40" height="40"></a></dd><dd class="comment_body">我也想要一份时序图，里面的两张我都看不清楚，谢谢。<br>blackzwt811c@163.com<br>我也想知道这种画时序图的软件叫什么名字。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2442801"><dt class="comment_head" floor="84">84楼 <span class="user"><a class="username" href="http://blog.csdn.net/wanqiushengt" target="_blank">wanqiushengt</a> <span class="ptime">2012-11-23 12:14发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2442801" username="wanqiushengt"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/wanqiushengt" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_wanqiushengt.jpg" width="40" height="40"></a></dd><dd class="comment_body">老罗很强大，准备买书去。同时求时序图：wanqiusheng@126.com，感激不尽！</dd></dl><dl class="comment_item comment_topic" id="comment_item_2427951"><dt class="comment_head" floor="83">83楼 <span class="user"><a class="username" href="http://blog.csdn.net/sadamoo" target="_blank">sadamoo</a> <span class="ptime">2012-11-09 16:35发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2427951" username="sadamoo"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sadamoo" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_sadamoo.jpg" width="40" height="40"></a></dd><dd class="comment_body">是否可以把时序图发一张给我。你忠实fans<br>1210577@qq.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2427950"><dt class="comment_head" floor="82">82楼 <span class="user"><a class="username" href="http://blog.csdn.net/sadamoo" target="_blank">sadamoo</a> <span class="ptime">2012-11-09 16:34发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2427950" username="sadamoo"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sadamoo" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_sadamoo.jpg" width="40" height="40"></a></dd><dd class="comment_body">是否可以把时序图发一张给我。你忠实fans<br>12105770@qq.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2422294"><dt class="comment_head" floor="81">81楼 <span class="user"><a class="username" href="http://blog.csdn.net/abc19842008" target="_blank">abc19842008</a> <span class="ptime">2012-11-04 23:26发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2422294" username="abc19842008"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/abc19842008" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_abc19842008.jpg" width="40" height="40"></a></dd><dd class="comment_body">求后续几篇文章的时序图，刚买了你的书，没有后续几个主题，求图。</dd><dl class="comment_item comment_reply" id="comment_item_2422300"><dt class="comment_head" floor="81">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2012-11-04 23:34发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2422300" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复abc19842008：后面SurfaceFlinger这个系列的文章还有一篇没写完，等写完发出来之后，再把里面的序列图放出来。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2399951"><dt class="comment_head" floor="80">80楼 <span class="user"><a class="username" href="http://blog.csdn.net/hudengjun8748" target="_blank">hudengjun8748</a> <span class="ptime">2012-10-14 11:03发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2399951" username="hudengjun8748"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/hudengjun8748" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_hudengjun8748.jpg" width="40" height="40"></a></dd><dd class="comment_body">老罗，你的书什么时候出？现在一直在做一个添加类似电源键的物理按键的项目，麻烦发把时序图发我一下，谢谢！1285723173＠qq.com</dd><dl class="comment_item comment_reply" id="comment_item_2400011"><dt class="comment_head" floor="80">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2012-10-14 11:56发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2400011" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复hudengjun8748：已经出了~看这里：http://blog.csdn.net/luoshengyang/article/details/7409491</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2389760"><dt class="comment_head" floor="79">79楼 <span class="user"><a class="username" href="http://blog.csdn.net/applepiekiwi" target="_blank">applepiekiwi</a> <span class="ptime">2012-10-03 02:29发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2389760" username="applepiekiwi"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/applepiekiwi" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_applepiekiwi.jpg" width="40" height="40"></a></dd><dd class="comment_body">非常详细, 可否给我一份张序图 applepiekiwi@gmail.com 十分感谢</dd></dl><dl class="comment_item comment_topic" id="comment_item_2386654"><dt class="comment_head" floor="78">78楼 <span class="user"><a class="username" href="http://blog.csdn.net/heikefangxian23" target="_blank">heikefangxian23</a> <span class="ptime">2012-09-28 09:10发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2386654" username="heikefangxian23"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/heikefangxian23" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_heikefangxian23.jpg" width="40" height="40"></a></dd><dd class="comment_body">楼主很有耐心，也很有毅力！！</dd></dl><dl class="comment_item comment_topic" id="comment_item_2382444"><dt class="comment_head" floor="77">77楼 <span class="user"><a class="username" href="http://blog.csdn.net/Ucool2007" target="_blank">Ucool2007</a> <span class="ptime">2012-09-25 15:30发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2382444" username="Ucool2007"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Ucool2007" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_ucool2007.jpg" width="40" height="40"></a></dd><dd class="comment_body">求时序图 一张<br>liucoolhao@gmail.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2381560"><dt class="comment_head" floor="76">76楼 <span class="user"><a class="username" href="http://blog.csdn.net/haly321" target="_blank">haly321</a> <span class="ptime">2012-09-24 18:44发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2381560" username="haly321"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/haly321" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_haly321.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师，能否给我一份时序图，谢谢了。249576691@qq.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2377637"><dt class="comment_head" floor="75">75楼 <span class="user"><a class="username" href="http://blog.csdn.net/finaldays" target="_blank">finaldays</a> <span class="ptime">2012-09-20 14:02发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2377637" username="finaldays"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/finaldays" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_finaldays.jpg" width="40" height="40"></a></dd><dd class="comment_body">版主您好，可否也发送一张时序图给我？<br>snowdancer@gmail.com<br><br>十分感谢</dd></dl><dl class="comment_item comment_topic" id="comment_item_2365666"><dt class="comment_head" floor="74">74楼 <span class="user"><a class="username" href="http://blog.csdn.net/ppcst" target="_blank">ppcst</a> <span class="ptime">2012-09-07 16:50发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2365666" username="ppcst"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/ppcst" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_ppcst.jpg" width="40" height="40"></a></dd><dd class="comment_body">老罗，我想在APK中的service里面获得键盘按键的一个特殊按键值，service中没有API可以获取，用NDK直接打开节点会有权限的问题。不知道可以在framework层获取吗？怎么获取？</dd></dl><dl class="comment_item comment_topic" id="comment_item_2363992"><dt class="comment_head" floor="73">73楼 <span class="user"><a class="username" href="http://blog.csdn.net/happy_6678" target="_blank">happy_6678</a> <span class="ptime">2012-09-06 09:58发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2363992" username="happy_6678"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/happy_6678" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_happy_6678.jpg" width="40" height="40"></a></dd><dd class="comment_body">博主，可否把这些时序图发一下，另存为后放大也是糊的，看不清拉，117559235@qq.com,谢谢了</dd></dl><dl class="comment_item comment_topic" id="comment_item_2361767"><dt class="comment_head" floor="72">72楼 <span class="user"><a class="username" href="http://blog.csdn.net/maggiccrystal_3" target="_blank">maggiccrystal_3</a> <span class="ptime">2012-09-04 11:25发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2361767" username="maggiccrystal_3"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/maggiccrystal_3" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_maggiccrystal_3.jpg" width="40" height="40"></a></dd><dd class="comment_body">嗯，我已经写了，谢谢</dd></dl><dl class="comment_item comment_topic" id="comment_item_2361108"><dt class="comment_head" floor="71">71楼 <span class="user"><a class="username" href="http://blog.csdn.net/maggiccrystal_3" target="_blank">maggiccrystal_3</a> <span class="ptime">2012-09-03 18:12发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2361108" username="maggiccrystal_3"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/maggiccrystal_3" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_maggiccrystal_3.jpg" width="40" height="40"></a></dd><dd class="comment_body">你好罗老师，我看了你这上面讲解，我想请教一下：如果我activity中要获取按键值 怎么调用？</dd><dl class="comment_item comment_reply" id="comment_item_2361351"><dt class="comment_head" floor="71">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2012-09-03 22:31发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2361351" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复maggiccrystal_3：重写一下Activity的成员函数onKeyDown、onKeyUp和onKeyMultiple不就行了？</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2353111"><dt class="comment_head" floor="70">70楼 <span class="user"><a class="username" href="http://blog.csdn.net/love_sarp001" target="_blank">love_sarp001</a> <span class="ptime">2012-08-27 11:06发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2353111" username="love_sarp001"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/love_sarp001" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_love_sarp001.jpg" width="40" height="40"></a></dd><dd class="comment_body">我在写应用demo的时候调用<br> open("/dev/input/event", O_RDONLY);<br>出现权限问题直接是返回了-1<br>请问老罗这个问题要怎么解决呢。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2350826"><dt class="comment_head" floor="69">69楼 <span class="user"><a class="username" href="http://blog.csdn.net/qwrqweertrewr" target="_blank">qwrqweertrewr</a> <span class="ptime">2012-08-24 17:00发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2350826" username="qwrqweertrewr"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/qwrqweertrewr" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_qwrqweertrewr.jpg" width="40" height="40"></a></dd><dd class="comment_body">非常感谢你的详细解说，解决了我的很多困惑。谢谢你~~能不给我发一份时序图？renhexiang@gmail.com~</dd></dl><dl class="comment_item comment_topic" id="comment_item_2341026"><dt class="comment_head" floor="68">68楼 <span class="user"><a class="username" href="http://blog.csdn.net/zyc945" target="_blank">zyc945</a> <span class="ptime">2012-08-17 12:59发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2341026" username="zyc945"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zyc945" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zyc945.jpg" width="40" height="40"></a></dd><dd class="comment_body">设置到native层的流程我感觉应该是这样的：<br>   sWindowSession.add-&gt;WindowManagerService.addWindow-&gt;<br>   WindowManagerService.addWindowToListInOrderLocked-&gt;<br>   WindowManagerService.updateFocusedWindowLocked-&gt;<br>   InputMonitor.setInputFocusLw-&gt;<br>   updateInputWindowsLw<br>   <br>   您觉得呢？</dd><dl class="comment_item comment_reply" id="comment_item_2341032"><dt class="comment_head" floor="68">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2012-08-17 13:03发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2341032" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复zyc945：对的，第2小了部分内容是有问题，之前已经有网友发现了，前面的评论也有提到过：<br>-------------------------------------------------------------<br>声明&amp;致歉：在解决@foresee321同学提出的问题中，发现了本文的一个重大错误：在应用程序注册键盘消息接收通道的过程中，设置FocusedWindow的Step 5不是由从step 4进入的，因此，Step 2到Step 4不应该出现在这里。设置InputWindow的InputChannel的地方是在 Step 11中，Step 11执行完创建和注册InputChannel之后，再经过finishUpdateFocusedWindowAfterAssignLayersLocked<br>和setInputFcousLw两个函数调用进入到Step 5中。进入到Step 5之后，后面的步骤是正确的。这个错误给大家带来的不便，老罗表示谦意！再次感谢@foresee321同学！也欢迎大家提出问题，老罗尽力解答。<br>-------------------------------------------------</dd><dl class="comment_item comment_reply" id="comment_item_2341072"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/zyc945" target="_blank">zyc945</a> <span class="ptime">2012-08-17 13:32发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2341072" username="zyc945"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zyc945" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zyc945.jpg" width="40" height="40"></a></dd><dd class="comment_body">恩，谢谢你的回复，我没有看到之前的评论，不好意思，看你的文章让我学到了许多东西。谢谢！回复Luoshengyang：</dd></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_2341025"><dt class="comment_head" floor="67">67楼 <span class="user"><a class="username" href="http://blog.csdn.net/zyc945" target="_blank">zyc945</a> <span class="ptime">2012-08-17 12:59发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2341025" username="zyc945"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zyc945" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zyc945.jpg" width="40" height="40"></a></dd><dd class="comment_body">您好，有点儿疑问：<br>   2. 应用程序注册键盘消息接收通道的过程分析<br>   当中，设置输入窗口到native层流程好像不是这样的。<br>   从requestLayout-&gt;relayout-&gt;relayoutWIndow-&gt;updateInputWindowsLw<br>   在updateInputWindowsLw中：<br>            final ArrayList&lt;WindowState&gt; windows = mWindows;  <br>            final int N = windows.size();  <br>            for (int i = N - 1; i &gt;= 0; i--) {  <br>                final WindowState child = windows.get(i);  <br>                if (child.mInputChannel == null || child.mRemoved) {<br>                    // Skip this window because it cannot possibly receive input.<br>                    continue;<br>                }<br>                ...<br>            }<br>   此时创建的WindowState还没有加入到mWindows，假设在这个过程中已经加入了，但由于<br>   mInputChannel是在sWindowSession.add方法中创建的，所以此处应为空，也会被   <br>   if (child.mInputChannel == null || child.mRemoved)判断跳过。所以我认为此处没有<br>   将新的windowstate设置到native层。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2335362"><dt class="comment_head" floor="66">66楼 <span class="user"><a class="username" href="http://blog.csdn.net/xukai7" target="_blank">xukai7</a> <span class="ptime">2012-08-13 17:22发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2335362" username="xukai7"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/xukai7" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_xukai7.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗老师，有一个问题我一直很纠结：<br><br>1 UI线程是一个looper循环的闭合框架，如果正处于block状态<br>（MessageQue调用了nativePollOnce），是不是只能从其他线程唤醒（除了timeout之外）？<br><br>2 NativeInputQueue：：handleReceiveCallback的执行我认为应该在非UI线程中：   因为UI线程是带着while()无限循环体的，不会再执行一些别的代码。<br><br>3 handleReceiveCallback最终会调用dispatchKey将消息添加到消息队列，此时才唤醒UI线程继续LOOP循环，读取并处理消息。<br><br>第3点我感肯定理解应该没问题，1,2应该是错误的理解。<br><br>不知道我是否把问题说明白了，期待您的解答。</dd><dl class="comment_item comment_reply" id="comment_item_2335425"><dt class="comment_head" floor="66">Re: <span class="user"><a class="username" href="http://blog.csdn.net/Luoshengyang" target="_blank">罗升阳</a> <span class="ptime">2012-08-13 17:54发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2335425" username="Luoshengyang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Luoshengyang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_luoshengyang.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复xukai7：我明白你的问题。有一点可能你需要再理解一下。UI线程被唤醒之后，不一定是返回到Java层的那个while循环里面去。因为UI线程在睡眠的时候，有可能是被内部的管道唤醒的，也有可能是被其它的文件描述符唤醒的。如果你手头上有源代码的话，看看frameworks/base/libs/utils/Looper.cpp文件里面的Looper::addFd和Looper::pollInner函数就会明白的了。大概这也是为什么2.3不再像以前一样用notify和wait机制来实现消息循环的原因之一吧。</dd><dl class="comment_item comment_reply" id="comment_item_2336106"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/xukai7" target="_blank">xukai7</a> <span class="ptime">2012-08-14 10:51发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2336106" username="xukai7"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/xukai7" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_xukai7.jpg" width="40" height="40"></a></dd><dd class="comment_body">我可以这么理解吗？<br>1 如果内部管道被唤醒，也就是looper::wake（）被执行，则会返回到Java层loop循环，如果是外部唤醒（如有按键或触摸消息），则会执行到UI线程的<br>NativeInputQueue：：handleReceiveCallback。 这样UI线程有两种代码执行路径？<br><br>2 如果在外部唤醒后Java层调用sendMessage函数，则会唤醒内部管道，从而进入到Java的looper循环里去了。</dd></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_2299256"><dt class="comment_head" floor="65">65楼 <span class="user"><a class="username" href="http://blog.csdn.net/pochuanpiao" target="_blank">pochuanpiao</a> <span class="ptime">2012-07-25 11:06发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2299256" username="pochuanpiao"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/pochuanpiao" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_pochuanpiao.jpg" width="40" height="40"></a></dd><dd class="comment_body">很详细呀，时序图可不可以也发给我一份，谢谢!<br>hp103@163.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2282033"><dt class="comment_head" floor="64">64楼 <span class="user"><a class="username" href="http://blog.csdn.net/neet0730" target="_blank">neet0730</a> <span class="ptime">2012-07-13 10:06发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2282033" username="neet0730"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/neet0730" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_neet0730.jpg" width="40" height="40"></a></dd><dd class="comment_body">天啊 真是太詳細了<br>受益良多<br>我也想要一張時序圖<br>感謝<br>neet0720@gmail.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2282030"><dt class="comment_head" floor="63">63楼 <span class="user"><a class="username" href="http://blog.csdn.net/neet0730" target="_blank">neet0730</a> <span class="ptime">2012-07-13 10:05发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2282030" username="neet0730"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/neet0730" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_neet0730.jpg" width="40" height="40"></a></dd><dd class="comment_body">天啊~~太仔細了~~很佩服 很實用<br>我也想要一張時序圖 <br>非常感恩</dd></dl><dl class="comment_item comment_topic" id="comment_item_2279292"><dt class="comment_head" floor="62">62楼 <span class="user"><a class="username" href="http://blog.csdn.net/ksksjipeng" target="_blank">ksksjipeng</a> <span class="ptime">2012-07-10 23:29发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2279292" username="ksksjipeng"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/ksksjipeng" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_ksksjipeng.jpg" width="40" height="40"></a></dd><dd class="comment_body">老罗，能否把你研究所画得这些时序图发我哈, jternence@gmail.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2265134"><dt class="comment_head" floor="61">61楼 <span class="user"><a class="username" href="http://blog.csdn.net/zxciop110" target="_blank">zxciop110</a> <span class="ptime">2012-06-26 18:39发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2265134" username="zxciop110"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zxciop110" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zxciop110.jpg" width="40" height="40"></a></dd><dd class="comment_body">能不能更改软键盘的UI的？  可否实现过？</dd></dl><dl class="comment_item comment_topic" id="comment_item_2261140"><dt class="comment_head" floor="60">60楼 <span class="user"><a class="username" href="http://blog.csdn.net/wanglei3208" target="_blank">一个人的奋斗</a> <span class="ptime">2012-06-20 20:11发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2261140" username="wanglei3208"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/wanglei3208" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_wanglei3208.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗哥，一直在关注你博客！我最近在学习这方便的东西，有很多不懂的地方，可以把你的时序图发一份给我吗？<br>wanglei3208@163.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2244911"><dt class="comment_head" floor="59">59楼 <span class="user"><a class="username" href="http://blog.csdn.net/huangzhenyu1983" target="_blank">huangzhenyu1983</a> <span class="ptime">2012-06-06 14:40发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2244911" username="huangzhenyu1983"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/huangzhenyu1983" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_huangzhenyu1983.jpg" width="40" height="40"></a></dd><dd class="comment_body">建议LZ在时序图中加上进程的标示，可以在时序图的顶端标明各函数分属的进程。：）</dd></dl><dl class="comment_item comment_topic" id="comment_item_2243942"><dt class="comment_head" floor="58">58楼 <span class="user"><a class="username" href="http://blog.csdn.net/Jo__yang" target="_blank">Jo__yang</a> <span class="ptime">2012-06-05 21:00发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2243942" username="Jo__yang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Jo__yang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_jo__yang.jpg" width="40" height="40"></a></dd><dd class="comment_body">牛人啊，小弟新学andriod,佩服之极，看到你的文章，能解我长久以来的困惑，在这感激不尽啊，以后会一直关注你，还有能否也给我发下你的时序图，谢谢啊。<br>我的邮箱：yangjuntry@163.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2243110"><dt class="comment_head" floor="57">57楼 <span class="user"><a class="username" href="http://blog.csdn.net/jiasting" target="_blank">jiasting</a> <span class="ptime">2012-06-05 11:33发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2243110" username="jiasting"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/jiasting" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_jiasting.jpg" width="40" height="40"></a></dd><dd class="comment_body">相当不错，一直关注你，是否可以把时序图发一张给我。<br>  jiasting@126.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2240924"><dt class="comment_head" floor="56">56楼 <span class="user"><a class="username" href="http://blog.csdn.net/yyc279528990" target="_blank">yyc279528990</a> <span class="ptime">2012-06-02 17:10发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2240924" username="yyc279528990"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/yyc279528990" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_yyc279528990.jpg" width="40" height="40"></a></dd><dd class="comment_body">你好,能否可以把时序图发一张给我。谢谢<br>yangyanchang123@126.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2239639"><dt class="comment_head" floor="55">55楼 <span class="user"><a class="username" href="http://blog.csdn.net/heroes177" target="_blank">heroes2</a> <span class="ptime">2012-06-01 09:56发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2239639" username="heroes177"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/heroes177" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_heroes177.jpg" width="40" height="40"></a></dd><dd class="comment_body">您好，是否还可以发时序图给我。<br>heroes2@163.com<br>非常感谢。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2223891"><dt class="comment_head" floor="54">54楼 <span class="user"><a class="username" href="http://blog.csdn.net/yidan923" target="_blank">yidan923</a> <span class="ptime">2012-05-17 18:04发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2223891" username="yidan923"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/yidan923" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_yidan923.jpg" width="40" height="40"></a></dd><dd class="comment_body">看了好久，解释的很仔细，可是我看不清时序图，可否发一份给我？邮箱是：yidan923@163.com   谢谢！</dd></dl><dl class="comment_item comment_topic" id="comment_item_2216709"><dt class="comment_head" floor="53">53楼 <span class="user"><a class="username" href="http://blog.csdn.net/gnf666" target="_blank">gnf666</a> <span class="ptime">2012-05-15 18:02发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2216709" username="gnf666"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/gnf666" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_gnf666.jpg" width="40" height="40"></a></dd><dd class="comment_body">罗兄，一直在关注你的文章，分析得都很透彻。可否把这些文章中的时序图发一份给我，g_nf@163.com，以方理更好的理解代码，十分感谢！</dd></dl><dl class="comment_item comment_topic" id="comment_item_2207721"><dt class="comment_head" floor="52">52楼 <span class="user"><a class="username" href="http://blog.csdn.net/wkunking" target="_blank">wkunking</a> <span class="ptime">2012-05-07 18:50发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2207721" username="wkunking"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/wkunking" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_wkunking.jpg" width="40" height="40"></a></dd><dd class="comment_body">好文，图确实看不清，能否帮我发到wkunwking@gmail.com,Thanks!</dd></dl><dl class="comment_item comment_topic" id="comment_item_2204716"><dt class="comment_head" floor="51">51楼 <span class="user"><a class="username" href="http://blog.csdn.net/lxj_0734" target="_blank">lxj_0734</a> <span class="ptime">2012-05-04 16:00发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2204716" username="lxj_0734"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/lxj_0734" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_lxj_0734.jpg" width="40" height="40"></a></dd><dd class="comment_body">分析得太详细了，可否把时序时发给我<br>lxj_0734@163.com       谢谢</dd></dl><dl class="comment_item comment_topic" id="comment_item_2176487"><dt class="comment_head" floor="50">50楼 <span class="user"><a class="username" href="http://blog.csdn.net/zht2004012539" target="_blank">zht2004012539</a> <span class="ptime">2012-04-10 16:09发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2176487" username="zht2004012539"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zht2004012539" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_zht2004012539.jpg" width="40" height="40"></a></dd><dd class="comment_body">同求图~~<br>283632694@qq.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2172696"><dt class="comment_head" floor="49">49楼 <span class="user"><a class="username" href="http://blog.csdn.net/lenomon" target="_blank">lenomon</a> <span class="ptime">2012-04-07 13:40发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2172696" username="lenomon"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/lenomon" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_lenomon.jpg" width="40" height="40"></a></dd><dd class="comment_body">这篇文章应该你能给增加些经验，<a href="http://orgcent.com/android-key-event-mechanism/" target="_blank">Android事件传递机制【按键事件】</a></dd></dl><dl class="comment_item comment_topic" id="comment_item_2171394"><dt class="comment_head" floor="48">48楼 <span class="user"><a class="username" href="http://blog.csdn.net/coolpine" target="_blank">coolpine</a> <span class="ptime">2012-04-06 11:07发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2171394" username="coolpine"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/coolpine" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_coolpine.jpg" width="40" height="40"></a></dd><dd class="comment_body">请教您一个问题：我知道可以在新线程中通过主线程的handle发送消息到主线程的message queue；那么，当响应按键事件时，android系统是否也是通过消息，将事件消息发送到同一个message queue中呢？按键消息是否比通过handle发送的消息优先级更高？请您指教。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2140434"><dt class="comment_head" floor="47">47楼 <span class="user"><a class="username" href="http://blog.csdn.net/xiongli880612" target="_blank">xpple</a> <span class="ptime">2012-03-22 15:51发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2140434" username="xiongli880612"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/xiongli880612" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_xiongli880612.jpg" width="40" height="40"></a></dd><dd class="comment_body">( ⊙o⊙ )哇，文章写得真不错！</dd></dl><dl class="comment_item comment_topic" id="comment_item_2138583"><dt class="comment_head" floor="46">46楼 <span class="user"><a class="username" href="http://blog.csdn.net/koko7958" target="_blank">koko7958</a> <span class="ptime">2012-03-21 11:13发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2138583" username="koko7958"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/koko7958" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_koko7958.jpg" width="40" height="40"></a></dd><dd class="comment_body">太好了，太强大了，比市面上好多SB书好多了，强烈支持老罗出书。我也要一下时序图，谢谢！<br>286510611@qq.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2132365"><dt class="comment_head" floor="45">45楼 <span class="user"><a class="username" href="http://blog.csdn.net/chenlihuaning" target="_blank">chenlihuaning</a> <span class="ptime">2012-03-15 20:59发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2132365" username="chenlihuaning"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/chenlihuaning" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_chenlihuaning.jpg" width="40" height="40"></a></dd><dd class="comment_body">写的非常好，学习了，谢谢分享，麻烦发个图。<br>13560199765@163.com</dd></dl><dl class="comment_item comment_topic" id="comment_item_2128471"><dt class="comment_head" floor="44">44楼 <span class="user"><a class="username" href="http://blog.csdn.net/memechashang" target="_blank">memechashang</a> <span class="ptime">2012-03-12 22:48发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2128471" username="memechashang"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/memechashang" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_memechashang.jpg" width="40" height="40"></a></dd><dd class="comment_body">不错，不错。。。遇到牛人，好人了 。。。值得欣赏。。。。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2127845"><dt class="comment_head" floor="43">43楼 <span class="user"><a class="username" href="http://blog.csdn.net/cyq1028" target="_blank">cyq1028</a> <span class="ptime">2012-03-12 15:19发表</span>  <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2127845" username="cyq1028"> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/cyq1028" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/3_cyq1028.jpg" width="40" height="40"></a></dd><dd class="comment_body">看都看累了，不晓得你写得累不累</dd></dl><div class="clear"></div></div>
    <div id="comment_bar"><div id="load_comments" page="2">查看更多评论</div></div>
    <div id="comment_form"><div class="guest_link">您还没有登录,请<a href="javascript:void(0);" onclick="javascript:csdn.showLogin(function (dat) {js_logined(dat.data.userName);});">[登录]</a>或<a href="http://passport.csdn.net/account/register?from=http%3A%2F%2Fblog.csdn.net%2Fluoshengyang%2Farticle%2Fdetails%2F6882903">[注册]</a></div></div>

    <div class="announce">
        * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
</div>

<script type="text/javascript">
    var fileName = '6882903';
    var commentscount = 188;
    var islock = false
</script>
<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/comment.js"></script>
    <div id="ad_bot">
    <iframe id="ad_frm_1" frameborder="0" scrolling="no" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ad(1).html" style="border-width: 0px; overflow: hidden; width: 746px; height: 0px;"></iframe></div>
    <script type="text/javascript">
    new Ad(5, 'ad_bot');
    </script>
<div id="report_dialog">
</div>

<div id="d-top" style="bottom:60px;">
      

       <a id="quick-reply" class="btn btn-top q-reply" title="快速回复" style="display:none;">
            <img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/blog-icon-reply.png" alt="快速回复">
        </a>    

    <a id="d-top-a" class="btn btn-top backtop" style="" title="返回顶部" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_huidaodingbu&#39;])">         
         <img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/top.png" alt="TOP">
    </a>
</div>
<script type="text/javascript">
    $(function ()
    {
        $("#ad_frm_0").height("90px");
        
        setTimeout(function(){
            $("#ad_frm_2").height("200px");
        },1000);
        

        if($("#comment_content").length>0)
        {
            $("#quick-reply").show();

            $("#quick-reply").click(function(){
                setEditorFocus();
            });
        }       
     
        var d_top = $('#d-top-a');
        document.onscroll = function ()
        {
            var scrTop = (document.body.scrollTop || document.documentElement.scrollTop);
            if (scrTop > 500)
            {
                d_top.show();
            } else
            {
                d_top.hide();
            }
        }
        $('#d-top-a').click(function ()
        {
            scrollTo(0, 0);
            this.blur();
            return false;
        });
    });
  
</script>
<style type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</style>
<div class="tag_list">
    <h5>
        <a href="http://www.csdn.net/tag/" target="_blank">核心技术类目</a></h5>
    <div class="classify">
<a title="全部主题" href="http://www.csdn.net/tag" target="_blank" onclick="LogClickCount(this,336);">全部主题</a>
<a title="Hadoop" href="http://g.csdn.net/5272865" target="_blank" onclick="LogClickCount(this,336);">Hadoop</a>
<a title="AWS" href="http://g.csdn.net/5272866" target="_blank" onclick="LogClickCount(this,336);">AWS</a>
<a title="移动游戏" href="http://g.csdn.net/5272870" target="_blank" onclick="LogClickCount(this,336);">移动游戏</a>
<a title="Java" href="http://g.csdn.net/5272871" target="_blank" onclick="LogClickCount(this,336);">Java</a>
<a title="Android" href="http://g.csdn.net/5272872" target="_blank" onclick="LogClickCount(this,336);">Android</a>
<a title="iOS" href="http://g.csdn.net/5272873" target="_blank" onclick="LogClickCount(this,336);">iOS</a>
<a title="Swift" href="http://g.csdn.net/5272868" target="_blank" onclick="LogClickCount(this,336);">Swift</a>
<a title="智能硬件" href="http://g.csdn.net/5272869" target="_blank" onclick="LogClickCount(this,336);">智能硬件</a>
<a title="Docker" href="http://g.csdn.net/5272867" target="_blank" onclick="LogClickCount(this,336);">Docker</a>
<a title="OpenStack" href="http://g.csdn.net/5272925" target="_blank" onclick="LogClickCount(this,336);">OpenStack</a>
<a title="VPN" href="http://www.csdn.net/tag/vpn" target="_blank" onclick="LogClickCount(this,336);">VPN</a>
<a title="Spark" href="http://g.csdn.net/5272924" target="_blank" onclick="LogClickCount(this,336);">Spark</a>
<a title="ERP" href="http://www.csdn.net/tag/erp" target="_blank" onclick="LogClickCount(this,336);">ERP</a>
<a title="IE10" href="http://www.csdn.net/tag/ie10" target="_blank" onclick="LogClickCount(this,336);">IE10</a>
<a title="Eclipse" href="http://www.csdn.net/tag/eclipse" target="_blank" onclick="LogClickCount(this,336);">Eclipse</a>
<a title="CRM" href="http://www.csdn.net/tag/crm" target="_blank" onclick="LogClickCount(this,336);">CRM</a>
<a title="JavaScript" href="http://www.csdn.net/tag/javascript" target="_blank" onclick="LogClickCount(this,336);">JavaScript</a>
<a title="数据库" href="http://www.csdn.net/tag/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" onclick="LogClickCount(this,336);">数据库</a>
<a title="Ubuntu" href="http://www.csdn.net/tag/ubuntu" target="_blank" onclick="LogClickCount(this,336);">Ubuntu</a>
<a title="NFC" href="http://www.csdn.net/tag/nfc" target="_blank" onclick="LogClickCount(this,336);">NFC</a>
<a title="WAP" href="http://www.csdn.net/tag/wap" target="_blank" onclick="LogClickCount(this,336);">WAP</a>
<a title="jQuery" href="http://www.csdn.net/tag/jquery" target="_blank" onclick="LogClickCount(this,336);">jQuery</a>
<a title="BI" href="http://www.csdn.net/tag/bi" target="_blank" onclick="LogClickCount(this,336);">BI</a>
<a title="HTML5" href="http://www.csdn.net/tag/html5" target="_blank" onclick="LogClickCount(this,336);">HTML5</a>
<a title="Spring" href="http://www.csdn.net/tag/spring" target="_blank" onclick="LogClickCount(this,336);">Spring</a>
<a title="Apache" href="http://www.csdn.net/tag/apache" target="_blank" onclick="LogClickCount(this,336);">Apache</a>
<a title=".NET" href="http://www.csdn.net/tag/.net" target="_blank" onclick="LogClickCount(this,336);">.NET</a>
<a title="API" href="http://www.csdn.net/tag/api" target="_blank" onclick="LogClickCount(this,336);">API</a>
<a title="HTML" href="http://www.csdn.net/tag/html" target="_blank" onclick="LogClickCount(this,336);">HTML</a>
<a title="SDK" href="http://www.csdn.net/tag/sdk" target="_blank" onclick="LogClickCount(this,336);">SDK</a>
<a title="IIS" href="http://www.csdn.net/tag/iis" target="_blank" onclick="LogClickCount(this,336);">IIS</a>
<a title="Fedora" href="http://www.csdn.net/tag/fedora" target="_blank" onclick="LogClickCount(this,336);">Fedora</a>
<a title="XML" href="http://www.csdn.net/tag/xml" target="_blank" onclick="LogClickCount(this,336);">XML</a>
<a title="LBS" href="http://www.csdn.net/tag/lbs" target="_blank" onclick="LogClickCount(this,336);">LBS</a>
<a title="Unity" href="http://www.csdn.net/tag/unity" target="_blank" onclick="LogClickCount(this,336);">Unity</a>
<a title="Splashtop" href="http://www.csdn.net/tag/splashtop" target="_blank" onclick="LogClickCount(this,336);">Splashtop</a>
<a title="UML" href="http://www.csdn.net/tag/uml" target="_blank" onclick="LogClickCount(this,336);">UML</a>
<a title="components" href="http://www.csdn.net/tag/components" target="_blank" onclick="LogClickCount(this,336);">components</a>
<a title="Windows Mobile" href="http://www.csdn.net/tag/windowsmobile" target="_blank" onclick="LogClickCount(this,336);">Windows Mobile</a>
<a title="Rails" href="http://www.csdn.net/tag/rails" target="_blank" onclick="LogClickCount(this,336);">Rails</a>
<a title="QEMU" href="http://www.csdn.net/tag/qemu" target="_blank" onclick="LogClickCount(this,336);">QEMU</a>
<a title="KDE" href="http://www.csdn.net/tag/kde" target="_blank" onclick="LogClickCount(this,336);">KDE</a>
<a title="Cassandra" href="http://www.csdn.net/tag/cassandra" target="_blank" onclick="LogClickCount(this,336);">Cassandra</a>
<a title="CloudStack" href="http://www.csdn.net/tag/cloudstack" target="_blank" onclick="LogClickCount(this,336);">CloudStack</a>
<a title="FTC" href="http://www.csdn.net/tag/ftc" target="_blank" onclick="LogClickCount(this,336);">FTC</a>
<a title="coremail" href="http://www.csdn.net/tag/coremail" target="_blank" onclick="LogClickCount(this,336);">coremail</a>
<a title="OPhone " href="http://www.csdn.net/tag/ophone" target="_blank" onclick="LogClickCount(this,336);">OPhone </a>
<a title="CouchBase" href="http://www.csdn.net/tag/couchbase" target="_blank" onclick="LogClickCount(this,336);">CouchBase</a>
<a title="云计算" href="http://www.csdn.net/tag/%E4%BA%91%E8%AE%A1%E7%AE%97" target="_blank" onclick="LogClickCount(this,336);">云计算</a>
<a title="iOS6" href="http://www.csdn.net/tag/iOS6" target="_blank" onclick="LogClickCount(this,336);">iOS6</a>
<a title="Rackspace " href="http://www.csdn.net/tag/rackspace" target="_blank" onclick="LogClickCount(this,336);">Rackspace </a>
<a title="Web App" href="http://www.csdn.net/tag/webapp" target="_blank" onclick="LogClickCount(this,336);">Web App</a>
<a title="SpringSide" href="http://www.csdn.net/tag/springside" target="_blank" onclick="LogClickCount(this,336);">SpringSide</a>
<a title="Maemo" href="http://www.csdn.net/tag/maemo" target="_blank" onclick="LogClickCount(this,336);">Maemo</a>
<a title="Compuware" href="http://www.csdn.net/tag/compuware" target="_blank" onclick="LogClickCount(this,336);">Compuware</a>
<a title="大数据" href="http://www.csdn.net/tag/%E5%A4%A7%E6%95%B0%E6%8D%AE" target="_blank" onclick="LogClickCount(this,336);">大数据</a>
<a title="aptech" href="http://www.csdn.net/tag/aptech" target="_blank" onclick="LogClickCount(this,336);">aptech</a>
<a title="Perl" href="http://www.csdn.net/tag/perl" target="_blank" onclick="LogClickCount(this,336);">Perl</a>
<a title="Tornado" href="http://www.csdn.net/tag/tornado" target="_blank" onclick="LogClickCount(this,336);">Tornado</a>
<a title="Ruby" href="http://www.csdn.net/tag/ruby" target="_blank" onclick="LogClickCount(this,336);">Ruby</a>
<a title="Hibernate" href="http://www.csdn.net/hibernate" target="_blank" onclick="LogClickCount(this,336);">Hibernate</a>
<a title="ThinkPHP" href="http://www.csdn.net/tag/thinkphp" target="_blank" onclick="LogClickCount(this,336);">ThinkPHP</a>
<a title="HBase" href="http://www.csdn.net/tag/hbase" target="_blank" onclick="LogClickCount(this,336);">HBase</a>
<a title="Pure" href="http://www.csdn.net/tag/pure" target="_blank" onclick="LogClickCount(this,336);">Pure</a>
<a title="Solr" href="http://www.csdn.net/tag/solr" target="_blank" onclick="LogClickCount(this,336);">Solr</a>
<a title="Angular" href="http://www.csdn.net/tag/angular" target="_blank" onclick="LogClickCount(this,336);">Angular</a>
<a title="Cloud Foundry" href="http://www.csdn.net/tag/cloudfoundry" target="_blank" onclick="LogClickCount(this,336);">Cloud Foundry</a>
<a title="Redis" href="http://www.csdn.net/tag/redis" target="_blank" onclick="LogClickCount(this,336);">Redis</a>
<a title="Scala" href="http://www.csdn.net/tag/scala" target="_blank" onclick="LogClickCount(this,336);">Scala</a>
<a title="Django" href="http://www.csdn.net/tag/django" target="_blank" onclick="LogClickCount(this,336);">Django</a>
<a title="Bootstrap" href="http://www.csdn.net/tag/bootstrap" target="_blank" onclick="LogClickCount(this,336);">Bootstrap</a>
    </div>
</div>


                        <div class="clear">
                        </div>
                    </div>                   
                
            </div>
            <div id="side">
    <div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/Luoshengyang" target="_blank">
    <img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/1_luoshengyang.jpg" title="访问我的空间" style="max-width:90%">
    </a>
    <br>
    <span><a href="http://my.csdn.net/Luoshengyang" class="user_name" target="_blank">罗升阳</a></span>
</div>
<div class="interact">
<a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_guanzhu&#39;])"></a>
<a href="javascript:void(0);" class="letter" onclick="loginto(1)" title="[发私信]"></a>
</div>
<div id="blog_medal">
        <div class="ico_expert" title="CSDN认证专家"></div>
<div id="bms_box"><a href="http://medal.blog.csdn.net/allmedal.aspx" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/columnstar_s.gif" onmouseover="m_over_m(this,0)" onmouseout="m_out_m()" alt=""></a><a href="http://medal.blog.csdn.net/allmedal.aspx" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/holdon_s2.gif" onmouseover="m_over_m(this,1)" onmouseout="m_out_m()" alt=""></a><a href="http://medal.blog.csdn.net/allmedal.aspx" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/blogstar13_s.gif" onmouseover="m_over_m(this,2)" onmouseout="m_out_m()" alt=""></a></div></div>
<ul id="blog_rank">
    <li>访问：<span>4019793次</span></li>
    <li>积分：<span>18233分</span></li>
    <li>排名：<span>第132名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>108篇</span></li>
    <li>转载：<span>0篇</span></li>
    <li>译文：<span>0篇</span></li>
    <li>评论：<span>5717条</span></li>
</ul>
</ul>
</div>


<div id="custom_column_6567056" class="panel">
<ul class="panel_head"><span>博客公告</span></ul>
<ul class="panel_body">
<b><font color="red" size="2">本博客所有文章均为原创，欢迎交流，欢迎转载；转载请勿篡改内容，并且注明出处，禁止用于商业目的，谢谢！</font></b>
</ul>
</div><div id="custom_column_21664874" class="panel">
<ul class="panel_head"><span>图书信息</span></ul>
<ul class="panel_body">
<font color="red"><b>书名：</b></font>
<p>《Android系统源代码情景分析》</p>

<p><a href="http://wenku.it168.com/d_000574719.shtml" target="_blank">试读请点击</a></p>

<p><font color="red"><b>出版社：</b></font></p>
<p>电子工业出版社</p>

<p><font color="red"><b>网店：</b></font></p>

<p>1. <a href="http://product.dangdang.com/product.aspx?product_id=22884086" target="_blank">当当网（满100减20，满200减50）</a></p><p></p>

<p>2. <a href="http://book.360buy.com/11104739.html" target="_blank">京东网（满99减20）</a></p><p></p>

<p>3. <a href="http://www.amazon.cn/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90-%E7%BD%97%E5%8D%87%E9%98%B3/dp/B009OLU8EE" target="_blank">亚马逊网（满100减20，满200减50）</a></p><p></p>

<p>4. <a href="http://product.china-pub.com/3684413" target="_blank">互动出版网</a></p><p></p>

<p>5. <a href="http://www.suning.com/emall/prd_10052_22001_-7_3435777_.html" target="_blank">苏宁易购网</a></p><p></p>

<p><a href="http://s.etao.com/search?spm=1002.8.1.1386.g76Rk3&q=Android%CF%B5%CD%B3%D4%B4%B4%FA%C2%EB%C7%E9%BE%B0%B7%D6%CE%F6&style=list&initiative_id=etao_20121011&pn=1&sort=sale-desc" target="_blank">比一比谁更实惠</a></p>

<p><font color="red"><b>号外：</b></font></p>

<p>本书繁体版已经成功输出到台湾</p>

<p></p>
</ul>
</div><div id="custom_column_21603386" class="panel">
<ul class="panel_head"><span>联系方式</span></ul>
<ul class="panel_body">
<font color="red"><b>新浪微博：</b></font>
<p><a href="http://weibo.com/shengyangluo" target="_blank"><font color="red"><b>http://weibo.com/shengyangluo</b></font></a></p><p></p>

<font color="red"><b>QQ交流群：</b></font>
<p><b><font color="red">130112760</font></b>（1000人群，已满）</p>
<p><b><font color="red">248749286</font></b>（1000人群，已满）</p>
<p><b><font color="red">204155322</font></b>（500人群，已满）</p>
<p><b><font color="red">278558417</font></b>（500人群，已满）</p>
<p><b><font color="red">303165655</font></b>（500人群，未满）</p>
<p>PS：请勿同时加入多个群，一经发现，永久封号，谢谢！</p>
</ul>
</div><div id="panel_Category" class="panel">
    <ul class="panel_head"><span>博客专栏</span></ul>
    <ul class="panel_body" id="sp_column">
    <table cellpadding="0" cellspacing="0"><tbody><tr>
    <td style="padding:10px 10px 0 0;">
    <a href="http://blog.csdn.net/column/details/androidluo.html" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/20111107095438958.jpg" style="width:75px;height:75px;"></a>
    </td>
    <td style="padding:10px 0; vertical-align:top;">
    <a href="http://blog.csdn.net/column/details/androidluo.html" target="_blank">老罗的Android之旅</a>
    <p>文章：108篇</p>
    <span>阅读：3989215</span>
    </td>
    </tr></tbody></table>
    </ul>
</div><div id="hotarticls" class="panel">
<ul class="panel_head">
    <span>       
阅读排行    </span>
</ul>

<ul class="panel_body itemlist">
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6559955" title="在Ubuntu上下载、编译和安装Android最新源代码">在Ubuntu上下载、编译和安装Android最新源代码</a><span>(132253)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6618363" title="Android进程间通信（IPC）机制Binder简要介绍和学习计划">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a><span>(122127)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/8923485" title="那两年炼就的Android内功修养">那两年炼就的Android内功修养</a><span>(114291)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" title="Android应用程序启动过程源代码分析">Android应用程序启动过程源代码分析</a><span>(102367)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6568411" title="在Ubuntu上为Android系统编写Linux内核驱动程序">在Ubuntu上为Android系统编写Linux内核驱动程序</a><span>(92252)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6567257" title="Android硬件抽象层（HAL）概要介绍和学习计划">Android硬件抽象层（HAL）概要介绍和学习计划</a><span>(87097)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6564592" title="在Ubuntu上下载、编译和安装Android最新内核源代码（Linux Kernel）">在Ubuntu上下载、编译和安装Android最新内核源代码（Linux Kernel）</a><span>(78711)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6557518" title="Android学习启动篇">Android学习启动篇</a><span>(73335)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6566662" title="如何单独编译Android源代码中的模块">如何单独编译Android源代码中的模块</a><span>(71656)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6621566" title="浅谈Service Manager成为Android进程间通信（IPC）机制Binder守护进程之路">浅谈Service Manager成为Android进程间通信（IPC）机制Binder守护进程之路</a><span>(68075)</span>
</li>
</ul>
</div>
<div id="hotarticls2" class="panel">
<ul class="panel_head"><span>评论排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" title="Android应用程序启动过程源代码分析">Android应用程序启动过程源代码分析</a><span>(337)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6559955" title="在Ubuntu上下载、编译和安装Android最新源代码">在Ubuntu上下载、编译和安装Android最新源代码</a><span>(258)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/8116866" title="《Android系统源代码情景分析》一书勘误">《Android系统源代码情景分析》一书勘误</a><span>(234)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/8923485" title="那两年炼就的Android内功修养">那两年炼就的Android内功修养</a><span>(225)</span>
</li>
<li>
<a href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET.html" title="Android应用程序键盘（Keyboard）消息处理机制分析">Android应用程序键盘（Keyboard）消息处理机制分析</a><span>(188)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6580267" title="在Ubuntu上为Android系统内置Java应用程序测试Application Frameworks层的硬件服务">在Ubuntu上为Android系统内置Java应用程序测试Application Frameworks层的硬件服务</a><span>(174)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/7409491" title="Android博客文章整理">Android博客文章整理</a><span>(167)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6568411" title="在Ubuntu上为Android系统编写Linux内核驱动程序">在Ubuntu上为Android系统编写Linux内核驱动程序</a><span>(165)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/8452527" title="2012年的Android之旅：梦想、学习、坚持、自信、淡定">2012年的Android之旅：梦想、学习、坚持、自信、淡定</a><span>(150)</span>
</li>
<li>
<a href="http://blog.csdn.net/luoshengyang/article/details/6564592" title="在Ubuntu上下载、编译和安装Android最新内核源代码（Linux Kernel）">在Ubuntu上下载、编译和安装Android最新内核源代码（Linux Kernel）</a><span>(137)</span>
</li>
</ul>
</div>
<div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/6882903#comments">Android应用程序键盘（Keyboard）消息处理机制分析</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/zjq2008wd" class="user_name">Ron_Tang</a>:
@Luoshengyang:恩，好的，谢谢！
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/8372924#comments">Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/lee079074256" class="user_name">lee079074256</a>:
mPaddingLeft ,mMarginLeft , mForegroundPaddingLeft...
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/8372924#comments">Android应用程序键盘（Keyboard）消息处理机制分析</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/Luoshengyang" class="user_name">罗升阳</a>:
@zjq2008wd:是的，Binder IPC可以在进程间传递文件描述符，你可以看一下书里面6.5...
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/8452527#comments">2012年的Android之旅：梦想、学习、坚持、自信、淡定</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/hj520wj" class="user_name">法本如是</a>:
是我辈楷模！
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/8452527#comments">Android应用程序键盘（Keyboard）消息处理机制分析</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/zjq2008wd" class="user_name">Ron_Tang</a>:
您好，罗大哥，我是您书的读者。阅读您书，可知InputChannel内含有管道，这个管道应该是Win...
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/8806798#comments">Android应用程序资源的查找过程分析</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/wangqing008" class="user_name">排山和倒海</a>:
mark一下
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/8806798#comments">Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/ritterliu" class="user_name">Ritter_Liu</a>:
@ritterliu:找到了，是HW里控制的，OpenGLRenderer::renderOverd...
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/6618363#comments">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/liuyanggofurther" class="user_name">liuyanggofurther</a>:
第二段第三行是命名管道哟 (命令管道 Named Pipe)
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/8923485#comments">那两年炼就的Android内功修养</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/dadaxiaoxiaode" class="user_name">踏踏实实豪气冲天</a>:
牛人是怎么炼成的？看完你的总结，我就感觉更加确定牛人不是天生的，而是比别人付出了更多，比别人更用心，...
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/luoshengyang/article/details/6744448#comments">Android应用程序发送广播（sendBroadcast）的过程分析</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/luxee" class="user_name">luxee</a>:
@zcwme:可以用am来发送.http://blog.csdn.net/sunrock/artic...
    </p>
    </li>
</ul>
</div>
    </div>
    <div class="clear">
    </div>
</div>

            <div class="clear">
            </div>
        </div>
        

<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/cnick.js"></script>
<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/newblog.min.js"></script>


<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/showblogmedal.ashx"></script>
<script type="text/javascript">
    document.write('<script type="text/javascript" src="http://csdnimg.cn/pubfooter/js/publib_footer.js?' + Math.floor(new Date() / 120000).toString(36) + '="></' + 'script>');
</script><script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/publib_footer.js"></script><link rel="stylesheet" type="text/css" href="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/pub_footer_2012.css"><div id="pub_footerall" class="pub_footerall"><dl><dt></dt> <dd><a href="http://www.csdn.net/company/about.html" target="_blank">公司简介</a>|<a href="http://www.csdn.net/company/recruit.html" target="_blank">招贤纳士</a>|<a href="http://www.csdn.net/company/marketing.html" target="_blank">广告服务</a>|<a href="http://www.csdn.net/company/account.html" target="_blank">银行汇款帐号</a>|<a href="http://www.csdn.net/company/contact.html" target="_blank">联系方式</a>|<a href="http://www.csdn.net/company/statement.html" target="_blank">版权声明</a>|<a href="http://www.csdn.net/company/layer.html" target="_blank">法律顾问</a>|<a href="mailto:webmaster@csdn.net">问题报告</a>|<a target="_blank" href="http://www.csdn.net/friendlink.html">合作伙伴</a>|<a href="http://bbs.csdn.net/forums/Service" target="_blank">论坛反馈</a></dd><dd><a href="http://wpa.qq.com/msgrd?v=3&uin=2355263776&site=qq&menu=yes" target="_blank" class="qq">网站客服</a> <a href="http://wpa.qq.com/msgrd?v=3&uin=2251809102&site=qq&menu=yes" target="_blank" class="qq">杂志客服</a> <a href="http://e.weibo.com/csdnsupport/profile" target="_blank" class="weibo">微博客服</a> <a href="mailto:webmaster@csdn.net" class="email" title="联系邮箱">webmaster@csdn.net</a> <span class="phone" title="服务热线">400-600-2320</span></dd><dd>京&nbsp;ICP&nbsp;证&nbsp;070598&nbsp;号</dd><dd>北京创新乐知信息技术有限公司 版权所有</dd><dd>江苏乐知网络技术有限公司 提供商务支持</dd><dd>Copyright © 1999-2014, CSDN.NET, All Rights Reserved&nbsp;<a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" target="_blank"><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/gongshang_logos.gif" alt="GongshangLogo" title=""></a></dd></dl></div><div id="note1" class="csdn_note" style="display:none; position:absolute; z-index:9999; width:440px">  <span class="notice_top_arrow"><span class="inner"></span></span>  <div class="box"></div></div><div class="csdn_notice_tip" style="display: none; position: absolute; z-index: 9990; width: 170px;">  <iframe src="about:blank" frameborder="0" scrolling="no" style="z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:transparent"></iframe>  <div class="tip_text">您有<strong>0</strong>条新通知</div>  <a href="javascript:void 0" class="close2"></a></div><script id="noticeScript" type="text/javascript" btnid="header_notice_num" wrapid="note1" count="5" subcount="5" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/notify.js"></script>
    <script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/login.js"></script>
<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script><img src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/pv.aspx" border="0" width="0" height="0">
<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/counter.js"></script><script type="text/javascript" charset="UTF-8" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/msg.popup.js"></script>
<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ad-blog.js"></script><script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ad-ms971.js"></script>
<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ad-ms974_2.js"></script>
<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/ad-js979_3.js"></script>

<script type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/count.js"></script><iframe src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/logs.html" frameborder="0" width="0" height="0"></iframe>
<script type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a>"
                    + "<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });
    });
</script>

    </div>
      <!--new top-->
    
    <script id="csdn-toolbar-id" btnid="header_notice_num" wrapid="note1" count="5" subcount="5" type="text/javascript" src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/toolbar.js"></script>
     <!--new top-->


<div id="tag-suggest-pop">
  <div class="relative">
    <div class="close"></div>
    <div class="content"></div>
  </div>
</div><iframe src="./Android应用程序键盘（Keyboard）消息处理机制分析 - 老罗的Android之旅 - 博客频道 - CSDN.NET_files/langchao-download-homepage-daohangtiaoxia-banner-728-90-30k.html" style="width: 1px; height: 1px; position: absolute; visibility: hidden;"></iframe></body></html>